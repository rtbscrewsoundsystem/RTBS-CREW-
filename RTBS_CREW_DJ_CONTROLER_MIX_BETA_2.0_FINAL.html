<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>RTBS CREW DJ CONTROLLER MIX - MOD</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
/* --- SKIN VIRTUAL DJ 8 PLATEADO --- */
body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
    color: #e0e0e0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow-x: hidden;
}

.container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    padding: 20px;
    background: linear-gradient(145deg, #3a3a3a 0%, #2c2c2c 100%);
    border-radius: 12px;
    border: 1px solid #555;
    box-shadow: 
        0 10px 30px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    width: 95%;
    max-width: 1400px;
    margin: auto;
    position: relative;
}

h1 {
    text-align: center;
    margin-top: 0;
    font-size: 24px;
    font-weight: 300;
    letter-spacing: 2px;
    color: #a0a0a0;
    text-shadow: 0 1px 0 rgba(0, 0, 0, 0.8);
    padding-bottom: 10px;
    border-bottom: 1px solid #444;
}

/* --- WAVEFORM SUPERIOR --- */
.waveforms-container-top {
    position: relative;
    width: 100%;
    height: 100px;
    background: linear-gradient(to bottom, #222 0%, #111 100%);
    border: 1px solid #444;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
}

#superimposedWaveformCanvas {
    width: 100%;
    height: 100%;
    display: block;
}

.top-waveform-indicator {
    position: absolute;
    left: 50%;
    top: 0;
    width: 2px;
    height: 100%;
    background: #fff;
    z-index: 15;
    pointer-events: none;
    box-shadow: 0 0 10px #00aaff;
}

/* --- DECK CONTAINERS --- */
.decks-container {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    width: 100%;
    gap: 20px;
}

.deck {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    width: 45%;
    position: relative;
    z-index: 1;
    background: linear-gradient(145deg, #333 0%, #2a2a2a 100%);
    border-radius: 10px;
    padding: 15px;
    border: 1px solid #444;
    box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.05),
        0 5px 15px rgba(0, 0, 0, 0.3);
}

.deck-controls {
    position: absolute;
    top: 15px;
    display: flex;
    gap: 8px;
    z-index: 10;
}

.deck-controls.deck1 {
    left: 15px;
}

.deck-controls.deck2 {
    right: 15px;
}

.deck-button {
    min-width: 60px;
    height: 30px;
    background: linear-gradient(to bottom, #444 0%, #333 100%);
    border: 1px solid #555;
    border-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
    font-size: 10px;
    color: #ccc;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.1s ease;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

.deck-button:hover {
    background: linear-gradient(to bottom, #555 0%, #444 100%);
    transform: translateY(-1px);
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
}

.deck-button:active {
    transform: translateY(1px);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

.sync-button {
    background: linear-gradient(to bottom, #2a4a6a 0%, #1a3a5a 100%);
    border-color: #3a6a9a;
}

/* --- PLATO CON IMAGEN GIRATORIA --- */
.platter {
    width: 180px;
    height: 180px;
    background: url('Proyecto_29.png') center/contain no-repeat;
    border-radius: 50%;
    border: 3px solid #555;
    box-shadow: 
        0 0 20px rgba(0, 0, 0, 0.8),
        inset 0 0 30px rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    z-index: 2;
    cursor: pointer;
    margin-top: 10px;
}

.platter-inner {
    width: 40px;
    height: 40px;
    background: radial-gradient(circle at 30% 30%, #444, #222);
    border-radius: 50%;
    border: 2px solid #666;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 9px;
    color: #aaa;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.5);
}

/* --- CONTROLES DE PITCH VERTICALES --- */
.pitch-control-vertical {
    position: absolute;
    top: 80px;
    height: 180px;
    width: 40px;
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 10;
}

.pitch-control-vertical.deck1 { left: 20px; }
.pitch-control-vertical.deck2 { right: 20px; }

.pitch-control-vertical input[type="range"] {
    -webkit-appearance: slider-vertical;
    width: 30px;
    height: 150px;
    background: linear-gradient(to bottom, #222, #444);
    border-radius: 15px;
    border: 1px solid #555;
    box-shadow: 
        inset 0 2px 5px rgba(0, 0, 0, 0.5),
        0 2px 5px rgba(0, 0, 0, 0.3);
}

.pitch-control-vertical input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 28px;
    height: 28px;
    background: radial-gradient(circle at 30% 30%, #888, #444);
    border-radius: 50%;
    border: 2px solid #aaa;
    box-shadow: 
        0 2px 5px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    cursor: pointer;
}

/* --- KNOBS CIRCULARES PARA EQ Y GAIN --- */
.knob-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    width: 70px;
}

.knob {
    width: 60px;
    height: 60px;
    position: relative;
    background: radial-gradient(circle at 30% 30%, #444, #222);
    border-radius: 50%;
    border: 3px solid #555;
    box-shadow: 
        0 5px 15px rgba(0, 0, 0, 0.5),
        inset 0 2px 5px rgba(0, 0, 0, 0.5);
}

.knob-label {
    font-size: 10px;
    color: #aaa;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.knob-marker {
    position: absolute;
    top: 5px;
    left: 50%;
    width: 2px;
    height: 20px;
    background: #00ccff;
    transform-origin: bottom center;
    transform: translateX(-50%);
    border-radius: 1px;
}

/* --- CONTROLES CENTRALES --- */
.center-controls-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    padding: 20px;
    background: linear-gradient(145deg, #3a3a3a 0%, #2c2c2c 100%);
    border: 1px solid #444;
    border-radius: 12px;
    width: 280px;
    z-index: 3;
    box-shadow: 
        inset 0 1px 0 rgba(255, 255, 255, 0.05),
        0 5px 15px rgba(0, 0, 0, 0.3);
}

/* --- FADERS VERTICALES CENTRADOS --- */
.vertical-fader-container {
    height: 120px;
    width: 30px;
    position: relative;
    background: linear-gradient(to bottom, #222, #333);
    border-radius: 4px;
    border: 1px solid #444;
    padding: 5px;
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
}

.vertical-fader {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    width: 120px;
    height: 20px;
    transform-origin: center;
    transform: rotate(270deg) translateX(-50px);
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -60px;
    margin-top: -10px;
}

.vertical-fader::-webkit-slider-runnable-track {
    background: linear-gradient(to right, #222, #444);
    height: 10px;
    border-radius: 5px;
    border: 1px solid #555;
}

.vertical-fader::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 24px;
    height: 24px;
    background: radial-gradient(circle at 30% 30%, #666, #333);
    border-radius: 50%;
    border: 2px solid #aaa;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    margin-top: -7px;
}

/* --- VU METERS CENTRALES --- */
.vu-meters-central {
    display: flex;
    gap: 20px;
    justify-content: center;
    margin-top: 10px;
}

.vu-meter-central {
    width: 20px;
    height: 100px;
    background: linear-gradient(to bottom, 
        #00ff00 0%, #00ff00 25%,
        #ffff00 25%, #ffff00 50%,
        #ff9900 50%, #ff9900 75%,
        #ff0000 75%, #ff0000 90%,
        #ffffff 90%, #ffffff 100%);
    border-radius: 3px;
    border: 1px solid #333;
    position: relative;
    overflow: hidden;
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
}

.vu-meter-level-central {
    position: absolute;
    bottom: 0;
    width: 100%;
    background: rgba(0, 0, 0, 0.7);
    transition: height 0.1s ease;
}

/* --- CROSSFADER --- */
.crossfader-container {
    width: 100%;
    text-align: center;
    position: relative;
    z-index: 3;
    margin-top: 10px;
}

#crossfader {
    width: 100%;
    height: 30px;
    -webkit-appearance: none;
    background: linear-gradient(to right, #222 0%, #444 50%, #222 100%);
    border-radius: 15px;
    border: 1px solid #555;
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
}

#crossfader::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 40px;
    height: 40px;
    background: radial-gradient(circle at 30% 30%, #666, #333);
    border-radius: 50%;
    border: 2px solid #aaa;
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.5);
}

/* --- BOTONES --- */
.buttons {
    display: flex;
    gap: 10px;
    z-index: 3;
    position: relative;
    justify-content: center;
    flex-wrap: wrap;
}

.button {
    min-width: 70px;
    height: 35px;
    background: linear-gradient(to bottom, #444 0%, #333 100%);
    border: 1px solid #555;
    border-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
    font-size: 11px;
    color: #ccc;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.1s ease;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

.button:hover {
    background: linear-gradient(to bottom, #555 0%, #444 100%);
    transform: translateY(-1px);
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
}

.button:active {
    transform: translateY(1px);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* --- HOT CUES --- */
.hot-cues-and-reverse {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 100%;
}

.hot-cue-button {
    background: linear-gradient(to bottom, #2a4a6a 0%, #1a3a5a 100%);
    border-color: #3a6a9a;
}

.reverse-button {
    background: linear-gradient(to bottom, #6a2a2a 0%, #5a1a1a 100%);
    border-color: #9a3a3a;
    color: #ffaaaa;
}

/* --- EFECTOS --- */
.effect-button-platter {
    width: 45px;
    height: 45px;
    background: linear-gradient(to bottom, #4a2a4a 0%, #3a1a3a 100%);
    border: 2px solid #7a3a7a;
    border-radius: 5px;
    color: #ffaaff;
    font-size: 9px;
    text-align: center;
    line-height: 45px;
    cursor: pointer;
    user-select: none;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

.effect-button-platter.active {
    background: linear-gradient(to bottom, #ff00ff 0%, #cc00cc 100%);
    box-shadow: 0 0 15px #ff00ff;
}

/* --- WAVEFORM INDIVIDUAL --- */
.waveform-deck-container {
    width: 100%;
    height: 80px;
    background: linear-gradient(to bottom, #1a1a1a 0%, #111 100%);
    border: 1px solid #444;
    border-radius: 5px;
    overflow: hidden;
    position: relative;
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
}

.waveform-deck-container.deck1 {
    border-color: #00aa00;
}

.waveform-deck-container.deck2 {
    border-color: #aa0000;
}

/* --- NAVEGACIÓN --- */
.navigation-buttons {
    display: flex;
    gap: 8px;
    margin-top: 5px;
}

.nav-button {
    width: 45px;
    height: 25px;
    background: linear-gradient(to bottom, #333 0%, #222 100%);
    border: 1px solid #444;
    border-radius: 3px;
    color: #ccc;
    font-size: 9px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
    transition: all 0.1s ease;
}

.nav-button:active {
    background: linear-gradient(to bottom, #222 0%, #111 100%);
    transform: translateY(1px);
}

/* --- PROGRESS BAR --- */
.progress-container {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 5px;
    z-index: 10;
    padding: 5px;
    margin-top: 5px;
}

.progress-bar {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 8px;
    background: linear-gradient(to right, #222, #333);
    border-radius: 4px;
    border: 1px solid #444;
    cursor: pointer;
    box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
}

.progress-bar::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: radial-gradient(circle at 30% 30%, #00ccff, #0088cc);
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
}

/* --- LOOP PADS --- */
.loop-pads {
    display: flex;
    gap: 5px;
    margin-top: 10px;
    justify-content: center;
    width: 100%;
    flex-wrap: wrap;
}

.loop-pad {
    width: 40px;
    height: 40px;
    background: linear-gradient(to bottom, #2a4a6a 0%, #1a3a5a 100%);
    border: 1px solid #3a6a9a;
    border-radius: 5px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    font-size: 9px;
    font-weight: bold;
    user-select: none;
    color: #aaccff;
    transition: all 0.1s ease;
}

.loop-pad:active, .loop-pad.active {
    background: linear-gradient(to bottom, #4a8acc 0%, #2a6aaa 100%);
    box-shadow: 0 0 10px #4a8acc;
    transform: translateY(1px);
}

/* --- ANIMACIONES --- */
.platter.playing {
    animation: spin 2s linear infinite;
}

.platter.paused {
    animation-play-state: paused;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* --- POPUPS --- */
#equalizer-popup, #settingsPopup {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(145deg, #3a3a3a 0%, #2c2c2c 100%);
    border: 2px solid #666;
    padding: 20px;
    box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
    z-index: 1000;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    border-radius: 12px;
    min-width: 500px;
}

.close-btn {
    background: linear-gradient(to bottom, #6a2a2a 0%, #5a1a1a 100%);
    color: #ffaaaa;
    border: 1px solid #9a3a3a;
    padding: 8px 20px;
    cursor: pointer;
    margin-top: 10px;
    font-size: 12px;
    border-radius: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
    transition: all 0.2s ease;
}

.close-btn:hover {
    background: linear-gradient(to bottom, #8a3a3a 0%, #6a2a2a 100%);
    transform: translateY(-1px);
}

/* --- SETTINGS BUTTON --- */
#settingsButton {
    position: absolute;
    top: 15px;
    right: 15px;
    width: 40px;
    height: 40px;
    background: linear-gradient(to bottom, #444 0%, #333 100%);
    border: 1px solid #555;
    border-radius: 50%;
    cursor: pointer;
    font-size: 20px;
    color: #ccc;
    text-shadow: 0 1px 0 rgba(0, 0, 0, 0.5);
    z-index: 4;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
}

#settingsButton:hover {
    background: linear-gradient(to bottom, #555 0%, #444 100%);
    transform: translateY(-1px);
    box-shadow: 0 5px 12px rgba(0, 0, 0, 0.4);
}

/* --- Estilos originales necesarios --- */
.eq-group {
    display: flex;
    justify-content: space-around;
    width: 100%;
    gap: 15px;
}

.eq-control {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}

.eq-control label { font-size: 12px; font-weight: bold; }

.eq-on-off { 
    width: 40px; 
    height: 20px; 
    border: 2px solid #00f; 
    background: #333; 
    color: #fff; 
    font-size: 8px; 
    cursor: pointer; 
    border-radius: 5px; 
}

.time-display { 
    display: flex; 
    justify-content: space-between; 
    font-size: 10px; 
}

.hot-cue-marker { 
    position: absolute; 
    width: 2px; 
    height: 100%; 
    background: #0080FF; 
    top: 0; 
    pointer-events:none; 
    z-index:5; 
}

.fader-effects-container {
    display: flex;
    gap: 20px;
    justify-content: center;
    width: 100%;
    align-items: center;
}

.effect-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}

/* Asegurar que los inputs originales estén ocultos pero funcionen */
.rotary-knob {
    display: none;
}

/* Ocultar elementos que no queremos mostrar */
.deck h3, .pitch-controls label, .crossfader-container span, .effect-group h4 {
    display: none !important;
}

/* Mejorar los VU meters */
.vu-meter-container {
    display: none !important; /* Ocultamos los VU meters de abajo */
}

/* Estilos para la fila de knobs con filtro */
.knobs-row {
    display: flex;
    justify-content: space-around;
    width: 100%;
    margin-top: 10px;
}

/* Estilos para el botón de cargar archivo */
.load-file-button {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(to bottom, #2a4a6a 0%, #1a3a5a 100%);
    border: 1px solid #3a6a9a;
    border-radius: 5px;
    padding: 5px 10px;
    font-size: 10px;
    color: #aaccff;
    cursor: pointer;
    z-index: 5;
}

/* BPM Display */
.bpm-display {
    font-size: 11px;
    color: #00cc00;
    font-weight: bold;
    background: rgba(0, 0, 0, 0.5);
    padding: 2px 6px;
    border-radius: 3px;
    position: absolute;
    top: 15px;
    z-index: 10;
}

.bpm-display.deck1 {
    left: 50%;
    transform: translateX(-50%);
}

.bpm-display.deck2 {
    right: 50%;
    transform: translateX(50%);
}
</style>
</head>
<body>

<div class="container">
    <button id="settingsButton" onclick="toggleSettingsPopup()">⚙️</button>
    <h1>RTBS CREW DJ CONTROLLER MIX — MOD</h1>

    <div class="waveforms-container-top">
        <canvas id="superimposedWaveformCanvas"></canvas>
        <div class="top-waveform-indicator"></div>
    </div>

    <div class="decks-container">
        <!-- DECK 1 -->
        <div class="deck" data-deck="1">
            <!-- Controles superiores del deck 1 -->
            <div class="deck-controls deck1">
                <div class="deck-button" id="button1" onclick="playPause(1)">Play</div>
                <div class="deck-button sync-button" id="sync1" onclick="sync(1)">Sync</div>
            </div>
            
            <div class="bpm-display deck1" id="bpmDisplay1">-- BPM</div>
            
            <div class="pitch-control-vertical deck1">
                <input type="range" id="pitch1" min="0.5" max="2" step="0.01" value="1">
            </div>
            
            <div class="platter" id="platter1" onclick="toggleSuperimpose(1)">
                <div class="platter-inner">1</div>
            </div>
            
            <!-- Botón para cargar archivo -->
            <div class="load-file-button" onclick="document.getElementById('fileInput1').click()">CARGAR AUDIO</div>
            <input type="file" id="fileInput1" accept="audio/*" style="display: none;">
            
            <div class="progress-container">
                <input type="range" id="progressBar1" class="progress-bar" min="0" max="1" step="0.001" value="0">
                <div class="time-display">
                    <span id="currentTime1">0:00</span>
                    <span id="duration1">0:00</span>
                </div>
            </div>
            
            <div class="waveform-deck-container deck1">
                <canvas id="waveformCanvas1"></canvas>
                <div class="hot-cue-marker" data-deck="1" style="display: none;"></div>
            </div>
            
            <div class="navigation-buttons">
                <div class="nav-button" onclick="navigateByBeats(1, -4)">-4</div>
                <div class="nav-button" onclick="navigateByBeats(1, 4)">+4</div>
            </div>
            
            <!-- Loop Pads -->
            <div class="loop-pads" id="loopPads1">
                <div class="loop-pad" data-value="0.125" onmousedown="startLoopRoll(1, 0.125)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/8</div>
                <div class="loop-pad" data-value="0.0625" onmousedown="startLoopRoll(1, 0.0625)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/16</div>
                <div class="loop-pad" data-value="0.25" onmousedown="startLoopRoll(1, 0.25)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/4</div>
                <div class="loop-pad" data-value="0.5" onmousedown="startLoopRoll(1, 0.5)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/2</div>
                <div class="loop-pad" data-value="1" onmousedown="startLoopRoll(1, 1)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1</div>
                <div class="loop-pad" data-value="2" onmousedown="startLoopRoll(1, 2)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">2</div>
            </div>
            
            <!-- Knobs circulares CON FILTRO -->
            <div class="knobs-row">
                <div class="knob-container">
                    <div class="knob" id="gainKnob1">
                        <div class="knob-marker" id="gainMarker1"></div>
                    </div>
                    <div class="knob-label">Gain</div>
                </div>
                <div class="knob-container">
                    <div class="knob" id="bassKnob1">
                        <div class="knob-marker" id="bassMarker1"></div>
                    </div>
                    <div class="knob-label">Bass</div>
                </div>
                <div class="knob-container">
                    <div class="knob" id="midKnob1">
                        <div class="knob-marker" id="midMarker1"></div>
                    </div>
                    <div class="knob-label">Mid</div>
                </div>
                <div class="knob-container">
                    <div class="knob" id="trebleKnob1">
                        <div class="knob-marker" id="trebleMarker1"></div>
                    </div>
                    <div class="knob-label">Treble</div>
                </div>
                <!-- FILTRO para deck 1 -->
                <div class="knob-container">
                    <div class="knob" id="filterKnob1">
                        <div class="knob-marker" id="filterMarker1"></div>
                    </div>
                    <div class="knob-label">Filter</div>
                </div>
            </div>
            
            <!-- EQ Kill buttons -->
            <div style="display: flex; justify-content: center; gap: 10px; margin-top: 5px;">
                <button class="button" onclick="toggleEQ('bass', 1)">B Kill</button>
                <button class="button" onclick="toggleEQ('mid', 1)">M Kill</button>
                <button class="button" onclick="toggleEQ('treble', 1)">T Kill</button>
            </div>
            
            <!-- Inputs ocultos para la funcionalidad original -->
            <input type="range" id="bass1" min="-20" max="20" value="0" class="rotary-knob">
            <input type="range" id="mid1" min="-20" max="20" value="0" class="rotary-knob">
            <input type="range" id="treble1" min="-20" max="20" value="0" class="rotary-knob">
            <input type="range" id="gain1" min="0" max="2" step="0.01" value="1" class="rotary-knob">
            <input type="range" id="filter1" min="20" max="22050" step="1" value="22050" class="rotary-knob">
        </div>

        <!-- CONTROLES CENTRALES -->
        <div class="center-controls-container">
            <div class="fader-effects-container">
                <div class="vertical-fader-container">
                    <input type="range" id="volume1" min="0" max="1" step="0.01" value="0.7" class="vertical-fader">
                </div>
                <div class="effect-group">
                    <button class="effect-button-platter" id="effect1-cut" onclick="toggleEffect(1, 'cut')">CUT</button>
                    <button class="effect-button-platter" id="effect1-flanger" onclick="toggleEffect(1, 'flanger')">FLNG</button>
                </div>
                
                <!-- VU Meters centrales SOLO ESTOS -->
                <div class="vu-meters-central">
                    <div class="vu-meter-central">
                        <div class="vu-meter-level-central" id="vuMeterCentral1"></div>
                    </div>
                    <div class="vu-meter-central">
                        <div class="vu-meter-level-central" id="vuMeterCentral2"></div>
                    </div>
                </div>
                
                <div class="effect-group">
                    <button class="effect-button-platter" id="effect2-cut" onclick="toggleEffect(2, 'cut')">CUT</button>
                    <button class="effect-button-platter" id="effect2-flanger" onclick="toggleEffect(2, 'flanger')">FLNG</button>
                </div>
                <div class="vertical-fader-container">
                    <input type="range" id="volume2" min="0" max="1" step="0.01" value="0.7" class="vertical-fader">
                </div>
            </div>

            <div class="crossfader-container">
                <input type="range" id="crossfader" min="0" max="1" step="0.01" value="0.5">
            </div>
            
            <div class="hot-cues-and-reverse">
                <div style="display:flex; gap:8px; align-items:center;">
                    <div>
                        <button class="hot-cue-button button" id="hotCue1" onclick="toggleHotCue(1)">HotCue</button>
                    </div>
                    <div>
                        <button class="button" id="deleteHotCue1" onclick="deleteHotCue(1)">Eliminar</button>
                    </div>
                    <div>
                        <button class="hot-cue-button button" id="hotCue2" onclick="toggleHotCue(2)">HotCue</button>
                    </div>
                    <div>
                        <button class="button" id="deleteHotCue2" onclick="deleteHotCue(2)">Eliminar</button>
                    </div>
                </div>
                <div style="margin-top:8px;">
                    <button class="button reverse-button" id="reverse1" onmousedown="startReverse(1)" onmouseup="stopReverse(1)" onmouseleave="stopReverse(1)">Reverse 1 (hold)</button>
                    <button class="button reverse-button" id="reverse2" onmousedown="startReverse(2)" onmouseup="stopReverse(2)" onmouseleave="stopReverse(2)">Reverse 2 (hold)</button>
                </div>
            </div>
        </div>

        <!-- DECK 2 -->
        <div class="deck" data-deck="2">
            <!-- Controles superiores del deck 2 -->
            <div class="deck-controls deck2">
                <div class="deck-button" id="button2" onclick="playPause(2)">Play</div>
                <div class="deck-button sync-button" id="sync2" onclick="sync(2)">Sync</div>
            </div>
            
            <div class="bpm-display deck2" id="bpmDisplay2">-- BPM</div>
            
            <div class="pitch-control-vertical deck2">
                <input type="range" id="pitch2" min="0.5" max="2" step="0.01" value="1">
            </div>
            
            <div class="platter" id="platter2" onclick="toggleSuperimpose(2)">
                <div class="platter-inner">2</div>
            </div>
            
            <!-- Botón para cargar archivo -->
            <div class="load-file-button" onclick="document.getElementById('fileInput2').click()">CARGAR AUDIO</div>
            <input type="file" id="fileInput2" accept="audio/*" style="display: none;">
            
            <div class="progress-container">
                <input type="range" id="progressBar2" class="progress-bar" min="0" max="1" step="0.001" value="0">
                <div class="time-display">
                    <span id="currentTime2">0:00</span>
                    <span id="duration2">0:00</span>
                </div>
            </div>
            
            <div class="waveform-deck-container deck2">
                <canvas id="waveformCanvas2"></canvas>
                <div class="hot-cue-marker" data-deck="2" style="display: none;"></div>
            </div>
            
            <div class="navigation-buttons">
                <div class="nav-button" onclick="navigateByBeats(2, -4)">-4</div>
                <div class="nav-button" onclick="navigateByBeats(2, 4)">+4</div>
            </div>
            
            <!-- Loop Pads -->
            <div class="loop-pads" id="loopPads2">
                <div class="loop-pad" data-value="0.125" onmousedown="startLoopRoll(2, 0.125)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/8</div>
                <div class="loop-pad" data-value="0.0625" onmousedown="startLoopRoll(2, 0.0625)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/16</div>
                <div class="loop-pad" data-value="0.25" onmousedown="startLoopRoll(2, 0.25)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/4</div>
                <div class="loop-pad" data-value="0.5" onmousedown="startLoopRoll(2, 0.5)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/2</div>
                <div class="loop-pad" data-value="1" onmousedown="startLoopRoll(2, 1)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1</div>
                <div class="loop-pad" data-value="2" onmousedown="startLoopRoll(2, 2)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">2</div>
            </div>
            
            <!-- Knobs circulares CON FILTRO -->
            <div class="knobs-row">
                <div class="knob-container">
                    <div class="knob" id="gainKnob2">
                        <div class="knob-marker" id="gainMarker2"></div>
                    </div>
                    <div class="knob-label">Gain</div>
                </div>
                <div class="knob-container">
                    <div class="knob" id="bassKnob2">
                        <div class="knob-marker" id="bassMarker2"></div>
                    </div>
                    <div class="knob-label">Bass</div>
                </div>
                <div class="knob-container">
                    <div class="knob" id="midKnob2">
                        <div class="knob-marker" id="midMarker2"></div>
                    </div>
                    <div class="knob-label">Mid</div>
                </div>
                <div class="knob-container">
                    <div class="knob" id="trebleKnob2">
                        <div class="knob-marker" id="trebleMarker2"></div>
                    </div>
                    <div class="knob-label">Treble</div>
                </div>
                <!-- FILTRO para deck 2 -->
                <div class="knob-container">
                    <div class="knob" id="filterKnob2">
                        <div class="knob-marker" id="filterMarker2"></div>
                    </div>
                    <div class="knob-label">Filter</div>
                </div>
            </div>
            
            <!-- EQ Kill buttons -->
            <div style="display: flex; justify-content: center; gap: 10px; margin-top: 5px;">
                <button class="button" onclick="toggleEQ('bass', 2)">B Kill</button>
                <button class="button" onclick="toggleEQ('mid', 2)">M Kill</button>
                <button class="button" onclick="toggleEQ('treble', 2)">T Kill</button>
            </div>
            
            <!-- Inputs ocultos para la funcionalidad original -->
            <input type="range" id="bass2" min="-20" max="20" value="0" class="rotary-knob">
            <input type="range" id="mid2" min="-20" max="20" value="0" class="rotary-knob">
            <input type="range" id="treble2" min="-20" max="20" value="0" class="rotary-knob">
            <input type="range" id="gain2" min="0" max="2" step="0.01" value="1" class="rotary-knob">
            <input type="range" id="filter2" min="20" max="22050" step="1" value="22050" class="rotary-knob">
        </div>
    </div>

    <div style="text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px;">
        <button onclick="toggleEqualizerPopup()">Ecualizador de 30 bandas</button>
        <div class="button" id="recordButton" onclick="toggleRecording()" style="width: auto;">Grabar</div>
        <div class="button" id="saveButton" onclick="saveRecording()" style="width: auto; background: #FF5733; display: none;">Guardar</div>
    </div>
</div>

<div id="equalizer-popup">
    <h3>Ecualizador de 30 bandas</h3>
    <div class="eq-container">
        <div class="eq-row" id="row1"></div>
        <div class="eq-row" id="row2"></div>
    </div>
    <button class="close-btn" onclick="toggleEqualizerPopup()">Cerrar</button>
</div>

<div id="settingsPopup">
    <h3>Ajustes de Sonido y MIDI</h3>
    <div class="settings-section">
        <label for="audioOutputSelector">Salida de Sonido:</label>
        <select id="audioOutputSelector"></select>
    </div>
    <div class="settings-section">
        <label for="midiInputSelector">Controlador MIDI:</label>
        <select id="midiInputSelector"></select>
    </div>
    <div class="settings-section">
        <label for="waveformStyleSelector">Visualizador de Onda:</label>
        <select id="waveformStyleSelector">
            <option value="default">Verde y Rojo</option>
            <option value="blue-orange">Azul y Naranja</option>
            <option value="rainbow">Arcoíris</option>
            <option value="mono">Monocromático</option>
            <option value="gradient">Degradado</option>
            <option value="bars">Barras</option>
            <option value="dots">Puntos</option>
            <option value="outline">Contorno</option>
        </select>
    </div>

    <div class="settings-section">
        <label for="recordingSourceSelector">Fuente de Grabación:</label>
        <select id="recordingSourceSelector">
            <option value="master">Salida Master (Línea)</option>
            <option value="mic">Micrófono</option>
        </select>
    </div>
    
    <div class="settings-section">
        <label for="midiMappingSelector">Mapeo MIDI:</label>
        <select id="midiMappingSelector">
            <option value="default">Por Defecto</option>
            <option value="traktor">Traktor</option>
            <option value="serato">Serato</option>
            <option value="rekordbox">Rekordbox</option>
            <option value="virtualdj">VirtualDJ</option>
            <option value="custom">Personalizado</option>
        </select>
    </div>

    <button class="close-btn" onclick="applySettings()">Aplicar</button>
    <button class="close-btn" onclick="toggleSettingsPopup()">Cerrar</button>
</div>

<script>
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let decks = {
        1: {
            audio: null,
            audioBuffer: null,
            source: null,
            gainNode: audioContext.createGain(),
            filterNode: audioContext.createBiquadFilter(),
            analyser: null,
            isPlaying: false,
            startTime: 0,
            pauseTime: 0,
            isReversed: false,
            reversedBuffer: null,
            eq: { bass: audioContext.createBiquadFilter(), mid: audioContext.createBiquadFilter(), treble: audioContext.createBiquadFilter() },
            isLoaded: false,
            animationFrame: null,
            eqState: { bass: true, mid: true, treble: true },
            eqValue: { bass: 0, mid: 0, treble: 0 },
            bpm: 0,
            loopRollSource: null,
            vinylBrakeInterval: null,
            hotCue: null,
            effects: { cut: false, flanger: false },
            vinylStartSound: null,
            vinylStopSound: null,
            // Efectos
            cutEffect: null,
            flangerEffect: null,
            // Para el visualizador superior
            waveformData: null,
            currentBeat: 0
        },
        2: {
            audio: null,
            audioBuffer: null,
            source: null,
            gainNode: audioContext.createGain(),
            filterNode: audioContext.createBiquadFilter(),
            analyser: null,
            isPlaying: false,
            startTime: 0,
            pauseTime: 0,
            isReversed: false,
            reversedBuffer: null,
            eq: { bass: audioContext.createBiquadFilter(), mid: audioContext.createBiquadFilter(), treble: audioContext.createBiquadFilter() },
            isLoaded: false,
            animationFrame: null,
            eqState: { bass: true, mid: true, treble: true },
            eqValue: { bass: 0, mid: 0, treble: 0 },
            bpm: 0,
            loopRollSource: null,
            vinylBrakeInterval: null,
            hotCue: null,
            effects: { cut: false, flanger: false },
            vinylStartSound: null,
            vinylStopSound: null,
            // Efectos
            cutEffect: null,
            flangerEffect: null,
            // Para el visualizador superior
            waveformData: null,
            currentBeat: 0
        }
    };
    let mediaRecorder;
    let recordedChunks = [];
    let analyserMaster = audioContext.createAnalyser(); analyserMaster.fftSize = 2048;
    let showDeck = {1:true,2:true}; // control which deck wave is superimposed
    
    let recordingStream;
    let isRecording = false;
    let activeRecordingSource = 'master';
    let currentWaveformStyle = 'default';
    let lastWavBlob = null;
    let lastVUUpdate = 0;

    // 30-band equalizer
    const frequencies = [
        32, 64, 125, 250, 500, 1000, 2000, 4000, 8000, 16000,
        31, 62, 125, 250, 500, 1000, 2000, 4000, 8000, 16000,
        20, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240
    ];
    const eqNodes = [];
    let globalEqFilters = [];
    const row1 = document.getElementById('row1');
    const row2 = document.getElementById('row2');

    const superCanvas = document.getElementById('superimposedWaveformCanvas');
    const superCtx = superCanvas.getContext('2d');

    // Función para actualizar VU Meters CENTRALES
    function updateVUMeters() {
        const now = Date.now();
        if (now - lastVUUpdate < 50) return; // Actualizar cada 50ms
        
        lastVUUpdate = now;
        
        for (let deckNum of [1, 2]) {
            if (decks[deckNum].isLoaded && decks[deckNum].analyser) {
                const analyser = decks[deckNum].analyser;
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(dataArray);
                
                // Calcular volumen promedio
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    sum += dataArray[i];
                }
                const average = sum / dataArray.length;
                const normalized = average / 256; // 0-1
                
                // Actualizar VU Meter central SOLO
                const vuMeterCentral = document.getElementById(`vuMeterCentral${deckNum}`);
                if (vuMeterCentral) {
                    vuMeterCentral.style.height = `${(1 - normalized) * 100}%`;
                    
                    // Cambiar color según nivel
                    if (normalized > 0.9) {
                        vuMeterCentral.style.background = 'rgba(255, 255, 255, 0.9)';
                    } else if (normalized > 0.75) {
                        vuMeterCentral.style.background = 'rgba(255, 0, 0, 0.8)';
                    } else if (normalized > 0.5) {
                        vuMeterCentral.style.background = 'rgba(255, 165, 0, 0.7)';
                    } else {
                        vuMeterCentral.style.background = 'rgba(0, 255, 0, 0.6)';
                    }
                }
            }
        }
        
        requestAnimationFrame(updateVUMeters);
    }

    // Función para inicializar knobs circulares (INCLUYENDO FILTRO)
    function initKnobs() {
        for (let deckNum of [1, 2]) {
            // Configurar knobs para gain, bass, mid, treble Y FILTRO
            ['gain', 'bass', 'mid', 'treble', 'filter'].forEach((type) => {
                const knob = document.getElementById(`${type}Knob${deckNum}`);
                const marker = document.getElementById(`${type}Marker${deckNum}`);
                const input = document.getElementById(`${type}${deckNum}`);
                
                if (knob && marker && input) {
                    knob.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? -0.05 : 0.05;
                        let newValue = parseFloat(input.value) + delta;
                        
                        // Limitar valores según el tipo
                        if (type === 'gain') {
                            newValue = Math.max(0, Math.min(2, newValue));
                        } else if (type === 'filter') {
                            newValue = Math.max(20, Math.min(22050, newValue));
                        } else {
                            newValue = Math.max(-20, Math.min(20, newValue));
                        }
                        
                        input.value = newValue;
                        input.dispatchEvent(new Event('input'));
                        updateKnobMarker(marker, input, type);
                    });
                    
                    // Actualizar marcador inicial
                    updateKnobMarker(marker, input, type);
                    
                    // Actualizar cuando cambia el input
                    input.addEventListener('input', () => {
                        updateKnobMarker(marker, input, type);
                    });
                    
                    // Permitir arrastrar el knob
                    let isDragging = false;
                    let startY = 0;
                    let startValue = 0;
                    
                    knob.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        startY = e.clientY;
                        startValue = parseFloat(input.value);
                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    });
                    
                    function onMouseMove(e) {
                        if (!isDragging) return;
                        
                        const deltaY = startY - e.clientY;
                        let newValue;
                        
                        if (type === 'gain') {
                            newValue = startValue + (deltaY * 0.01);
                            newValue = Math.max(0, Math.min(2, newValue));
                        } else if (type === 'filter') {
                            newValue = startValue + (deltaY * 50);
                            newValue = Math.max(20, Math.min(22050, newValue));
                        } else {
                            newValue = startValue + (deltaY * 0.5);
                            newValue = Math.max(-20, Math.min(20, newValue));
                        }
                        
                        input.value = newValue;
                        input.dispatchEvent(new Event('input'));
                        updateKnobMarker(marker, input, type);
                    }
                    
                    function onMouseUp() {
                        isDragging = false;
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    }
                }
            });
        }
    }

    // Función para actualizar posición del marcador del knob
    function updateKnobMarker(marker, input, type) {
        const value = parseFloat(input.value);
        let angle;
        
        if (type === 'gain') {
            // Gain: 0-2 → 225°-315°
            angle = 225 + (value / 2) * 90;
        } else if (type === 'filter') {
            // Filter: 20-22050 → 225°-315° (logarítmico)
            const normalized = Math.log(value/20) / Math.log(22050/20);
            angle = 225 + normalized * 90;
        } else {
            // EQ: -20 a 20 → 225°-315°
            angle = 225 + ((value + 20) / 40) * 90;
        }
        
        marker.style.transform = `translateX(-50%) rotate(${angle}deg)`;
    }

    // Cargar sonidos de inicio y parada de vinilo
    async function loadVinylSounds() {
        try {
            // Crear sonidos sintéticos para inicio y parada de vinilo
            const createVinylSound = (fadeIn, duration) => {
                const sampleRate = audioContext.sampleRate;
                const length = sampleRate * duration;
                const buffer = audioContext.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < length; i++) {
                    // Ruido blanco
                    let value = Math.random() * 2 - 1;
                    
                    // Aplicar filtro de paso bajo para simular ruido de vinilo
                    if (i > 0) {
                        value = 0.95 * data[i-1] + 0.05 * value;
                    }
                    
                    // Aplicar envolvente
                    let envelope;
                    if (fadeIn) {
                        envelope = Math.min(1, i / (sampleRate * 0.1)); // Fade in rápido
                    } else {
                        envelope = Math.max(0, 1 - (i / (sampleRate * 0.3))); // Fade out más lento
                    }
                    
                    data[i] = value * envelope * 0.3;
                }
                
                return buffer;
            };
            
            decks[1].vinylStartSound = createVinylSound(true, 0.2);
            decks[1].vinylStopSound = createVinylSound(false, 0.5);
            decks[2].vinylStartSound = createVinylSound(true, 0.2);
            decks[2].vinylStopSound = createVinylSound(false, 0.5);
        } catch (error) {
            console.error("Error creating vinyl sounds:", error);
        }
    }

    // Reproducir sonido de vinilo
    function playVinylSound(deckNum, isStart) {
        if (!decks[deckNum]) return;
        
        const buffer = isStart ? decks[deckNum].vinylStartSound : decks[deckNum].vinylStopSound;
        if (!buffer) return;
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);
        source.start();
    }

    // Inicializar ecualizador de 30 bandas
    function init30BandEQ() {
        // Clear existing nodes
        while (globalEqFilters.length > 0) {
            const filter = globalEqFilters.pop();
            filter.disconnect();
        }
        
        // Create new filters
        for (let i = 0; i < frequencies.length; i++) {
            const filter = audioContext.createBiquadFilter();
            filter.type = 'peaking';
            filter.frequency.value = frequencies[i];
            filter.Q.value = 1;
            filter.gain.value = 0;
            
            // Connect in series
            if (i === 0) {
                analyserMaster.connect(filter);
            } else {
                globalEqFilters[i-1].connect(filter);
            }
            
            globalEqFilters.push(filter);
            
            // Create UI controls
            const band = document.createElement('div');
            band.className = 'band';
            
            const input = document.createElement('input');
            input.type = 'range';
            input.min = '-20';
            input.max = '20';
            input.value = '0';
            input.dataset.index = i;
            input.addEventListener('input', (e) => {
                const index = parseInt(e.target.dataset.index);
                globalEqFilters[index].gain.value = parseFloat(e.target.value);
            });
            
            const label = document.createElement('label');
            label.textContent = `${frequencies[i]}Hz`;
            
            band.appendChild(input);
            band.appendChild(label);
            
            if (i < 15) {
                row1.appendChild(band);
            } else {
                row2.appendChild(band);
            }
        }
        
        // Connect the last filter to destination
        globalEqFilters[globalEqFilters.length - 1].connect(audioContext.destination);
    }

    // Initialize the application
    function init() {
        // Set up audio routing
        analyserMaster.connect(audioContext.destination);
        
        // Initialize 30-band EQ
        init30BandEQ();
        
        // Load vinyl sounds
        loadVinylSounds();
        
        // Set up file inputs
        document.getElementById('fileInput1').addEventListener('change', (e) => handleFileSelect(e, 1));
        document.getElementById('fileInput2').addEventListener('change', (e) => handleFileSelect(e, 2));
        
        // Set up controls
        setupControls();
        
        // Set up canvas dimensions
        setupCanvasDimensions();
        
        // Set up MIDI
        setupMIDI();
        
        // Inicializar knobs (INCLUYENDO FILTRO)
        initKnobs();
        
        // Iniciar VU Meters (SOLO CENTRALES)
        requestAnimationFrame(updateVUMeters);
        
        // Start animation
        animate();
        
        // Set up recording
        setupRecording();
    }

    // Set up controls
    function setupControls() {
        // Volume controls
        document.getElementById('volume1').addEventListener('input', (e) => {
            decks[1].gainNode.gain.value = parseFloat(e.target.value);
        });
        document.getElementById('volume2').addEventListener('input', (e) => {
            decks[2].gainNode.gain.value = parseFloat(e.target.value);
        });
        
        // EQ controls
        ['bass', 'mid', 'treble'].forEach((band) => {
            for (let i = 1; i <= 2; i++) {
                document.getElementById(`${band}${i}`).addEventListener('input', (e) => {
                    decks[i].eq[band].gain.value = parseFloat(e.target.value);
                    decks[i].eqValue[band] = parseFloat(e.target.value);
                });
            }
        });
        
        // Gain controls
        document.getElementById('gain1').addEventListener('input', (e) => {
            decks[1].gainNode.gain.value = parseFloat(e.target.value);
        });
        document.getElementById('gain2').addEventListener('input', (e) => {
            decks[2].gainNode.gain.value = parseFloat(e.target.value);
        });
        
        // Filter controls
        document.getElementById('filter1').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            decks[1].filterNode.frequency.value = value;
            // Actualizar visualmente si existe el knob
            const marker = document.getElementById('filterMarker1');
            if (marker) {
                updateKnobMarker(marker, e.target, 'filter');
            }
        });
        document.getElementById('filter2').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            decks[2].filterNode.frequency.value = value;
            // Actualizar visualmente si existe el knob
            const marker = document.getElementById('filterMarker2');
            if (marker) {
                updateKnobMarker(marker, e.target, 'filter');
            }
        });
        
        // Pitch controls
        document.getElementById('pitch1').addEventListener('input', (e) => {
            if (decks[1].source) {
                decks[1].source.playbackRate.value = parseFloat(e.target.value);
            }
        });
        document.getElementById('pitch2').addEventListener('input', (e) => {
            if (decks[2].source) {
                decks[2].source.playbackRate.value = parseFloat(e.target.value);
            }
        });
        
        // Crossfader
        document.getElementById('crossfader').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            // Adjust volumes based on crossfader position
            decks[1].gainNode.gain.value = value < 0.5 ? 1 : 1 - ((value - 0.5) * 2);
            decks[2].gainNode.gain.value = value > 0.5 ? 1 : value * 2;
        });
        
        // Progress bars
        document.getElementById('progressBar1').addEventListener('input', (e) => {
            if (decks[1].isLoaded) {
                seekTrack(1, parseFloat(e.target.value));
            }
        });
        document.getElementById('progressBar2').addEventListener('input', (e) => {
            if (decks[2].isLoaded) {
                seekTrack(2, parseFloat(e.target.value));
            }
        });
    }

    // Set up canvas dimensions
    function setupCanvasDimensions() {
        const canvases = [
            document.getElementById('superimposedWaveformCanvas'),
            document.getElementById('waveformCanvas1'),
            document.getElementById('waveformCanvas2')
        ];
        
        canvases.forEach(canvas => {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        });
    }

    // Handle file selection
    async function handleFileSelect(event, deckNum) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Store audio buffer
            decks[deckNum].audioBuffer = audioBuffer;
            decks[deckNum].isLoaded = true;
            
            // Preprocess waveform data for the top visualizer
            preprocessWaveformData(deckNum, audioBuffer);
            
            // Create reversed buffer
            createReversedBuffer(deckNum, audioBuffer);
            
            // Create analyser
            decks[deckNum].analyser = audioContext.createAnalyser();
            decks[deckNum].analyser.fftSize = 2048;
            
            // Set up audio routing
            setupAudioRouting(deckNum);
            
            // Draw waveform
            drawFullWaveform(deckNum);
            
            // Update duration display
            const duration = formatTime(audioBuffer.duration);
            document.getElementById(`duration${deckNum}`).textContent = duration;
            
            // Detect BPM
            detectBPM(deckNum, audioBuffer);
            
            // Actualizar botón de play
            document.getElementById(`button${deckNum}`).textContent = 'Play';
            
        } catch (error) {
            console.error('Error loading audio file:', error);
            alert('Error al cargar el archivo de audio. Asegúrate de que es un archivo de audio válido.');
        }
    }

    // Preprocess waveform data for the top visualizer
    function preprocessWaveformData(deckNum, audioBuffer) {
        const channelData = audioBuffer.getChannelData(0);
        const samplesPerPixel = Math.floor(channelData.length / superCanvas.width);
        decks[deckNum].waveformData = [];
        
        for (let i = 0; i < superCanvas.width; i++) {
            let min = 0;
            let max = 0;
            
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = i * samplesPerPixel + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            
            decks[deckNum].waveformData.push({ min, max });
        }
    }

    // Create reversed audio buffer
    function createReversedBuffer(deckNum, audioBuffer) {
        const reversedBuffer = audioContext.createBuffer(
            audioBuffer.numberOfChannels,
            audioBuffer.length,
            audioBuffer.sampleRate
        );
        
        for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
            const originalData = audioBuffer.getChannelData(channel);
            const reversedData = reversedBuffer.getChannelData(channel);
            
            for (let i = 0; i < audioBuffer.length; i++) {
                reversedData[i] = originalData[audioBuffer.length - 1 - i];
            }
        }
        
        decks[deckNum].reversedBuffer = reversedBuffer;
    }

    // Set up audio routing
    function setupAudioRouting(deckNum) {
        // Set up EQ
        decks[deckNum].eq.bass.type = 'lowshelf';
        decks[deckNum].eq.bass.frequency.value = 250;
        
        decks[deckNum].eq.mid.type = 'peaking';
        decks[deckNum].eq.mid.frequency.value = 1000;
        decks[deckNum].eq.mid.Q.value = 1;
        
        decks[deckNum].eq.treble.type = 'highshelf';
        decks[deckNum].eq.treble.frequency.value = 4000;
        
        // Set up filter
        decks[deckNum].filterNode.type = 'lowpass';
        decks[deckNum].filterNode.frequency.value = 22050;
        decks[deckNum].filterNode.Q.value = 1;
        
        // Connect nodes
        decks[deckNum].eq.bass.connect(decks[deckNum].eq.mid);
        decks[deckNum].eq.mid.connect(decks[deckNum].eq.treble);
        decks[deckNum].eq.treble.connect(decks[deckNum].filterNode);
        decks[deckNum].filterNode.connect(decks[deckNum].gainNode);
        decks[deckNum].gainNode.connect(decks[deckNum].analyser);
        decks[deckNum].analyser.connect(analyserMaster);
    }

    // Draw full waveform
    function drawFullWaveform(deckNum) {
        const canvas = document.getElementById(`waveformCanvas${deckNum}`);
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        ctx.clearRect(0, 0, width, height);
        
        if (!decks[deckNum].audioBuffer) return;
        
        const audioBuffer = decks[deckNum].audioBuffer;
        const channelData = audioBuffer.getChannelData(0);
        const step = Math.ceil(channelData.length / width);
        
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        
        // Choose color based on deck
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        for (let i = 0; i < width; i++) {
            let min = 0;
            let max = 0;
            
            for (let j = 0; j < step; j++) {
                const index = i * step + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            
            ctx.lineTo(i, height / 2 - min * height / 2);
            ctx.lineTo(i, height / 2 - max * height / 2);
        }
        
        ctx.stroke();
    }

    // Play/Pause track
    function playPause(deckNum) {
        if (!decks[deckNum].isLoaded) {
            alert('Primero carga un archivo de audio en el deck ' + deckNum);
            document.getElementById(`fileInput${deckNum}`).click();
            return;
        }
        
        if (decks[deckNum].isPlaying) {
            pauseTrack(deckNum);
        } else {
            playTrack(deckNum);
        }
    }

    // Play track
    function playTrack(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        
        // Play vinyl start sound
        playVinylSound(deckNum, true);
        
        const source = audioContext.createBufferSource();
        
        if (decks[deckNum].isReversed) {
            source.buffer = decks[deckNum].reversedBuffer;
        } else {
            source.buffer = decks[deckNum].audioBuffer;
        }
        
        // Set playback rate
        source.playbackRate.value = parseFloat(document.getElementById(`pitch${deckNum}`).value);
        
        // Connect source to audio chain
        source.connect(decks[deckNum].eq.bass);
        
        // Store source
        decks[deckNum].source = source;
        
        // Calculate start time
        let startTime;
        if (decks[deckNum].pauseTime > 0) {
            startTime = audioContext.currentTime - decks[deckNum].pauseTime;
        } else {
            startTime = audioContext.currentTime;
        }
        
        // Start playback
        source.start(0, decks[deckNum].pauseTime);
        
        // Update state
        decks[deckNum].isPlaying = true;
        decks[deckNum].startTime = startTime;
        
        // Update button text
        document.getElementById(`button${deckNum}`).textContent = 'Pause';
        
        // Start platter animation
        document.getElementById(`platter${deckNum}`).classList.add('playing');
        
        // Start animation for progress bar
        cancelAnimationFrame(decks[deckNum].animationFrame);
        animateProgress(deckNum);
    }

    // Pause track
    function pauseTrack(deckNum) {
        if (!decks[deckNum].isPlaying || !decks[deckNum].source) return;
        
        // Play vinyl stop sound
        playVinylSound(deckNum, false);
        
        // Stop source
        decks[deckNum].source.stop();
        decks[deckNum].source.disconnect();
        
        // Calculate pause time
        decks[deckNum].pauseTime = audioContext.currentTime - decks[deckNum].startTime;
        
        // Update state
        decks[deckNum].isPlaying = false;
        
        // Update button text
        document.getElementById(`button${deckNum}`).textContent = 'Play';
        
        // Stop platter animation
        document.getElementById(`platter${deckNum}`).classList.remove('playing');
        
        // Stop animation
        cancelAnimationFrame(decks[deckNum].animationFrame);
    }

    // Seek track
    function seekTrack(deckNum, progress) {
        const wasPlaying = decks[deckNum].isPlaying;
        
        if (wasPlaying) {
            pauseTrack(deckNum);
        }
        
        decks[deckNum].pauseTime = progress * decks[deckNum].audioBuffer.duration;
        
        // Update beat position
        updateBeatPosition(deckNum);
        
        if (wasPlaying) {
            playTrack(deckNum);
        } else {
            // Update progress bar
            document.getElementById(`progressBar${deckNum}`).value = progress;
            document.getElementById(`currentTime${deckNum}`).textContent = formatTime(decks[deckNum].pauseTime);
        }
    }

    // Navegación por beats (4 tiempos)
    function navigateByBeats(deckNum, beats) {
        if (!decks[deckNum].isLoaded || decks[deckNum].bpm === 0) return;
        
        const wasPlaying = decks[deckNum].isPlaying;
        
        if (wasPlaying) {
            pauseTrack(deckNum);
        }
        
        // Calcular duración de un beat en segundos
        const secondsPerBeat = 60 / decks[deckNum].bpm;
        
        // Calcular nueva posición
        let newPosition = decks[deckNum].pauseTime + (beats * secondsPerBeat);
        
        // Asegurarse de que está dentro de los límites
        if (newPosition < 0) newPosition = 0;
        if (newPosition > decks[deckNum].audioBuffer.duration) newPosition = decks[deckNum].audioBuffer.duration;
        
        decks[deckNum].pauseTime = newPosition;
        
        // Update beat position
        updateBeatPosition(deckNum);
        
        if (wasPlaying) {
            playTrack(deckNum);
        } else {
            // Actualizar barra de progreso
            const progress = newPosition / decks[deckNum].audioBuffer.duration;
            document.getElementById(`progressBar${deckNum}`).value = progress;
            document.getElementById(`currentTime${deckNum}`).textContent = formatTime(newPosition);
        }
    }

    // Update beat position for visualization
    function updateBeatPosition(deckNum) {
        if (!decks[deckNum].isLoaded || decks[deckNum].bpm === 0) return;
        
        // Calcular posición actual en beats
        const secondsPerBeat = 60 / decks[deckNum].bpm;
        decks[deckNum].currentBeat = Math.floor(decks[deckNum].pauseTime / secondsPerBeat);
    }

    // Animate progress bar
    function animateProgress(deckNum) {
        if (!decks[deckNum].isPlaying) return;
        
        const currentTime = audioContext.currentTime - decks[deckNum].startTime;
        const duration = decks[deckNum].audioBuffer.duration;
        const progress = currentTime / duration;
        
        // Update progress bar
        document.getElementById(`progressBar${deckNum}`).value = progress;
        document.getElementById(`currentTime${deckNum}`).textContent = formatTime(currentTime);
        
        // Update beat position
        updateBeatPosition(deckNum);
        
        // Continue animation
        decks[deckNum].animationFrame = requestAnimationFrame(() => animateProgress(deckNum));
    }

    // Format time
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
    }

    // Detect BPM
    function detectBPM(deckNum, audioBuffer) {
        // Simple BPM detection (this is a placeholder)
        // In a real application, you would use a more sophisticated algorithm
        const estimatedBPM = Math.floor(80 + Math.random() * 60);
        decks[deckNum].bpm = estimatedBPM;
        document.getElementById(`bpmDisplay${deckNum}`).textContent = `${estimatedBPM} BPM`;
    }

    // Sync BPM
    function sync(deckNum) {
        const otherDeckNum = deckNum === 1 ? 2 : 1;
        
        if (!decks[otherDeckNum].isLoaded) {
            alert('Primero carga un archivo en el otro deck para sincronizar');
            return;
        }
        
        // Set pitch to match other deck's BPM
        const targetBPM = decks[otherDeckNum].bpm;
        const currentBPM = decks[deckNum].bpm;
        
        if (currentBPM > 0) {
            const ratio = targetBPM / currentBPM;
            document.getElementById(`pitch${deckNum}`).value = ratio;
            
            if (decks[deckNum].source) {
                decks[deckNum].source.playbackRate.value = ratio;
            }
            
            // Actualizar visualmente el knob de pitch si existe
            const pitchInput = document.getElementById(`pitch${deckNum}`);
            if (pitchInput) {
                pitchInput.dispatchEvent(new Event('input'));
            }
        }
    }

    // Toggle EQ band
    function toggleEQ(band, deckNum) {
        const isEnabled = decks[deckNum].eqState[band];
        
        if (isEnabled) {
            // Kill the band por completo
            decks[deckNum].eq[band].gain.value = -40;
            decks[deckNum].eqState[band] = false;
        } else {
            // Restaurar la banda al valor previo
            decks[deckNum].eq[band].gain.value = decks[deckNum].eqValue[band];
            decks[deckNum].eqState[band] = true;
        }
    }

    // Start reverse
    function startReverse(deckNum) {
        if (!decks[deckNum].isLoaded) return;

        const currentTime = decks[deckNum].isPlaying ? (audioContext.currentTime - decks[deckNum].startTime) : decks[deckNum].pauseTime;
        
        if (decks[deckNum].isPlaying) {
            pauseTrack(deckNum);
        }

        decks[deckNum].isReversed = true;
        decks[deckNum].pauseTime = decks[deckNum].audioBuffer.duration - currentTime;

        playTrack(deckNum);
    }

    // Stop reverse
    function stopReverse(deckNum) {
        if (!decks[deckNum].isLoaded || !decks[deckNum].isReversed) return;

        const currentTime = decks[deckNum].audioBuffer.duration - decks[deckNum].pauseTime;

        if (decks[deckNum].isPlaying) {
            pauseTrack(deckNum);
        }

        decks[deckNum].isReversed = false;
        decks[deckNum].pauseTime = currentTime;

        playTrack(deckNum);
    }

    // Toggle hot cue
    function toggleHotCue(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        
        if (decks[deckNum].hotCue === null) {
            // Set hot cue
            const currentTime = decks[deckNum].isPlaying ? 
                (audioContext.currentTime - decks[deckNum].startTime) : 
                decks[deckNum].pauseTime;
            
            decks[deckNum].hotCue = currentTime;
            
            // Create visual marker
            createHotCueMarker(deckNum, currentTime);
            
            document.getElementById(`hotCue${deckNum}`).textContent = 'GoTo';
        } else {
            // Go to hot cue
            seekTrack(deckNum, decks[deckNum].hotCue / decks[deckNum].audioBuffer.duration);
        }
    }

    // Delete hot cue
    function deleteHotCue(deckNum) {
        decks[deckNum].hotCue = null;
        document.getElementById(`hotCue${deckNum}`).textContent = 'HotCue';
        
        // Remove visual marker
        const markers = document.querySelectorAll(`.hot-cue-marker[data-deck="${deckNum}"]`);
        markers.forEach(marker => marker.remove());
    }

    // Create hot cue marker
    function createHotCueMarker(deckNum, time) {
        const progress = time / decks[deckNum].audioBuffer.duration;
        const waveformContainer = document.querySelector(`.waveform-deck-container.deck${deckNum}`);
        
        // Remove existing marker
        const existingMarker = document.querySelector(`.hot-cue-marker[data-deck="${deckNum}"]`);
        if (existingMarker) existingMarker.remove();
        
        // Create new marker
        const marker = document.createElement('div');
        marker.className = 'hot-cue-marker';
        marker.dataset.deck = deckNum;
        marker.style.left = `${progress * 100}%`;
        
        waveformContainer.appendChild(marker);
    }

    // Toggle effect
    function toggleEffect(deckNum, effect) {
        const button = document.getElementById(`effect${deckNum}-${effect}`);
        
        if (decks[deckNum].effects[effect]) {
            // Disable effect
            decks[deckNum].effects[effect] = false;
            button.classList.remove('active');
            
            // Disconnect effect nodes
            if (effect === 'cut' && decks[deckNum].cutEffect) {
                decks[deckNum].cutEffect.disconnect();
                decks[deckNum].cutEffect = null;
            } else if (effect === 'flanger' && decks[deckNum].flangerEffect) {
                decks[deckNum].flangerEffect.disconnect();
                decks[deckNum].flangerEffect = null;
            }
        } else {
            // Enable effect
            decks[deckNum].effects[effect] = true;
            button.classList.add('active');
            
            // Create and connect effect nodes
            if (effect === 'cut') {
                // Create a simple cut effect (mute/unmute rapidly)
                const oscillator = audioContext.createOscillator();
                oscillator.frequency.value = 10; // 10Hz for a choppy effect
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0;
                
                oscillator.connect(gainNode.gain);
                oscillator.start();
                
                gainNode.connect(decks[deckNum].gainNode);
                decks[deckNum].cutEffect = gainNode;
            } else if (effect === 'flanger') {
                // Create a simple flanger effect
                const delay = audioContext.createDelay();
                delay.delayTime.value = 0.005;
                
                const oscillator = audioContext.createOscillator();
                oscillator.frequency.value = 0.5;
                
                const gain = audioContext.createGain();
                gain.gain.value = 0.002;
                
                oscillator.connect(gain);
                gain.connect(delay.delayTime);
                
                delay.connect(decks[deckNum].gainNode);
                oscillator.start();
                
                decks[deckNum].flangerEffect = delay;
            }
        }
    }

    // Start loop roll
    function startLoopRoll(deckNum, duration) {
        if (!decks[deckNum].isLoaded || !decks[deckNum].isPlaying) return;

        // Pausar pista principal
        pauseTrack(deckNum);

        const currentTime = decks[deckNum].pauseTime;
        const startTime = currentTime;
        const endTime = startTime + duration;

        // Crear nuevo source en loop
        const source = audioContext.createBufferSource();
        source.buffer = decks[deckNum].audioBuffer;
        source.loop = true;
        source.loopStart = startTime;
        source.loopEnd = endTime;

        // Conectar source
        source.connect(decks[deckNum].eq.bass);

        // Reproducir fragmento
        source.start(0, startTime);
        decks[deckNum].loopRollSource = { source, startTime };
    }

    // Stop loop roll
    function stopLoopRoll(deckNum) {
        if (decks[deckNum].loopRollSource) {
            const { source, startTime } = decks[deckNum].loopRollSource;
            const now = audioContext.currentTime;
            const loopDuration = source.loopEnd - source.loopStart;

            source.stop();
            source.disconnect();
            decks[deckNum].loopRollSource = null;

            // Calcular nuevo punto de tiempo real
            decks[deckNum].pauseTime = startTime + ((now - decks[deckNum].startTime) % loopDuration);
            playTrack(deckNum);
        }
    }

    // Toggle superimpose
    function toggleSuperimpose(deckNum) {
        showDeck[deckNum] = !showDeck[deckNum];
    }

    // Animate all canvas elements
    function animate() {
        drawSuperimposedWaveform();
        requestAnimationFrame(animate);
    }

    // draw superimposed waveform for both decks
    function drawSuperimposedWaveform() {
        const width = superCanvas.width;
        const height = superCanvas.height;
        
        superCtx.clearRect(0, 0, width, height);
        
        // draw deck 1 waveform if shown and loaded
        if (showDeck[1] && decks[1].isLoaded && decks[1].waveformData) {
            drawDeckWaveformSegment(1, width, height);
        }
        
        // draw deck 2 waveform if shown and loaded
        if (showDeck[2] && decks[2].isLoaded && decks[2].waveformData) {
            drawDeckWaveformSegment(2, width, height);
        }
    }

    // draw a segment of the waveform for the top visualizer
    function drawDeckWaveformSegment(deckNum, width, height) {
        if (!decks[deckNum].waveformData || !decks[deckNum].isLoaded) return;
        
        const audioBuffer = decks[deckNum].audioBuffer;
        if (!audioBuffer) return;
        
        const currentPositionSeconds = decks[deckNum].isPlaying ? 
            (audioContext.currentTime - decks[deckNum].startTime) : 
            decks[deckNum].pauseTime;
        
        const durationSeconds = audioBuffer.duration;
        const totalSamples = audioBuffer.length;
        const sampleRate = audioBuffer.sampleRate;
        
        // calculate the number of samples to display
        // 20 seconds of audio, adjust for playback rate
        const viewDuration = 20; 
        const samplesPerView = viewDuration * sampleRate;
        
        // calculate the current sample index and the start/end samples for the view
        const currentSampleIndex = Math.floor(currentPositionSeconds * sampleRate);
        const startSample = Math.max(0, currentSampleIndex - samplesPerView / 2);
        const endSample = Math.min(totalSamples, currentSampleIndex + samplesPerView / 2);
        
        const channelData = audioBuffer.getChannelData(0);
        
        // determine the number of samples per pixel for this zoomed-in view
        const samplesPerPixel = (endSample - startSample) / width;
        
        let color;
        switch(currentWaveformStyle) {
            case 'blue-orange':
                color = deckNum === 1 ? '#0088FF' : '#FF8800';
                break;
            case 'rainbow':
                const hue = (Date.now() / 20 + deckNum * 60) % 360;
                color = `hsl(${hue}, 100%, 60%)`;
                break;
            case 'mono':
                color = deckNum === 1 ? '#CCCCCC' : '#888888';
                break;
            case 'gradient':
                const gradient = superCtx.createLinearGradient(0, 0, width, 0);
                gradient.addColorStop(0, deckNum === 1 ? '#00FF00' : '#FF0000');
                gradient.addColorStop(1, deckNum === 1 ? '#0000FF' : '#FF00FF');
                color = gradient;
                break;
            case 'bars':
                drawBarsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData);
                return;
            case 'dots':
                drawDotsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData);
                return;
            case 'outline':
                drawOutlineWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData);
                return;
            default: // 'default'
                color = deckNum === 1 ? '#00FF00' : '#FF0000';
        }

        superCtx.strokeStyle = color;
        superCtx.lineWidth = 2;
        
        superCtx.beginPath();
        for (let i = 0; i < width; i++) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= totalSamples) break;
            
            let min = 0;
            let max = 0;
            
            // get min and max for the group of samples for this pixel
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < totalSamples) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            
            // draw the line for the pixel
            if (i === 0) {
                superCtx.moveTo(i, height / 2 - min * height / 2);
            } else {
                superCtx.lineTo(i, height / 2 - min * height / 2);
            }
            superCtx.lineTo(i, height / 2 - max * height / 2);
        }
        superCtx.stroke();
    }

    // draw bars style waveform for superimposed view
    function drawBarsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData) {
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        const samplesPerPixel = (endSample - startSample) / width;
        
        for (let i = 0; i < width; i += 4) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;

            let min = 0;
            let max = 0;

            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            const barHeight = (max - min) * height / 2;
            
            superCtx.fillStyle = color;
            superCtx.fillRect(i, height / 2 - barHeight / 2, 3, barHeight);
        }
    }

    // draw dots style waveform for superimposed view
    function drawDotsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData) {
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        const samplesPerPixel = (endSample - startSample) / width;
        
        superCtx.fillStyle = color;
        
        for (let i = 0; i < width; i += 3) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;

            let min = 0;
            let max = 0;

            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            
            superCtx.beginPath();
            superCtx.arc(i, height / 2 - min * height / 2, 1.5, 0, Math.PI * 2);
            superCtx.fill();
            
            superCtx.beginPath();
            superCtx.arc(i, height / 2 - max * height / 2, 1.5, 0, Math.PI * 2);
            superCtx.fill();
        }
    }

    // draw outline style waveform for superimposed view
    function drawOutlineWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData) {
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        const samplesPerPixel = (endSample - startSample) / width;
        
        superCtx.strokeStyle = color;
        superCtx.lineWidth = 1;
        
        // draw upper outline
        superCtx.beginPath();
        for (let i = 0; i < width; i++) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;

            let max = 0;
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value > max) max = value;
                }
            }
            
            if (i === 0) {
                superCtx.moveTo(i, height / 2 - max * height / 2);
            } else {
                superCtx.lineTo(i, height / 2 - max * height / 2);
            }
        }
        superCtx.stroke();
        
        // draw lower outline
        superCtx.beginPath();
        for (let i = 0; i < width; i++) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;

            let min = 0;
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                }
            }
            
            if (i === 0) {
                superCtx.moveTo(i, height / 2 - min * height / 2);
            } else {
                superCtx.lineTo(i, height / 2 - min * height / 2);
            }
        }
        superCtx.stroke();
    }

    // Set up MIDI
    function setupMIDI() {
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(
                (midiAccess) => {
                    console.log('MIDI access granted', midiAccess);
                    
                    // List available MIDI inputs
                    const inputs = midiAccess.inputs.values();
                    const inputSelector = document.getElementById('midiInputSelector');
                    
                    for (let input = inputs.next(); input && !input.done; input = inputs.next()) {
                        const option = document.createElement('option');
                        option.value = input.value.id;
                        option.textContent = input.value.name;
                        inputSelector.appendChild(option);
                        
                        // Add event listener
                        input.value.onmidimessage = handleMIDIMessage;
                    }
                },
                (error) => {
                    console.error('MIDI access denied', error);
                }
            );
        }
    }

    // Handle MIDI message
    function handleMIDIMessage(message) {
        // This is a placeholder for MIDI mapping
        // In a real application, you would map MIDI controls to deck functions
        console.log('MIDI message received', message.data);
    }

    // Toggle equalizer popup
    function toggleEqualizerPopup() {
        const popup = document.getElementById('equalizer-popup');
        popup.style.display = popup.style.display === 'flex' ? 'none' : 'flex';
    }

    // Toggle settings popup
    function toggleSettingsPopup() {
        const popup = document.getElementById('settingsPopup');
        popup.style.display = popup.style.display === 'flex' ? 'none' : 'flex';
    }

    // Apply settings
    function applySettings() {
        // Get selected values
        const waveformStyle = document.getElementById('waveformStyleSelector').value;
        const recordingSource = document.getElementById('recordingSourceSelector').value;
        const midiMapping = document.getElementById('midiMappingSelector').value;
        
        // Apply waveform style
        applyWaveformStyle(waveformStyle);
        
        // Set recording source
        activeRecordingSource = recordingSource;
        
        // Apply MIDI mapping
        applyMIDIMapping(midiMapping);
        
        // Close popup
        toggleSettingsPopup();
    }

    // Apply waveform style
    function applyWaveformStyle(style) {
        currentWaveformStyle = style;
    }

    // Apply MIDI mapping
    function applyMIDIMapping(mapping) {
        // This is a placeholder for MIDI mapping
        // In a real application, you would change how MIDI messages are handled
        console.log('Applying MIDI mapping:', mapping);
    }

    // Initialize when page loads
    window.addEventListener('load', init);
    window.addEventListener('resize', setupCanvasDimensions);
</script>

<!-- Recorder functions -->
<script>
    async function setupRecording() {
        try {
            // Create or reuse a MediaStreamDestination to capture the master output
            if (!window.recordingDestination) {
                window.recordingDestination = audioContext.createMediaStreamDestination();
            }

            // Connect the end of the EQ chain to the recording destination if possible
            try {
                if (globalEqFilters && globalEqFilters.length > 0) {
                    // Connect last global EQ filter to the recording destination (in addition to destination)
                    globalEqFilters[globalEqFilters.length - 1].connect(window.recordingDestination);
                } else {
                    // Fallback: connect analyserMaster to recording destination
                    analyserMaster.connect(window.recordingDestination);
                }
            } catch (e) {
                console.warn("No globalEqFilters available yet:", e);
                try { analyserMaster.connect(window.recordingDestination); } catch(e2) {}
            }

            // Prepare mic stream (for "mic" recording source)
            window._micStream = null;
            document.getElementById('recordingSourceSelector').addEventListener('change', (e) => {
                activeRecordingSource = e.target.value;
            });

            console.log("Recording setup complete.");
        } catch (err) {
            console.error("setupRecording error:", err);
        }
    }

    // Utility: encode AudioBuffer to WAV (16-bit PCM)
    function encodeWAV(audioBuffer) {
        const numChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const format = 1; // PCM
        const bitsPerSample = 16;

        // interleave
        let samples;
        if (numChannels === 2) {
            const left = audioBuffer.getChannelData(0);
            const right = audioBuffer.getChannelData(1);
            samples = new Int16Array(left.length + right.length);
            let index = 0;
            for (let i = 0; i < left.length; i++) {
                samples[index++] = Math.max(-1, Math.min(1, left[i])) * 0x7fff;
                samples[index++] = Math.max(-1, Math.min(1, right[i])) * 0x7fff;
            }
        } else {
            const ch = audioBuffer.getChannelData(0);
            samples = new Int16Array(ch.length);
            for (let i = 0; i < ch.length; i++) {
                samples[i] = Math.max(-1, Math.min(1, ch[i])) * 0x7fff;
            }
        }

        const blockAlign = numChannels * bitsPerSample / 8;
        const byteRate = sampleRate * blockAlign;
        const dataSize = samples.length * (bitsPerSample / 8);
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);

        /* RIFF identifier */
        writeString(view, 0, 'RIFF');
        /* file length */
        view.setUint32(4, 36 + dataSize, true);
        /* RIFF type */
        writeString(view, 8, 'WAVE');
        /* format chunk identifier */
        writeString(view, 12, 'fmt ');
        /* format chunk length */
        view.setUint32(16, 16, true);
        /* sample format (raw) */
        view.setUint16(20, format, true);
        /* channel count */
        view.setUint16(22, numChannels, true);
        /* sample rate */
        view.setUint32(24, sampleRate, true);
        /* byte rate (sample rate * block align) */
        view.setUint32(28, byteRate, true);
        /* block align (channel count * bytes per sample) */
        view.setUint16(32, blockAlign, true);
        /* bits per sample */
        view.setUint16(34, bitsPerSample, true);
        /* data chunk identifier */
        writeString(view, 36, 'data');
        /* data chunk length */
        view.setUint32(40, dataSize, true);

        // write the PCM samples
        let offset = 44;
        for (let i = 0; i < samples.length; i++, offset += 2) {
            view.setInt16(offset, samples[i], true);
        }

        return new Blob([view], { type: 'audio/wav' });

        function writeString(dataview, offset, string) {
            for (let i = 0; i < string.length; i++) {
                dataview.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    }

    // Convert arbitrary audio Blob (like webm/opus) to WAV by decoding and re-encoding
    async function convertBlobToWav(blob) {
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        // If channel count >2, downmix to stereo
        if (audioBuffer.numberOfChannels > 2) {
            // create stereo buffer
            const offline = audioContext.createBuffer(2, audioBuffer.length, audioBuffer.sampleRate);
            const outL = offline.getChannelData(0);
            const outR = offline.getChannelData(1);
            for (let i = 0; i < audioBuffer.length; i++) {
                let sumL = 0, sumR = 0;
                for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
                    const d = audioBuffer.getChannelData(ch)[i];
                    if (ch % 2 === 0) sumL += d; else sumR += d;
                }
                outL[i] = sumL / Math.ceil(audioBuffer.numberOfChannels / 2);
                outR[i] = sumR / Math.floor(audioBuffer.numberOfChannels / 2);
            }
            return encodeWAV(offline);
        } else {
            return encodeWAV(audioBuffer);
        }
    }

    // Toggle recording (start/stop)
    async function toggleRecording() {
        try {
            const button = document.getElementById('recordButton');
            if (!isRecording) {
                // Start recording
                // Ensure recordingDestination is ready
                await setupRecording();

                const sourceSelector = document.getElementById('recordingSourceSelector').value;
                let stream;
                if (sourceSelector === 'mic') {
                    // ask for mic permissions and use mic stream
                    window._micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream = window._micStream;
                } else {
                    // master output stream
                    if (!window.recordingDestination) {
                        alert('No recording destination available.');
                        return;
                    }
                    stream = window.recordingDestination.stream;
                }

                // Use MediaRecorder (will likely be webm/opus) and then convert to WAV
                const options = { mimeType: 'audio/webm' };
                try {
                    mediaRecorder = new MediaRecorder(stream, options);
                } catch (e) {
                    // fallback without mimeType
                    mediaRecorder = new MediaRecorder(stream);
                }

                recordedChunks = [];
                mediaRecorder.ondataavailable = (ev) => {
                    if (ev.data && ev.data.size > 0) recordedChunks.push(ev.data);
                };

                mediaRecorder.onstop = async () => {
                    try {
                        const blob = new Blob(recordedChunks, { type: recordedChunks[0].type || 'audio/webm' });
                        // Convert to WAV
                        const wavBlob = await convertBlobToWav(blob);
                        lastWavBlob = wavBlob;
                        // Show save button
                        document.getElementById('saveButton').style.display = 'inline-block';
                        // Create automatic download link (temporary)
                        const url = URL.createObjectURL(wavBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'rtbs_recording_' + new Date().toISOString().replace(/[:.]/g,'-') + '.wav';
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        URL.revokeObjectURL(url);
                    } catch (err) {
                        console.error('Error converting recording to WAV:', err);
                        alert('Error al convertir la grabación a WAV. Revisa la consola.');
                    }
                };

                mediaRecorder.start();
                isRecording = true;
                button.textContent = 'Grabando...';
                button.style.background = '#AA0000';
                console.log('Recording started.');
            } else {
                // Stop recording
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
                // stop mic stream if used
                if (window._micStream) {
                    window._micStream.getTracks().forEach(t => t.stop());
                    window._micStream = null;
                }
                isRecording = false;
                document.getElementById('recordButton').textContent = 'Grabar';
                document.getElementById('recordButton').style.background = '';
                console.log('Recording stopped.');
            }
        } catch (err) {
            console.error('toggleRecording error:', err);
            alert('Error al iniciar/detener la grabación. Mira la consola.');
        }
    }

    // Save last WAV to disk (if exists)
    function saveRecording() {
        if (!lastWavBlob) {
            alert('No hay grabación para guardar.');
            return;
        }
        const url = URL.createObjectURL(lastWavBlob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = 'rtbs_recording_' + new Date().toISOString().replace(/[:.]/g,'-') + '.wav';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }
</script>
</body>
</html>
