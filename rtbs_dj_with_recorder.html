<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>RTBS CREW DJ CONTROLLER MIX - MOD</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
/* --- Estilos principales de la mesa de DJ --- */
body { margin:0; font-family:'Comic Sans MS', cursive, sans-serif; background: black; color: #FFFF00; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
.container { display: flex; flex-direction: column; gap: 20px; padding: 20px; background: #111; border-radius: 10px; border: 2px solid #333; width: 90%; max-width: 1200px; margin: auto; position: relative; }
h1 { text-align: center; margin-top: 0; }
.waveforms-container-top { position: relative; width: 100%; height: 100px; background: #000; border: 2px solid #00f; border-radius: 5px; overflow: hidden; }
#superimposedWaveformCanvas { width: 100%; height: 100%; display:block; }
.waveforms-dual-container { display: flex; justify-content: space-between; gap: 10px; }
.waveform-deck-container { width: 100%; height: 80px; background: #222; border: 2px solid #00f; border-radius: 5px; overflow: hidden; position: relative; }
.waveform-deck-container.deck1 { border-color: #00FF00; }
.waveform-deck-container.deck2 { border-color: #FF0000; }
.hot-cue-marker { position: absolute; width: 2px; height: 100%; background: #0080FF; top: 0; pointer-events:none; z-index:5; }
#waveformCanvas1, #waveformCanvas2 { width: 100%; height: 100%; display:block; }
.decks-container { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; gap: 20px; }
.deck { display: flex; flex-direction: column; align-items: center; gap: 10px; width: auto; position: relative; z-index:1; }
.deck h3 { display: flex; align-items: center; gap: 5px; }
.bpm-display { font-size: 12px; color: #00FF00; }
.platter { width: 120px; height: 120px; background: #222; border-radius: 50%; border: 4px solid #00f; box-shadow: 0 0 10px #00f; display: flex; justify-content: center; align-items: center; position: relative; z-index:2; }
.platter-inner { width: 60px; height: 60px; background: #080; border-radius: 50%; border: 2px solid #00f; display: flex; align-items: center; justify-content: center; font-size: 10px; }
.controls { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
.buttons { display: flex; gap: 10px; z-index:3; position: relative; }
.button { width: 60px; height: 30px; background: #080; border: 2px solid #00f; border-radius: 5px; display: flex; justify-content: center; align-items: center; cursor: pointer; user-select:none; }
.crossfader-container { margin-top: 20px; text-align: center; position:relative; z-index:3; }
#crossfader { width: 90%; }
.control-block {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    padding: 10px;
    border: 1px solid #444;
    border-radius: 8px;
    background: #222;
}
.eq-group {
    display: flex;
    justify-content: space-around;
    width: 100%;
    gap: 15px;
}
.eq-control {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.eq-control label { font-size: 12px; font-weight: bold; }
.rotary-knob {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    width: 60px;
    height: 60px;
    transform: rotate(270deg);
}
.rotary-knob::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; height: 20px; width: 20px; background-color: #00f; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); margin-top: -10px; }
.rotary-knob::-moz-range-thumb { height: 20px; width: 20px; background-color: #00f; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); }
.rotary-knob::-webkit-slider-runnable-track { background: #555; height: 5px; border-radius: 5px; }
.rotary-knob::-moz-range-track { background: #555; height: 5px; border-radius: 5px; }
.eq-on-off { width: 40px; height: 20px; border: 2px solid #00f; background: #333; color: #fff; font-size: 8px; cursor: pointer; border-radius: 5px; }
.vertical-fader-container { height: 120px; width: 20px; position: relative; }
.vertical-fader {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    width: 120px;
    height: 20px;
    transform-origin: center;
    transform: rotate(270deg);
}
.vertical-fader::-webkit-slider-runnable-track { background: #555; height: 8px; border-radius: 5px; }
.vertical-fader::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; margin-top: -4px; }
.vertical-fader::-moz-range-thumb { width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; }
.progress-container { width: 100%; display: flex; flex-direction: column; gap: 5px; z-index: 10; padding: 5px; margin-top: 10px; }
.progress-bar { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #555; border-radius: 5px; cursor: pointer; }
.progress-bar::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; }
.progress-bar::-moz-range-thumb { width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; }
.time-display { display: flex; justify-content: space-between; font-size: 10px; }
.platter.playing { animation: spin 2s linear infinite; }
.platter.paused { animation-play-state: paused; }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
#equalizer-popup { display: none; flex-direction: column; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; border: 2px solid #808080; padding: 10px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); z-index: 1000; flex-direction: column; align-items: center; }
#equalizer-popup h3 { color: #0080FF; margin-top: 5px; margin-bottom: 10px; }
.eq-container { display: flex; flex-direction: column; gap: 10px; }
.eq-row { display: flex; justify-content: center; gap: 5px; }
.band { display: flex; flex-direction: column; align-items: center; width: 20px; }
.band label { font-size: 8px; color: #fff; margin-top: 5px; }
.band input[type="range"] { -webkit-appearance: slider-vertical; width: 20px; height: 120px; background: #0080FF; }
.close-btn { background: #FF0000; color: #fff; border: none; padding: 5px; cursor: pointer; margin-top: 10px; font-size: 12px; }
.loop-pads { display: flex; gap: 5px; margin-top: 10px; justify-content: center; width: 100%; }
.loop-pad { width: 45px; height: 45px; background: #005080; border: 2px solid #00f; border-radius: 5px; display: flex; justify-content: center; align-items: center; cursor: pointer; font-size: 10px; font-weight: bold; user-select: none; }
.loop-pad:active, .loop-pad.active { background: #00aaff; box-shadow: 0 0 10px #00aaff; }
#settingsButton { position: absolute; top: 10px; right: 10px; width: 40px; height: 40px; background: transparent; border: null; cursor: pointer; font-size: 30px; color: #fff; text-shadow: 0 0 5px #00f; z-index:4; }
#settingsPopup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; border: 2px solid #808080; padding: 20px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); z-index: 1001; flex-direction: column; align-items: center; gap: 15px; }
.settings-section { display: flex; flex-direction: column; gap: 5px; }
.settings-section label { font-size: 14px; font-weight: bold; }
.settings-section select { background: #333; color: #FFFF00; border: 1px solid #00f; padding: 5px; }
.deck-flex-container { display: flex; justify-content: center; align-items: flex-end; width: 100%; gap: 10px; }
.deck-controls-left { display: flex; flex-direction: column; align-items: center; gap: 10px; position: relative; }
.deck-center-controls { display: flex; flex-direction: column; align-items: center; gap: 10px; }
.hot-cues-and-reverse { display: flex; flex-direction: column; align-items: center; gap: 5px; }
.reverse-button { background: #FF0000; color: #fff; border: 2px solid #fff; cursor: pointer; user-select:none; }
.reverse-button.active { background: #ff7700; box-shadow: 0 0 10px #ff7700; }
.effects-platter-container { display: flex; flex-direction: column; align-items: center; gap: 5px; padding: 10px; border: 1px solid #444; border-radius: 8px; background: #222; z-index:2; }
.effect-button-platter { width: 40px; height: 40px; background: #500050; border: 2px solid #FF00FF; border-radius: 5px; color: #fff; font-size: 8px; text-align: center; line-height: 40px; cursor: pointer; user-select:none; }
.effect-button-platter.active { background: #ff00ff; box-shadow: 0 0 10px #ff00ff; }
.top-waveform-indicator { position: absolute; left: 50%; top: 0; width: 2px; height: 100%; background: #fff; z-index: 15; pointer-events:none; }
.center-controls-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    padding: 15px;
    background: #222;
    border: 1px solid #444;
    border-radius: 10px;
    margin-left: auto;
    margin-right: auto;
    width: 340px;
    z-index:3;
}
.fader-effects-container {
    display: flex;
    gap: 20px;
    justify-content: center;
    width: 100%;
}
.effect-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.effect-button-platter {
    width: 40px;
    height: 40px;
    background: #500050;
    border: 2px solid #FF00FF;
    border-radius: 5px;
    color: #fff;
    font-size: 8px;
    text-align: center;
    line-height: 40px;
    cursor: pointer;
    user-select:none;
}
.effect-button-platter.active {
    background: #ff00ff;
    box-shadow: 0 0 10px #ff00ff;
}
/* Ensure crossfader doesn't cover buttons */
.crossfader-container, .buttons { z-index: 3; }

/* Botones de navegación rápida */
.navigation-buttons {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}
.nav-button {
    width: 50px;
    height: 25px;
    background: #333;
    border: 1px solid #00f;
    border-radius: 3px;
    color: #fff;
    font-size: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
}
.nav-button:active {
    background: #555;
}
</style>
</head>
<body>

<div class="container">
    <button id="settingsButton" onclick="toggleSettingsPopup()">⚙️</button>
    <h1>RTBS CREW DJ CONTROLLER MIX — MOD</h1>

    <div class="waveforms-container-top">
        <canvas id="superimposedWaveformCanvas"></canvas>
        <div class="top-waveform-indicator"></div>
    </div>

    <div class="decks-container">
        <div class="deck" data-deck="1">
            <h3>Plato 1 <span id="bpmDisplay1" class="bpm-display"></span></h3>
            <div class="platter" id="platter1" onclick="toggleSuperimpose(1)">
                <div class="platter-inner">Plato 1</div>
            </div>
            <input type="file" id="fileInput1" accept="audio/*">
            <div class="progress-container">
                <input type="range" id="progressBar1" class="progress-bar" min="0" max="1" step="0.001" value="0">
                <div class="time-display">
                    <span id="currentTime1">0:00</span>
                    <span id="duration1">0:00</span>
                </div>
            </div>
            <div class="waveform-deck-container deck1">
                <canvas id="waveformCanvas1"></canvas>
            </div>
            
            <div class="navigation-buttons">
                <div class="nav-button" onclick="navigateByBeats(1, -4)">-4 B</div>
                <div class="nav-button" onclick="navigateByBeats(1, 4)">+4 B</div>
            </div>
            
            <div class="loop-pads" id="loopPads1">
                <div class="loop-pad" data-value="0.125" onmousedown="startLoopRoll(1, 0.125)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/8</div>
                <div class="loop-pad" data-value="0.0625" onmousedown="startLoopRoll(1, 0.0625)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/16</div>
                <div class="loop-pad" data-value="0.25" onmousedown="startLoopRoll(1, 0.25)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/4</div>
                <div class="loop-pad" data-value="0.5" onmousedown="startLoopRoll(1, 0.5)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/2</div>
                <div class="loop-pad" data-value="1" onmousedown="startLoopRoll(1, 1)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1</div>
                <div class="loop-pad" data-value="2" onmousedown="startLoopRoll(1, 2)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">2</div>
            </div>
            
            <div class="deck-flex-container">
                <div class="deck-controls-left">
                    <div class="control-block">
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>B</label>
                                <input type="range" id="bass1" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>M</label>
                                <input type="range" id="mid1" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>T</label>
                                <input type="range" id="treble1" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                        </div>
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>Ganancia</label>
                                <input type="range" id="gain1" min="0" max="2" step="0.01" value="1" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>Filtro</label>
                                <input type="range" id="filter1" min="20" max="22050" step="1" value="22050" class="rotary-knob">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: center; gap: 10px;">
                            <button class="eq-on-off" onclick="toggleEQ('bass', 1)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('mid', 1)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('treble', 1)">Kill</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="center-controls-container">
            <div class="fader-effects-container">
                <div class="vertical-fader-container">
                    <input type="range" id="volume1" min="0" max="1" step="0.01" value="0.7" class="vertical-fader">
                </div>
                <div class="effect-group">
                    <h4>Efectos 1</h4>
                    <button class="effect-button-platter" id="effect1-cut" onclick="toggleEffect(1, 'cut')">CUT</button>
                    <button class="effect-button-platter" id="effect1-flanger" onclick="toggleEffect(1, 'flanger')">FLNG</button>
                </div>
                <div class="vertical-fader-container">
                    <input type="range" id="volume2" min="0" max="1" step="0.01" value="0.7" class="vertical-fader">
                </div>
                <div class="effect-group">
                    <h4>Efectos 2</h4>
                    <button class="effect-button-platter" id="effect2-cut" onclick="toggleEffect(2, 'cut')">CUT</button>
                    <button class="effect-button-platter" id="effect2-flanger" onclick="toggleEffect(2, 'flanger')">FLNG</button>
                </div>
            </div>

            <div class="pitch-controls">
                <label>Pitch 1</label>
                <input type="range" id="pitch1" min="0.5" max="2" step="0.01" value="1">
                <label>Pitch 2</label>
                <input type="range" id="pitch2" min="0.5" max="2" step="0.01" value="1">
            </div>
            <div class="buttons">
                <div class="button" id="button1" onclick="playPause(1)">Play</div>
                <div class="button" id="sync1" onclick="sync(1)">Sync</div>
                <div class="button" id="button2" onclick="playPause(2)">Play</div>
                <div class="button" id="sync2" onclick="sync(2)">Sync</div>
            </div>
            
            <div class="crossfader-container">
                <span>Crossfader</span><br>
                <input type="range" id="crossfader" min="0" max="1" step="0.01" value="0.5">
            </div>
            
            <div class="hot-cues-and-reverse">
                <div style="display:flex; gap:8px; align-items:center;">
                    <div>
                        <button class="hot-cue-button button" id="hotCue1" onclick="toggleHotCue(1)">HotCue</button>
                        <div style="font-size:10px; text-align:center;">Guardar / Ir</div>
                    </div>
                    <div>
                        <button class="button" id="deleteHotCue1" onclick="deleteHotCue(1)">Eliminar</button>
                        <div style="font-size:10px; text-align:center;">Eliminar hotcue</div>
                    </div>
                    <div>
                        <button class="hot-cue-button button" id="hotCue2" onclick="toggleHotCue(2)">HotCue</button>
                        <div style="font-size:10px; text-align:center;">Guardar / Ir</div>
                    </div>
                    <div>
                        <button class="button" id="deleteHotCue2" onclick="deleteHotCue(2)">Eliminar</button>
                        <div style="font-size:10px; text-align:center;">Eliminar hotcue</div>
                    </div>
                </div>
                <div style="margin-top:8px;">
                    <button class="button reverse-button" id="reverse1" onmousedown="startReverse(1)" onmouseup="stopReverse(1)" onmouseleave="stopReverse(1)">Reverse 1 (hold)</button>
                    <button class="button reverse-button" id="reverse2" onmousedown="startReverse(2)" onmouseup="stopReverse(2)" onmouseleave="stopReverse(2)">Reverse 2 (hold)</button>
                </div>
            </div>
        </div>

        <div class="deck" data-deck="2">
            <h3>Plato 2 <span id="bpmDisplay2" class="bpm-display"></span></h3>
            <div class="platter" id="platter2" onclick="toggleSuperimpose(2)">
                <div class="platter-inner">Plato 2</div>
            </div>
            <input type="file" id="fileInput2" accept="audio/*">
            <div class="progress-container">
                <input type="range" id="progressBar2" class="progress-bar" min="0" max="1" step="0.001" value="0">
                <div class="time-display">
                    <span id="currentTime2">0:00</span>
                    <span id="duration2">0:00</span>
                </div>
            </div>
            <div class="waveform-deck-container deck2">
                <canvas id="waveformCanvas2"></canvas>
            </div>
            
            <div class="navigation-buttons">
                <div class="nav-button" onclick="navigateByBeats(2, -4)">-4 B</div>
                <div class="nav-button" onclick="navigateByBeats(2, 4)">+4 B</div>
            </div>
            
            <div class="loop-pads" id="loopPads2">
                <div class="loop-pad" data-value="0.125" onmousedown="startLoopRoll(2, 0.125)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/8</div>
                <div class="loop-pad" data-value="0.0625" onmousedown="startLoopRoll(2, 0.0625)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/16</div>
                <div class="loop-pad" data-value="0.25" onmousedown="startLoopRoll(2, 0.25)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/4</div>
                <div class="loop-pad" data-value="0.5" onmousedown="startLoopRoll(2, 0.5)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/2</div>
                <div class="loop-pad" data-value="1" onmousedown="startLoopRoll(2, 1)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1</div>
                <div class="loop-pad" data-value="2" onmousedown="startLoopRoll(2, 2)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">2</div>
            </div>
            
            <div class="deck-flex-container">
                <div class="deck-controls-left">
                    <div class="control-block">
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>B</label>
                                <input type="range" id="bass2" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>M</label>
                                <input type="range" id="mid2" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>T</label>
                                <input type="range" id="treble2" min="-20" max; max="20" value="0" class="rotary-knob">
                            </div>
                        </div>
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>Ganancia</label>
                                <input type="range" id="gain2" min="0" max="2" step="0.01" value="1" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>Filtro</label>
                                <input type="range" id="filter2" min="20" max="22050" step="1" value="22050" class="rotary-knob">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: center; gap: 10px;">
                            <button class="eq-on-off" onclick="toggleEQ('bass', 2)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('mid', 2)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('treble', 2)">Kill</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div style="text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px;">
        <button onclick="toggleEqualizerPopup()">Ecualizador de 30 bandas</button>
        <div class="button" id="recordButton" onclick="toggleRecording()" style="width: auto;">Grabar</div>
        <div class="button" id="saveButton" onclick="saveRecording()" style="width: auto; background: #FF5733; display: none;">Guardar</div>
    </div>
</div>

<div id="equalizer-popup">
    <h3>Ecualizador de 30 bandas</h3>
    <div class="eq-container">
        <div class="eq-row" id="row1"></div>
        <div class="eq-row" id="row2"></div>
    </div>
    <button class="close-btn" onclick="toggleEqualizerPopup()">Cerrar</button>
</div>

<div id="settingsPopup">
    <h3>Ajustes de Sonido y MIDI</h3>
    <div class="settings-section">
        <label for="audioOutputSelector">Salida de Sonido:</label>
        <select id="audioOutputSelector"></select>
    </div>
    <div class="settings-section">
        <label for="midiInputSelector">Controlador MIDI:</label>
        <select id="midiInputSelector"></select>
    </div>
    <div class="settings-section">
        <label for="waveformStyleSelector">Visualizador de Onda:</label>
        <select id="waveformStyleSelector">
            <option value="default">Verde y Rojo</option>
            <option value="blue-orange">Azul y Naranja</option>
            <option value="rainbow">Arcoíris</option>
            <option value="mono">Monocromático</option>
            <option value="gradient">Degradado</option>
            <option value="bars">Barras</option>
            <option value="dots">Puntos</option>
            <option value="outline">Contorno</option>
        </select>
    </div>

    <div class="settings-section">
        <label for="recordingSourceSelector">Fuente de Grabación:</label>
        <select id="recordingSourceSelector">
            <option value="master">Salida Master (Línea)</option>
            <option value="mic">Micrófono</option>
        </select>
    </div>
    
    <div class="settings-section">
        <label for="midiMappingSelector">Mapeo MIDI:</label>
        <select id="midiMappingSelector">
            <option value="default">Por Defecto</option>
            <option value="traktor">Traktor</option>
            <option value="serato">Serato</option>
            <option value="rekordbox">Rekordbox</option>
            <option value="virtualdj">VirtualDJ</option>
            <option value="custom">Personalizado</option>
        </select>
    </div>

    <button class="close-btn" onclick="applySettings()">Aplicar</button>
    <button class="close-btn" onclick="toggleSettingsPopup()">Cerrar</button>
</div>
<script>
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const masterGainNode = audioContext.createGain(); // NUEVO: Nodo principal del Master Bus
    window.masterGainNode = masterGainNode; 
    let decks = {
        1: {
            audio: null,
            audioBuffer: null,
            source: null,
            gainNode: audioContext.createGain(),
            filterNode: audioContext.createBiquadFilter(),
            analyser: null,
            isPlaying: false,
            startTime: 0,
            pauseTime: 0,
            isReversed: false,
            reversedBuffer: null,
            eq: { bass: audioContext.createBiquadFilter(), mid: audioContext.createBiquadFilter(), treble: audioContext.createBiquadFilter() },
            isLoaded: false,
            animationFrame: null,
            eqState: { bass: true, mid: true, treble: true },
            eqValue: { bass: 0, mid: 0, treble: 0 },
            bpm: 0,
            loopRollSource: null,
            vinylBrakeInterval: null,
            hotCue: null,
            effects: { cut: false, flanger: false },
            vinylStartSound: null,
            vinylStopSound: null,
            // Efectos
            crossfaderNode: audioContext.createGain(), // NUEVO: Para el Crossfader
            effectsBus: audioContext.createGain(), // NUEVO: Bus para insertar efectos
            cutEffect: null,
            flangerEffect: null,
            flangerFeedback: null,
            flangerLFO: null,
            // Para el visualizador superior
            waveformData: null,
            currentBeat: 0
        },
        2: {
            audio: null,
            audioBuffer: null,
            source: null,
            gainNode: audioContext.createGain(),
            filterNode: audioContext.createBiquadFilter(),
            analyser: null,
            isPlaying: false,
            startTime: 0,
            pauseTime: 0,
            isReversed: false,
            reversedBuffer: null,
            eq: { bass: audioContext.createBiquadFilter(), mid: audioContext.createBiquadFilter(), treble: audioContext.createBiquadFilter() },
            isLoaded: false,
            animationFrame: null,
            eqState: { bass: true, mid: true, treble: true },
            eqValue: { bass: 0, mid: 0, treble: 0 },
            bpm: 0,
            loopRollSource: null,
            vinylBrakeInterval: null,
            hotCue: null,
            effects: { cut: false, flanger: false },
            vinylStartSound: null,
            vinylStopSound: null,
            // Efectos
            crossfaderNode: audioContext.createGain(), // NUEVO: Para el Crossfader
            effectsBus: audioContext.createGain(), // NUEVO: Bus para insertar efectos
            cutEffect: null,
            flangerEffect: null,
            flangerFeedback: null,
            flangerLFO: null,
            // Para el visualizador superior
            waveformData: null,
            currentBeat: 0
        }
    };
    let mediaRecorder;
    let recordedChunks = [];
    let analyserMaster = audioContext.createAnalyser(); analyserMaster.fftSize = 2048;
    let showDeck = {1:true,2:true}; // control which deck wave is superimposed
    
    let recordingStream;
    let isRecording = false;
    let activeRecordingSource = 'master';
    let currentWaveformStyle = 'default';

    // 30-band equalizer
    const frequencies = [
        32, 64, 125, 250, 500, 1000, 2000, 4000, 8000, 16000,
        31, 62, 125, 250, 500, 1000, 2000, 4000, 8000, 16000,
        20, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240
    ];
    const eqNodes = [];
    let globalEqFilters = [];
    const row1 = document.getElementById('row1');
    const row2 = document.getElementById('row2');

    const superCanvas = document.getElementById('superimposedWaveformCanvas');
    const superCtx = superCanvas.getContext('2d');

    // Cargar sonidos de inicio y parada de vinilo
    async function loadVinylSounds() {
        try {
            // Crear sonidos sintéticos para inicio y parada de vinilo
            const createVinylSound = (fadeIn, duration) => {
                const sampleRate = audioContext.sampleRate;
                const length = sampleRate * duration;
                const buffer = audioContext.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < length; i++) {
                    // Ruido blanco
                    let value = Math.random() * 2 - 1;
                    
                    // Aplicar filtro de paso bajo para simular ruido de vinilo
                    if (i > 0) {
                        value = 0.95 * data[i-1] + 0.05 * value;
                    }
                    
                    // Aplicar envolvente
                    let envelope;
                    if (fadeIn) {
                        envelope = Math.min(1, i / (sampleRate * 0.1)); // Fade in rápido
                    } else {
                        envelope = Math.max(0, 1 - (i / (sampleRate * 0.3))); // Fade out más lento
                    }
                    
                    data[i] = value * envelope * 0.3;
                }
                
                return buffer;
            };
            
            decks[1].vinylStartSound = createVinylSound(true, 0.2);
            decks[1].vinylStopSound = createVinylSound(false, 0.5);
            decks[2].vinylStartSound = createVinylSound(true, 0.2);
            decks[2].vinylStopSound = createVinylSound(false, 0.5);
        } catch (error) {
            console.error("Error creating vinyl sounds:", error);
        }
    }

    // Reproducir sonido de vinilo
    function playVinylSound(deckNum, isStart) {
        if (!decks[deckNum]) return;
        
        const buffer = isStart ? decks[deckNum].vinylStartSound : decks[deckNum].vinylStopSound;
        if (!buffer) return;
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);
        source.start();
    }

    // Inicializar ecualizador de 30 bandas
    function init30BandEQ() {
        // Clear existing nodes
        while (globalEqFilters.length > 0) {
            const filter = globalEqFilters.pop();
            filter.disconnect();
        }
        
        // Create new filters
        for (let i = 0; i < frequencies.length; i++) {
            const filter = audioContext.createBiquadFilter();
            filter.type = 'peaking';
            filter.frequency.value = frequencies[i];
            filter.Q.value = 1;
            filter.gain.value = 0;
            
            // Connect in series
            if (i === 0) {
                analyserMaster.connect(filter);
            } else {
                globalEqFilters[i-1].connect(filter);
            }
            
            globalEqFilters.push(filter);
            
            // Create UI controls
            const band = document.createElement('div');
            band.className = 'band';
            const input = document.createElement('input');
            input.type = 'range';
            input.min = '-20';
            input.max = '20';
            input.value = '0';
            input.dataset.index = i;
            input.addEventListener('input', (e) => {
                const index = parseInt(e.target.dataset.index);
                globalEqFilters[index].gain.value = parseFloat(e.target.value);
            });
            const label = document.createElement('label');
            label.textContent = `${frequencies[i]}Hz`;
            band.appendChild(input);
            band.appendChild(label);
            
            if (i < 15) {
                row1.appendChild(band);
            } else {
                row2.appendChild(band);
            }
        }
        
        // Connect the last filter to destination and recording destination
        if (globalEqFilters.length > 0) {
            globalEqFilters[globalEqFilters.length - 1].connect(audioContext.destination);
            if (window.recordingDestination) {
                globalEqFilters[globalEqFilters.length - 1].connect(window.recordingDestination); // CONEXIÓN DE GRABACIÓN
            }
        }
    }

    // Connect audio nodes for a deck
    function setupAudioRouting(deckNum) {
        const deck = decks[deckNum];
        
        // Disconnect all to reset chain
        if (deck.source) deck.source.disconnect();
        deck.eq.bass.disconnect();
        deck.eq.mid.disconnect();
        deck.eq.treble.disconnect();
        deck.filterNode.disconnect();
        deck.gainNode.disconnect();
        deck.effectsBus.disconnect(); // NEW
        
        // --- DECK CHAIN ---
        // 1. Source -> EQ (Bass)
        if (deck.source) deck.source.connect(deck.eq.bass);
        
        // 2. EQ Chain (Bass -> Mid -> Treble)
        deck.eq.bass.connect(deck.eq.mid);
        deck.eq.mid.connect(deck.eq.treble);
        
        // 3. EQ (Treble) -> Filter
        deck.eq.treble.connect(deck.filterNode);
        
        // 4. Filter -> Gain (Volume Fader)
        deck.filterNode.connect(deck.gainNode);

        // 5. Gain -> Effects Bus (NEW: Point of insertion for Cut/Flanger)
        deck.gainNode.connect(deck.effectsBus);
        
        // 6. Effects Bus -> Crossfader Node (The final output from the deck)
        // By default, effectsBus connects directly to crossfaderNode
        deck.effectsBus.connect(deck.crossfaderNode);
        
        // Re-apply effects routing to ensure correct chain (Effect Bus -> Effect Node -> Crossfader Node)
        updateEffectRouting(deckNum);
    }

    // Draw waveform on deck canvas
    function drawFullWaveform(deckNum) {
        const canvas = document.getElementById(`waveformCanvas${deckNum}`);
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        ctx.clearRect(0, 0, width, height);
        if (!decks[deckNum].audioBuffer) return;
        
        const audioBuffer = decks[deckNum].audioBuffer;
        const channelData = audioBuffer.getChannelData(0);
        const step = Math.ceil(channelData.length / width);
        
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        
        // Choose color based on deck
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        for (let i = 0; i < width; i++) {
            let min = 0;
            let max = 0;
            for (let j = 0; j < step; j++) {
                const index = i * step + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            ctx.lineTo(i, height / 2 - min * height / 2);
            ctx.lineTo(i, height / 2 - max * height / 2);
        }
        ctx.stroke();
    }

    // Play/Pause track
    function playPause(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        if (decks[deckNum].isPlaying) {
            pauseTrack(deckNum);
        } else {
            playTrack(deckNum);
        }
    }

    // Play track
    function playTrack(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        
        // Play vinyl start sound
        playVinylSound(deckNum, true);
        
        const source = audioContext.createBufferSource();
        if (decks[deckNum].isReversed) {
            source.buffer = decks[deckNum].reversedBuffer;
        } else {
            source.buffer = decks[deckNum].audioBuffer;
        }
        
        // Set playback rate
        source.playbackRate.value = parseFloat(document.getElementById(`pitch${deckNum}`).value);
        
        // Store source
        decks[deckNum].source = source;
        
        // Set up audio routing from source to master bus
        setupAudioRouting(deckNum); 
        
        // Calculate start time
        let startTime;
        if (decks[deckNum].pauseTime > 0) {
            startTime = audioContext.currentTime - decks[deckNum].pauseTime;
        } else {
            startTime = audioContext.currentTime;
        }
        
        // Start playback
        source.start(0, decks[deckNum].pauseTime);
        
        // Update state
        decks[deckNum].isPlaying = true;
        decks[deckNum].startTime = startTime;
        decks[deckNum].pauseTime = 0;
        
        document.getElementById(`button${deckNum}`).textContent = 'Pausa';
        document.getElementById(`platter${deckNum}`).classList.add('playing');
        
        // Start animation loop
        if (decks[deckNum].animationFrame) {
            cancelAnimationFrame(decks[deckNum].animationFrame);
        }
        animateProgress(deckNum);
        
        // Stop automatically at the end
        source.onended = () => {
            if (!decks[deckNum].isReversed) {
                stopTrack(deckNum);
            }
        };
    }

    // Pause track
    function pauseTrack(deckNum) {
        if (!decks[deckNum].isPlaying) return;
        
        // Stop vinyl sound
        playVinylSound(deckNum, false);
        
        // Calculate pause time
        const currentTime = audioContext.currentTime - decks[deckNum].startTime;
        decks[deckNum].pauseTime = currentTime;
        
        // Stop source and update state
        decks[deckNum].source.stop();
        decks[deckNum].isPlaying = false;
        
        document.getElementById(`button${deckNum}`).textContent = 'Play';
        document.getElementById(`platter${deckNum}`).classList.remove('playing');
        document.getElementById(`platter${deckNum}`).classList.add('paused');
        
        // Stop animation loop
        if (decks[deckNum].animationFrame) {
            cancelAnimationFrame(decks[deckNum].animationFrame);
            decks[deckNum].animationFrame = null;
        }
    }

    // Stop track and reset
    function stopTrack(deckNum) {
        if (decks[deckNum].isPlaying) {
            decks[deckNum].source.stop();
        }
        decks[deckNum].isPlaying = false;
        decks[deckNum].startTime = 0;
        decks[deckNum].pauseTime = 0;
        
        document.getElementById(`button${deckNum}`).textContent = 'Play';
        document.getElementById(`progressBar${deckNum}`).value = 0;
        document.getElementById(`currentTime${deckNum}`).textContent = '0:00';
        document.getElementById(`platter${deckNum}`).classList.remove('playing', 'paused');
        
        if (decks[deckNum].animationFrame) {
            cancelAnimationFrame(decks[deckNum].animationFrame);
            decks[deckNum].animationFrame = null;
        }
    }

    // Seek track
    function seekTrack(deckNum, progress) {
        if (!decks[deckNum].isLoaded) return;
        const wasPlaying = decks[deckNum].isPlaying;
        
        if (wasPlaying) {
            pauseTrack(deckNum);
        }
        
        const newPosition = progress * decks[deckNum].audioBuffer.duration;
        decks[deckNum].pauseTime = newPosition;
        
        if (wasPlaying) {
            playTrack(deckNum);
        } else {
            document.getElementById(`progressBar${deckNum}`).value = progress;
            document.getElementById(`currentTime${deckNum}`).textContent = formatTime(newPosition);
        }
    }

    // Sync BPM
    function sync(deckNum) {
        // Placeholder for sync logic
        alert(`Sincronizando Plato ${deckNum} (funcionalidad de demostración)`);
    }
    
    // Navegación por beats (4 tiempos)
    function navigateByBeats(deckNum, beats) {
        if (!decks[deckNum].isLoaded || decks[deckNum].bpm === 0) return;
        const wasPlaying = decks[deckNum].isPlaying;
        if (wasPlaying) {
            pauseTrack(deckNum);
        }
        // Calcular duración de un beat en segundos
        const secondsPerBeat = 60 / decks[deckNum].bpm;
        // Calcular nueva posición
        let newPosition = decks[deckNum].pauseTime + (beats * secondsPerBeat);
        // Asegurarse de que está dentro de los límites
        if (newPosition < 0) newPosition = 0;
        if (newPosition > decks[deckNum].audioBuffer.duration) newPosition = decks[deckNum].audioBuffer.duration;
        decks[deckNum].pauseTime = newPosition;
        // Update beat position
        updateBeatPosition(deckNum);
        if (wasPlaying) {
            playTrack(deckNum);
        } else {
            // Actualizar barra de progreso
            const progress = newPosition / decks[deckNum].audioBuffer.duration;
            document.getElementById(`progressBar${deckNum}`).value = progress;
            document.getElementById(`currentTime${deckNum}`).textContent = formatTime(newPosition);
        }
    }

    // Update beat position for visualization
    function updateBeatPosition(deckNum) {
        if (!decks[deckNum].isLoaded || decks[deckNum].bpm === 0) return;
        // Calcular posición actual en beats
        const secondsPerBeat = 60 / decks[deckNum].bpm;
        decks[deckNum].currentBeat = Math.floor(decks[deckNum].pauseTime / secondsPerBeat);
    }

    // Animate progress bar
    function animateProgress(deckNum) {
        if (!decks[deckNum].isPlaying) return;
        const currentTime = audioContext.currentTime - decks[deckNum].startTime;
        const duration = decks[deckNum].audioBuffer.duration;
        const progress = currentTime / duration;
        
        // Check if finished
        if (currentTime >= duration) {
            stopTrack(deckNum);
            return;
        }
        
        // Update progress bar
        document.getElementById(`progressBar${deckNum}`).value = progress;
        document.getElementById(`currentTime${deckNum}`).textContent = formatTime(currentTime);
        
        // Update beat position
        updateBeatPosition(deckNum);
        
        // Continue animation
        decks[deckNum].animationFrame = requestAnimationFrame(() => animateProgress(deckNum));
    }

    // Format time
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
    }

    // Detect BPM
    function detectBPM(deckNum, audioBuffer) {
        // Simple BPM detection (this is a placeholder)
        // In a real application, you would use a more sophisticated algorithm
        decks[deckNum].bpm = 128; 
        document.getElementById(`bpmDisplay${deckNum}`).textContent = `BPM: 128`;
    }

    // Toggle EQ
    function toggleEQ(band, deckNum) {
        const deck = decks[deckNum];
        if (deck.eqState[band]) {
            // Kill
            deck.eqValue[band] = deck.eq[band].gain.value; // Save current value
            deck.eq[band].gain.value = -40; // Hard kill
            deck.eqState[band] = false;
        } else {
            // Restore
            deck.eq[band].gain.value = decks[deckNum].eqValue[band];
            deck.eqState[band] = true;
        }
    }

    // Start reverse function
    function startReverse(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        const currentTime = decks[deckNum].isPlaying ? (audioContext.currentTime - decks[deckNum].startTime) : decks[deckNum].pauseTime;
        if (decks[deckNum].isPlaying) {
            pauseTrack(deckNum);
        }
        decks[deckNum].isReversed = true;
        decks[deckNum].pauseTime = decks[deckNum].audioBuffer.duration - currentTime;
        playTrack(deckNum);
        document.getElementById(`reverse${deckNum}`).classList.add('active');
    }

    // Stop reverse function
    function stopReverse(deckNum) {
        if (!decks[deckNum].isLoaded || !decks[deckNum].isReversed) return;
        const currentTime = decks[deckNum].audioBuffer.duration - decks[deckNum].pauseTime;
        if (decks[deckNum].isPlaying) {
            pauseTrack(deckNum);
        }
        decks[deckNum].isReversed = false;
        decks[deckNum].pauseTime = currentTime;
        playTrack(deckNum);
        document.getElementById(`reverse${deckNum}`).classList.remove('active');
    }

    // Toggle hot cue
    function toggleHotCue(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        if (decks[deckNum].hotCue === null) {
            // Set hot cue
            const currentTime = decks[deckNum].isPlaying ? (audioContext.currentTime - decks[deckNum].startTime) : decks[deckNum].pauseTime;
            decks[deckNum].hotCue = currentTime;
            // Create visual marker
            createHotCueMarker(deckNum, currentTime);
            document.getElementById(`hotCue${deckNum}`).textContent = 'GoTo';
        } else {
            // Go to hot cue
            seekTrack(deckNum, decks[deckNum].hotCue / decks[deckNum].audioBuffer.duration);
        }
    }

    // Delete hot cue
    function deleteHotCue(deckNum) {
        decks[deckNum].hotCue = null;
        document.getElementById(`hotCue${deckNum}`).textContent = 'HotCue';
        // Remove visual marker
        const markers = document.querySelectorAll(`.hot-cue-marker[data-deck="${deckNum}"]`);
        markers.forEach(marker => marker.remove());
    }

    // Create hot cue marker
    function createHotCueMarker(deckNum, time) {
        const progress = time / decks[deckNum].audioBuffer.duration;
        const waveformContainer = document.querySelector(`.waveform-deck-container.deck${deckNum}`);
        // Remove existing marker
        const existingMarker = document.querySelector(`.hot-cue-marker[data-deck="${deckNum}"]`);
        if (existingMarker) existingMarker.remove();
        
        // Create new marker
        const marker = document.createElement('div');
        marker.className = 'hot-cue-marker';
        marker.dataset.deck = deckNum;
        marker.style.left = `${progress * 100}%`;
        waveformContainer.appendChild(marker);
    }

    // Start loop roll
    function startLoopRoll(deckNum, duration) {
        if (!decks[deckNum].isLoaded || !decks[deckNum].isPlaying) return;
        
        // Pausar pista principal
        pauseTrack(deckNum);
        
        const currentTime = decks[deckNum].pauseTime;
        const startTime = currentTime;
        const endTime = startTime + duration;
        
        // Crear nuevo source en loop
        const source = audioContext.createBufferSource();
        source.buffer = decks[deckNum].audioBuffer;
        source.loop = true;
        source.loopStart = startTime;
        source.loopEnd = endTime;
        
        // Conectar source a la cadena de audio del deck
        source.connect(decks[deckNum].eq.bass);
        
        // Reproducir fragmento
        source.start(0, startTime);
        decks[deckNum].loopRollSource = { source, startTime };
        
        // Highlight active loop pad
        document.querySelector(`#loopPads${deckNum} .loop-pad[data-value="${duration}"]`).classList.add('active');
    }

    // Stop loop roll
    function stopLoopRoll(deckNum) {
        if (decks[deckNum].loopRollSource) {
            const { source, startTime } = decks[deckNum].loopRollSource;
            const now = audioContext.currentTime;
            
            // Calculate actual time in the loop
            const elapsed = now - decks[deckNum].startTime;
            const loopDuration = source.loopEnd - source.loopStart;
            
            source.stop();
            source.disconnect();
            decks[deckNum].loopRollSource = null;
            
            // Calcular nuevo punto de tiempo real (cuantizado al inicio del loop)
            decks[deckNum].pauseTime = startTime + (elapsed % loopDuration); 
            
            playTrack(deckNum);
            
            // Remove highlight
            document.querySelectorAll(`#loopPads${deckNum} .loop-pad`).forEach(pad => pad.classList.remove('active'));
        }
    }

    // Toggle superimpose
    function toggleSuperimpose(deckNum) {
        showDeck[deckNum] = !showDeck[deckNum];
    }

    // Animate all canvas elements
    function animate() {
        drawSuperimposedWaveform();
        requestAnimationFrame(animate);
    }

    // draw superimposed waveform for both decks
    function drawSuperimposedWaveform() {
        const width = superCanvas.width;
        const height = superCanvas.height;
        superCtx.clearRect(0, 0, width, height);

        // Calculate playhead position
        const playheadX = width / 2;
        
        // Draw both deck waveforms
        if (showDeck[1] && decks[1].isLoaded && decks[1].waveformData) {
            drawDeckWaveformSegment(1, width, height, playheadX);
        }
        if (showDeck[2] && decks[2].isLoaded && decks[2].waveformData) {
            drawDeckWaveformSegment(2, width, height, playheadX);
        }
        
        // Draw playhead indicator
        const indicator = document.querySelector('.top-waveform-indicator');
        if (indicator) {
            indicator.style.left = `${playheadX}px`;
        }
    }

    // Draw a segment of the waveform around the playhead
    function drawDeckWaveformSegment(deckNum, width, height, playheadX) {
        const deck = decks[deckNum];
        const audioBuffer = deck.audioBuffer;
        const duration = audioBuffer.duration;
        const currentTime = deck.isPlaying ? (audioContext.currentTime - deck.startTime) : deck.pauseTime;
        
        // The center of the visible waveform (playheadX) corresponds to the currentTime
        // Total samples and total pixels in the full waveform
        const totalSamples = audioBuffer.length;
        const totalPixels = width; // Assuming 1:1 pixel/sample ratio for simplicity in this view
        
        // Calculate the starting sample index for the visible segment
        const samplesPerSecond = audioBuffer.sampleRate;
        // Number of samples to the left of the playhead (half the screen width)
        const samplesBeforePlayhead = Math.floor(totalSamples * (playheadX / totalPixels));
        
        // Current sample index
        const currentSampleIndex = Math.floor(currentTime * samplesPerSecond);
        
        // Start sample index for drawing the visible segment
        let startSample = currentSampleIndex - samplesBeforePlayhead;
        let endSample = currentSampleIndex + (totalSamples - samplesBeforePlayhead); // End of track
        
        // Ensure startSample is not negative (clamp to 0)
        startSample = Math.max(0, startSample);
        
        const samplesPerPixel = (endSample - startSample) / width;
        const channelData = audioBuffer.getChannelData(0);
        
        // Choose color based on deck and style
        let color;
        const style = currentWaveformStyle;
        
        switch (style) {
            case 'blue-orange': color = deckNum === 1 ? '#0080FF' : '#FF8C00'; break;
            case 'rainbow': 
                // Calculate color based on time (simple hue rotation)
                const hue = (currentTime / duration * 60) % 360;
                color = `hsl(${hue}, 100%, 60%)`;
                break;
            case 'mono': color = deckNum === 1 ? '#CCCCCC' : '#888888'; break;
            case 'gradient': 
                const gradient = superCtx.createLinearGradient(0, 0, width, 0);
                gradient.addColorStop(0, deckNum === 1 ? '#00FF00' : '#FF0000');
                gradient.addColorStop(1, deckNum === 1 ? '#0000FF' : '#FF00FF');
                color = gradient;
                break;
            case 'bars': 
                drawBarsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData); 
                return;
            case 'dots': 
                drawDotsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData); 
                return;
            case 'outline': 
                drawOutlineWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData); 
                return;
            default: // 'default'
                color = deckNum === 1 ? '#00FF00' : '#FF0000';
        }

        superCtx.strokeStyle = color;
        superCtx.lineWidth = 2;
        superCtx.beginPath();

        // Calculate visible pixel range
        const visiblePixelStart = 0;
        const visiblePixelEnd = width;
        
        for (let i = visiblePixelStart; i < visiblePixelEnd; i++) {
            // Find the sample index that corresponds to this pixel's position relative to the playhead
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            
            if (sampleIndex >= totalSamples) break;

            let min = 0;
            let max = 0;
            // Get min and max for the group of samples for this pixel
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < totalSamples) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            
            // Draw
            if (i === visiblePixelStart) {
                superCtx.moveTo(i, height / 2 - min * height / 2);
            } else {
                superCtx.lineTo(i, height / 2 - min * height / 2);
            }
            superCtx.lineTo(i, height / 2 - max * height / 2);
        }
        superCtx.stroke();
    }
    
    // Draw bars style waveform for superimposed view
    function drawBarsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData) {
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        const samplesPerPixel = (endSample - startSample) / width;
        superCtx.fillStyle = color;
        for (let i = 0; i < width; i += 3) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;
            let min = 0;
            let max = 0;
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            const barHeight = Math.abs(max - min) * height / 2;
            const barY = height / 2 - max * height / 2;
            superCtx.fillRect(i, barY, 2, barHeight);
        }
    }
    
    // draw dots style waveform for superimposed view
    function drawDotsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData) {
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        const samplesPerPixel = (endSample - startSample) / width;
        superCtx.fillStyle = color;
        for (let i = 0; i < width; i += 3) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;
            let min = 0;
            let max = 0;
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            superCtx.beginPath();
            superCtx.arc(i, height / 2 - min * height / 2, 1.5, 0, Math.PI * 2);
            superCtx.fill();
            superCtx.beginPath();
            superCtx.arc(i, height / 2 - max * height / 2, 1.5, 0, Math.PI * 2);
            superCtx.fill();
        }
    }

    // draw outline style waveform for superimposed view
    function drawOutlineWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData) {
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        const samplesPerPixel = (endSample - startSample) / width;
        superCtx.strokeStyle = color;
        superCtx.lineWidth = 1;
        
        // draw upper outline
        superCtx.beginPath();
        for (let i = 0; i < width; i++) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;
            let max = 0;
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value > max) max = value;
                }
            }
            if (i === 0) {
                superCtx.moveTo(i, height / 2 - max * height / 2);
            } else {
                superCtx.lineTo(i, height / 2 - max * height / 2);
            }
        }
        superCtx.stroke();
        
        // draw lower outline
        superCtx.beginPath();
        for (let i = 0; i < width; i++) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;
            let min = 0;
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                }
            }
            if (i === 0) {
                superCtx.moveTo(i, height / 2 - min * height / 2);
            } else {
                superCtx.lineTo(i, height / 2 - min * height / 2);
            }
        }
        superCtx.stroke();
    }

    // Set up MIDI
    function setupMIDI() {
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(
                (midiAccess) => {
                    console.log('MIDI access granted', midiAccess);
                    // List available MIDI inputs
                    const inputs = midiAccess.inputs.values();
                    const inputSelector = document.getElementById('midiInputSelector');
                    for (let input = inputs.next(); input && !input.done; input = inputs.next()) {
                        const option = document.createElement('option');
                        option.value = input.value.id;
                        option.textContent = input.value.name;
                        inputSelector.appendChild(option);
                        // Add event listener
                        input.value.onmidimessage = handleMIDIMessage;
                    }
                },
                (error) => {
                    console.error('MIDI access denied', error);
                }
            );
        }
    }

    // Handle MIDI message
    function handleMIDIMessage(message) {
        // This is a placeholder for MIDI mapping
        // In a real application, you would map MIDI controls to deck functions
        console.log('MIDI message received', message.data);
    }

    // Toggle equalizer popup
    function toggleEqualizerPopup() {
        const popup = document.getElementById('equalizer-popup');
        popup.style.display = popup.style.display === 'flex' ? 'none' : 'flex';
    }

    // Toggle settings popup
    function toggleSettingsPopup() {
        const popup = document.getElementById('settingsPopup');
        popup.style.display = popup.style.display === 'flex' ? 'none' : 'flex';
    }

    // Apply settings
    function applySettings() {
        currentWaveformStyle = document.getElementById('waveformStyleSelector').value;
        const mapping = document.getElementById('midiMappingSelector').value;
        activeRecordingSource = document.getElementById('recordingSourceSelector').value;
        
        // Apply MIDI mapping (placeholder)
        console.log('Applying MIDI mapping:', mapping);
        
        // Close popup
        toggleSettingsPopup();
    }

    // Update crossfader gain values (NEW FUNCTION)
    function updateCrossfader(e) {
        const value = parseFloat(e.target.value); // 0 (left) to 1 (right)
        // Implement an Equal Power Curve for smooth crossfading
        const gain1 = Math.cos(value * 0.5 * Math.PI);
        const gain2 = Math.cos((1.0 - value) * 0.5 * Math.PI);
        
        // Apply to the new crossfader nodes
        decks[1].crossfaderNode.gain.value = gain1;
        decks[2].crossfaderNode.gain.value = gain2;
    }

    // Update Effect Routing (NEW FUNCTION)
    function updateEffectRouting(deckNum) {
        const deck = decks[deckNum];
        
        // 1. Disconnect everything from the effects bus
        deck.effectsBus.disconnect();
        // Disconnect effect nodes from their output point (crossfader)
        if (deck.cutEffect) deck.cutEffect.disconnect();
        if (deck.flangerEffect) deck.flangerEffect.disconnect();

        // 2. Build the chain based on active effects
        let currentNode = deck.effectsBus;
        
        if (deck.effects.cut) {
            currentNode.connect(deck.cutEffect);
            currentNode = deck.cutEffect;
        }
        
        if (deck.effects.flanger) {
            // Flanger: split the signal (dry signal from current node, wet signal from flanger)
            
            // Wet signal path (re-connect flanger feedback loop)
            deck.flangerEffect.connect(deck.flangerFeedback);
            deck.flangerFeedback.connect(deck.flangerEffect); 

            // Connect dry signal: currentNode -> Crossfader Node
            currentNode.connect(deck.crossfaderNode);
            
            // Connect wet signal: Flanger Effect (wet) -> Crossfader Node
            deck.flangerEffect.connect(deck.crossfaderNode);

        } else {
            // Final connection (if no flanger, or if flanger is implemented as an insert, which is simpler here)
            // If flanger is implemented as a send/return, this needs to change. Sticking to simple insert here.
            
            // Simple insert logic:
            currentNode.connect(deck.crossfaderNode);
        }
        
        if (deck.effects.flanger) {
            // Simple flanger insertion (overwrite previous cut connection if both are active)
            // This needs a mixer, but for simplicity, we'll implement a simple flanger effect that only applies the delay.
            // A true flanger is complex. For a simple demonstration:
            
            // Connect current node to the flanger input
            currentNode.connect(deck.flangerEffect);
            
            // Connect flanger output to the crossfader
            deck.flangerEffect.connect(deck.crossfaderNode);
            
            // Flanger LFO control (start it if it wasn't)
            if (!deck.flangerLFO) {
                deck.flangerLFO = audioContext.createOscillator();
                deck.flangerLFO.frequency.value = 0.5; // 0.5 Hz
                deck.flangerLFO.start(0);
                
                const flangerGain = audioContext.createGain();
                flangerGain.gain.value = 0.002; // Modulation depth
                
                deck.flangerLFO.connect(flangerGain);
                flangerGain.connect(deck.flangerEffect.delayTime);
            }

        }
    }

    // Toggle effect
    function toggleEffect(deckNum, effectName) {
        const deck = decks[deckNum];
        
        // Placeholder values for effects (Actual values must be set here)
        if (deck.cutEffect === null) {
            // Initialize effect nodes on demand
            deck.cutEffect = audioContext.createBiquadFilter();
            deck.cutEffect.type = 'lowpass';
            deck.cutEffect.frequency.value = 22050; 
            deck.cutEffect.Q.value = 0.01;
            
            deck.flangerEffect = audioContext.createDelay(0.02);
            deck.flangerFeedback = audioContext.createGain();
            deck.flangerFeedback.gain.value = 0.5;
            
            // Flanger LFO
            deck.flangerLFO = audioContext.createOscillator();
            deck.flangerLFO.frequency.value = 0.5; 
            deck.flangerLFO.start(0);
            
            const flangerGain = audioContext.createGain();
            flangerGain.gain.value = 0.002;
            
            deck.flangerLFO.connect(flangerGain);
            flangerGain.connect(deck.flangerEffect.delayTime);
        }
        
        deck.effects[effectName] = !deck.effects[effectName];
        
        const buttonId = `effect${deckNum}-${effectName}`;
        document.getElementById(buttonId).classList.toggle('active', deck.effects[effectName]);
        
        if (effectName === 'cut') {
            if (deck.effects.cut) {
                // Set cut effect to an audible setting
                deck.cutEffect.frequency.value = 500; // Lowpass cut
            } else {
                // Reset to bypass
                deck.cutEffect.frequency.value = 22050; // Full range
            }
        }
        
        if (effectName === 'flanger') {
            if (deck.effects.flanger) {
                // Connect flanger feedback
                deck.flangerEffect.connect(deck.flangerFeedback);
            } else {
                // Disconnect flanger feedback
                deck.flangerEffect.disconnect();
                deck.flangerFeedback.disconnect();
            }
        }
        
        // Re-route the entire effects bus to ensure correct connection
        updateEffectRouting(deckNum);
    }
    
    // Handle file selection
    async function handleFileSelect(event, deckNum) {
        const file = event.target.files[0];
        if (!file) return;
        
        // Reset effects state
        decks[deckNum].effects = { cut: false, flanger: false };
        
        try {
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Store audio buffer
            decks[deckNum].audioBuffer = audioBuffer;
            decks[deckNum].isLoaded = true;
            
            // Create Effect Nodes (if not created already)
            if (decks[deckNum].cutEffect === null) {
                decks[deckNum].effectsBus = audioContext.createGain();
                decks[deckNum].cutEffect = audioContext.createBiquadFilter();
                decks[deckNum].cutEffect.type = 'lowpass';
                decks[deckNum].cutEffect.frequency.value = 22050;
                decks[deckNum].cutEffect.Q.value = 0.01;
            
                decks[deckNum].flangerEffect = audioContext.createDelay(0.02);
                decks[deckNum].flangerFeedback = audioContext.createGain();
                decks[deckNum].flangerFeedback.gain.value = 0.5;
            
                // Flanger LFO setup
                decks[deckNum].flangerLFO = audioContext.createOscillator();
                decks[deckNum].flangerLFO.frequency.value = 0.5;
                decks[deckNum].flangerLFO.start(0);
                
                const flangerGain = audioContext.createGain();
                flangerGain.gain.value = 0.002;
                
                decks[deckNum].flangerLFO.connect(flangerGain);
                flangerGain.connect(decks[deckNum].flangerEffect.delayTime);
                
                // Disconnect all to ensure a clean start
                decks[deckNum].flangerEffect.disconnect();
                decks[deckNum].flangerFeedback.disconnect();
                decks[deckNum].flangerLFO.disconnect();
            }
            
            // Preprocess waveform data for the top visualizer
            preprocessWaveformData(deckNum, audioBuffer);
            
            // Create reversed buffer
            createReversedBuffer(deckNum, audioBuffer);
            
            // Create analyser
            decks[deckNum].analyser = audioContext.createAnalyser();
            decks[deckNum].analyser.fftSize = 2048;
            
            // Set up audio routing (connects to Master Bus)
            setupAudioRouting(deckNum); 
            
            // Draw waveform
            drawFullWaveform(deckNum);
            
            // Update duration display
            const duration = formatTime(audioBuffer.duration);
            document.getElementById(`duration${deckNum}`).textContent = duration;
            
            // Detect BPM
            detectBPM(deckNum, audioBuffer);
        } catch (error) {
            console.error('Error loading audio file:', error);
        }
    }

    // Preprocess waveform data for the top visualizer
    function preprocessWaveformData(deckNum, audioBuffer) {
        const channelData = audioBuffer.getChannelData(0);
        const samplesPerPixel = Math.floor(channelData.length / superCanvas.width);
        decks[deckNum].waveformData = [];
        for (let i = 0; i < superCanvas.width; i++) {
            let min = 0;
            let max = 0;
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = i * samplesPerPixel + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            decks[deckNum].waveformData.push({ min, max });
        }
    }

    // Create reversed audio buffer
    function createReversedBuffer(deckNum, audioBuffer) {
        const reversedBuffer = audioContext.createBuffer(
            audioBuffer.numberOfChannels,
            audioBuffer.length,
            audioBuffer.sampleRate
        );
        for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
            const channel = audioBuffer.getChannelData(i);
            const reversedChannel = reversedBuffer.getChannelData(i);
            for (let j = 0; j < channel.length; j++) {
                reversedChannel[j] = channel[channel.length - 1 - j];
            }
        }
        decks[deckNum].reversedBuffer = reversedBuffer;
    }
    
    // Initialize when page loads
    function init() {
        // Set up master bus connections (NEW)
        masterGainNode.connect(analyserMaster); // Master Bus -> Analyser/Recorder Input
        decks[1].crossfaderNode.connect(masterGainNode); // Deck 1 -> Master Bus
        decks[2].crossfaderNode.connect(masterGainNode); // Deck 2 -> Master Bus

        // Initialize 30-band EQ (connects AnalyserMaster to audioContext.destination and recordingDestination)
        init30BandEQ();
        
        // Load vinyl sounds
        loadVinylSounds();

        // Set up file inputs
        document.getElementById('fileInput1').addEventListener('change', (e) => handleFileSelect(e, 1));
        document.getElementById('fileInput2').addEventListener('change', (e) => handleFileSelect(e, 2));

        // Set up controls
        setupControls();

        // Set up canvas dimensions
        setupCanvasDimensions();

        // Set up MIDI
        setupMIDI();

        // Set up recording (must be called after init30BandEQ to connect the destination)
        setupRecording(); 
        
        // Start animation
        animate(); 
    }

    // Set up controls
    function setupControls() {
        // Volume controls
        document.getElementById('volume1').addEventListener('input', (e) => {
            decks[1].gainNode.gain.value = parseFloat(e.target.value);
        });
        document.getElementById('volume2').addEventListener('input', (e) => {
            decks[2].gainNode.gain.value = parseFloat(e.target.value);
        });

        // EQ controls
        ['bass', 'mid', 'treble'].forEach((band) => {
            for (let i = 1; i <= 2; i++) {
                document.getElementById(`${band}${i}`).addEventListener('input', (e) => {
                    decks[i].eq[band].gain.value = parseFloat(e.target.value);
                    decks[i].eqValue[band] = parseFloat(e.target.value); // Store for Kill/Restore
                    decks[i].eqState[band] = true;
                });
            }
        });

        // Gain (pre-fader) controls
        for (let i = 1; i <= 2; i++) {
            document.getElementById(`gain${i}`).addEventListener('input', (e) => {
                decks[i].source.gain.value = parseFloat(e.target.value);
            });
        }
        
        // Filter controls
        for (let i = 1; i <= 2; i++) {
            document.getElementById(`filter${i}`).addEventListener('input', (e) => {
                decks[i].filterNode.frequency.value = parseFloat(e.target.value);
            });
            decks[i].filterNode.type = 'lowpass'; // Set to lowpass for filter control
        }

        // Pitch controls
        document.getElementById('pitch1').addEventListener('input', (e) => {
            if (decks[1].source) {
                decks[1].source.playbackRate.value = parseFloat(e.target.value);
            }
        });
        document.getElementById('pitch2').addEventListener('input', (e) => {
            if (decks[2].source) {
                decks[2].source.playbackRate.value = parseFloat(e.target.value);
            }
        });

        // Crossfader control (NEW)
        document.getElementById('crossfader').addEventListener('input', updateCrossfader);
        // Initial call to set gain values
        updateCrossfader({ target: { value: document.getElementById('crossfader').value } });

        // Progress bar controls
        document.getElementById('progressBar1').addEventListener('input', (e) => { seekTrack(1, parseFloat(e.target.value)); });
        document.getElementById('progressBar2').addEventListener('input', (e) => { seekTrack(2, parseFloat(e.target.value)); });
    }

    // Set up canvas dimensions
    function setupCanvasDimensions() {
        const canvases = [
            document.getElementById('superimposedWaveformCanvas'),
            document.getElementById('waveformCanvas1'),
            document.getElementById('waveformCanvas2')
        ];
        canvases.forEach(canvas => {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        });
    }

    // Toggle equalizer popup (already exists)
    // Toggle settings popup (already exists)
    // Apply settings (already exists)
    // handleMIDIMessage (already exists)

    let lastWavBlob = null; // Store the last recorded blob

    // Set up recording
    async function setupRecording() {
        try {
            // Create or reuse a MediaStreamDestination to capture the master output
            if (!window.recordingDestination) {
                window.recordingDestination = audioContext.createMediaStreamDestination();
            }
            
            // The connection to the recording destination is now handled in init30BandEQ, 
            // where the output of the global EQ is connected to both audioContext.destination AND window.recordingDestination.
            
            document.getElementById('recordingSourceSelector').addEventListener('change', (e) => { 
                activeRecordingSource = e.target.value; 
            });
            console.log("Recording setup complete.");
        } catch (err) {
            console.error("setupRecording error:", err);
        }
    }

    // Utility: encode AudioBuffer to WAV (16-bit PCM)
    function encodeWAV(audioBuffer) {
        const numChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const format = 1; // PCM
        const bitsPerSample = 16;
        
        // interleave
        let samples;
        if (numChannels === 2) {
            const left = audioBuffer.getChannelData(0);
            const right = audioBuffer.getChannelData(1);
            samples = new Int16Array(left.length + right.length);
            let offset = 0;
            for (let i = 0; i < left.length; i++) {
                // Convert floating point to 16-bit PCM
                samples[offset++] = left[i] * 0x7FFF;
                samples[offset++] = right[i] * 0x7FFF;
            }
        } else { // Mono or > 2 channels (will only use first channel for mono)
            const mono = audioBuffer.getChannelData(0);
            samples = new Int16Array(mono.length);
            for (let i = 0; i < mono.length; i++) {
                samples[i] = mono[i] * 0x7FFF;
            }
        }
        
        const dataSize = samples.byteLength;
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);
        
        /* RIFF identifier */ writeString(view, 0, 'RIFF');
        /* file length */ view.setUint32(4, 36 + dataSize, true);
        /* RIFF type */ writeString(view, 8, 'WAVE');
        /* format chunk identifier */ writeString(view, 12, 'fmt ');
        /* format chunk length */ view.setUint32(16, 16, true);
        /* sample format (1 = PCM) */ view.setUint16(20, format, true);
        /* channel count */ view.setUint16(22, numChannels, true);
        /* sample rate */ view.setUint32(24, sampleRate, true);
        /* byte rate (sample rate * block align) */ view.setUint32(28, sampleRate * numChannels * (bitsPerSample / 8), true);
        /* block align (channel count * bytes per sample) */ view.setUint16(32, numChannels * (bitsPerSample / 8), true);
        /* bits per sample */ view.setUint16(34, bitsPerSample, true);
        /* data chunk identifier */ writeString(view, 36, 'data');
        /* data chunk length */ view.setUint32(40, dataSize, true);
        
        // write the PCM samples
        let offset = 44;
        for (let i = 0; i < samples.length; i++, offset += 2) {
            view.setInt16(offset, samples[i], true);
        }
        
        return new Blob([view], { type: 'audio/wav' });
        
        function writeString(dataview, offset, string) {
            for (let i = 0; i < string.length; i++) {
                dataview.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    }

    // Convert arbitrary audio Blob (like webm/opus) to WAV by decoding and re-encoding
    async function convertBlobToWav(blob) {
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        // If channel count >2, downmix to stereo (simple summation)
        if (audioBuffer.numberOfChannels > 2) {
            // create stereo buffer
            const offlineContext = new OfflineAudioContext(2, audioBuffer.length, audioBuffer.sampleRate);
            const source = offlineContext.createBufferSource();
            source.buffer = audioBuffer;
            
            // Use a ChannelMerger to downmix
            const merger = offlineContext.createChannelMerger(2);
            source.connect(merger, 0, 0);
            source.connect(merger, 0, 1);
            
            source.start(0);
            const downmixedBuffer = await offlineContext.startRendering();
            return encodeWAV(downmixedBuffer);
        }
        
        return encodeWAV(audioBuffer);
    }
    
    // Toggle recording
    async function toggleRecording() {
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        
        try {
            if (!isRecording) {
                // Start recording
                
                let streamToRecord;
                
                if (activeRecordingSource === 'mic') {
                    // Start Mic Stream
                    window._micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    streamToRecord = window._micStream;
                } else {
                    // Master Output
                    if (!window.recordingDestination) {
                        await setupRecording();
                    }
                    streamToRecord = window.recordingDestination.stream;
                }
                
                if (!streamToRecord) {
                    throw new Error("No stream available for recording.");
                }

                recordedChunks = [];
                mediaRecorder = new MediaRecorder(streamToRecord, { mimeType: 'audio/webm' });

                mediaRecorder.ondataavailable = (ev) => {
                    if (ev.data && ev.data.size > 0) recordedChunks.push(ev.data);
                };

                mediaRecorder.onstop = async () => {
                    try {
                        const blob = new Blob(recordedChunks, { type: recordedChunks[0].type || 'audio/webm' });
                        // Convert to WAV
                        const wavBlob = await convertBlobToWav(blob);
                        lastWavBlob = wavBlob;
                        
                        // Show save button
                        document.getElementById('saveButton').style.display = 'inline-block';
                        
                        // Create automatic download link (temporary)
                        const url = URL.createObjectURL(wavBlob);
                        const a = document.createElement('a');
                        a.style.display = 'none';
                        a.href = url;
                        a.download = 'rtbs_recording_' + new Date().toISOString().replace(/[:.]/g,'-') + '.wav';
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        URL.revokeObjectURL(url);

                    } catch(e) {
                        console.error("Error on mediaRecorder stop/convert:", e);
                        alert('Error al procesar la grabación. Mira la consola.');
                    }
                };

                mediaRecorder.start();
                isRecording = true;
                document.getElementById('recordButton').textContent = 'Detener';
                document.getElementById('recordButton').style.background = '#AA0000';
                console.log('Recording started.');
            } else {
                // Stop recording
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
                // stop mic stream if used
                if (window._micStream) {
                    window._micStream.getTracks().forEach(t => t.stop());
                    window._micStream = null;
                }
                isRecording = false;
                document.getElementById('recordButton').textContent = 'Grabar';
                document.getElementById('recordButton').style.background = '';
                console.log('Recording stopped.');
            }
        } catch (err) {
            console.error('toggleRecording error:', err);
            alert('Error al iniciar/detener la grabación. Mira la consola.');
        }
    }

    // Save last WAV to disk (if exists)
    function saveRecording() {
        if (!lastWavBlob) {
            alert('No hay grabación para guardar.');
            return;
        }
        const url = URL.createObjectURL(lastWavBlob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = 'rtbs_recording_' + new Date().toISOString().replace(/[:.]/g,'-') + '.wav';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }

    window.addEventListener('load', init);
    window.addEventListener('resize', setupCanvasDimensions);
                </script>
</body>
</html>
