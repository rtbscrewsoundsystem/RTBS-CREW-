<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>RTBS CREW - V12.0 FINAL REPAIR</title>
    <style>
        :root { --p: #00ff41; --s: #0080ff; --bg: #c0c0c0; --win: #000080; }
        body { background: #000; color: var(--p); font-family: 'Courier New', monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; }
        .monitor { border: 4px solid var(--bg); background: var(--bg); padding: 2px; box-shadow: 10px 10px 0 #000; width: 90vw; max-width: 800px; }
        .screen { background: #000; height: 600px; display: flex; flex-direction: column; position: relative; border: 2px solid #000; }
        header { background: linear-gradient(90deg, var(--win), #0080ff); color: #fff; padding: 4px; font-size: 11px; display: flex; justify-content: space-between; font-weight: bold; }
        canvas { width: 100%; flex-grow: 1; cursor: crosshair; }
        
        /* Línea de Tiempo */
        .timeline-container { background: #000; padding: 10px; border-top: 1px solid var(--p); display: flex; align-items: center; gap: 10px; }
        #timeline { flex: 1; cursor: pointer; accent-color: var(--p); }

        .popup { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; background: var(--bg); border: 3px solid #fff; padding: 15px; z-index: 100; display: none; color: #000; box-shadow: 0 0 40px #000; }
        .eq-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin: 10px 0; }
        .v-slider { appearance: slider-vertical; width: 100%; height: 80px; background: #000; }
        
        .controls { background: var(--bg); padding: 10px; display: flex; gap: 8px; border-top: 2px solid #404040; }
        button { font-family: 'Courier New'; font-weight: bold; font-size: 10px; padding: 6px; cursor: pointer; background: var(--bg); border: 2px solid; border-color: #fff #404040 #404040 #fff; }
        button:active { border-color: #404040 #fff #fff #404040; }
        .modes-list { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; max-height: 300px; overflow-y: auto; }
    </style>
</head>
<body>

<div class="monitor">
    <div class="screen">
        <header><span>RTBS_SYSTEM_V12.0_STABLE</span><span id="cur-mode-txt">MODE: BARS</span></header>
        <canvas id="v"></canvas>

        <div class="timeline-container">
            <span id="time-curr" style="font-size:10px">0:00</span>
            <input type="range" id="timeline" value="0" min="0" step="0.1">
            <span id="time-total" style="font-size:10px">0:00</span>
        </div>

        <div id="pop-settings" class="popup">
            <b style="font-size:12px">COLOR CONFIG</b>
            <div style="margin: 10px 0; display: flex; gap: 20px;">
                C1: <input type="color" id="c1" value="#00ff41">
                C2: <input type="color" id="c2" value="#0080ff">
            </div>
            <b style="font-size:12px">20-BAND EQUALIZER</b>
            <div class="eq-grid" id="eq-1"></div>
            <div class="eq-grid" id="eq-2"></div>
            <div style="display: flex; gap: 5px;">
                <button onclick="resetEQ()" style="flex:1; background:#ffeb3b">RESET EQ (0dB)</button>
                <button onclick="togglePop('pop-settings')" style="flex:1; background:#f44336; color:#fff">CLOSE</button>
            </div>
        </div>

        <div id="pop-modes" class="popup">
            <b style="font-size:12px">SELECT VISUALIZER</b>
            <div class="modes-list" id="modes-grid"></div>
            <button onclick="togglePop('pop-modes')" style="width:100%; margin-top:10px;">CERRAR</button>
        </div>

        <div class="controls">
            <input type="file" id="file" accept="audio/*" style="font-size:9px; flex:1">
            <button id="btn-play" style="background:var(--p)">POWER/PLAY</button>
            <button onclick="togglePop('pop-settings')" style="background:#ffcc00">EQ/COLOR</button>
            <button onclick="togglePop('pop-modes')" style="background:var(--s); color:#fff">MODES</button>
            <button onclick="resetEQ()" style="background:#ff9800">RESET EQ</button>
        </div>
    </div>
</div>

<script>
    const audio = new Audio();
    const canvas = document.getElementById('v'), ctx = canvas.getContext('2d');
    const timeline = document.getElementById('timeline');
    let audioCtx, analyser, dataArray, filters = [], initialized = false;
    let mode = 'bars', colorA = "#00ff41", colorB = "#0080ff", rot = 0;
const modes = [
  'bars', 'rave', 'dna', 'tunnel', 'matrix', 'vortex', 'radial', 'laser', 'wave', 
  'hex', 'stars', 'rings', 'dots', 'flower', 'glitch', 'cyber', 'nebula', 
  'oscilloscope', 'spectrum', 'grid', 'pulse', 'orbit', 'chaos', 'psycho_sphere', 
  'liquid_dream', 'fractal_tree', 'chrome_whirl', 'ghost_pulse',
  // Nuevos modos
  'quantum_lines', 'echo_ribbons', 'void_spiral', 'neon_cage', 'plasma_cells',
  'sound_mandala', 'bit_crusher', 'holo_wave', 'spectral_rain', 'audio_constellation',
  'energy_core', 'mirror_bass', 'time_fracture', 'digital_smoke', 'pulse_grid',
  'frequency_blades', 'audio_tentacles', 'broken_signal', 'sonic_orbitals',
  'liquid_mirror', 'vector_storm', 'bass_blackhole', 'neural_pulse', 'data_flow',
  'audio_fabric', 'spectral_sun', 'cyber_fog', 'harmonic_shell', 'bass_inferno',
  'echo_particles', 'time_rings', 'audio_prism', 'glow_maze', 'cosmic_noise'
];
    // UI: Botones de modos
    const mGrid = document.getElementById('modes-grid');
    modes.forEach(m => {
        const b = document.createElement('button'); b.innerText = m.toUpperCase();
        b.onclick = () => { mode = m; document.getElementById('cur-mode-txt').innerText = "MODE: "+m.toUpperCase(); togglePop('pop-modes'); };
        mGrid.appendChild(b);
    });

    // EQ: 20 Bandas
    const fVals = [32, 64, 125, 250, 500, 750, 1000, 1500, 2000, 2500, 3000, 4000, 5000, 6000, 8000, 10000, 12000, 14000, 16000, 18000];
    fVals.forEach((f, i) => {
        const target = i < 10 ? 'eq-1' : 'eq-2';
        const d = document.createElement('div');
        d.innerHTML = `<input type="range" class="v-slider" id="f-${i}" min="-20" max="20" value="0" oninput="changeF(${i}, this.value)"><div style="font-size:6px;text-align:center">${f<1000?f:f/1000+'k'}</div>`;
        document.getElementById(target).appendChild(d);
    });

    function togglePop(id) { const p = document.getElementById(id); p.style.display = p.style.display === 'block' ? 'none' : 'block'; }
    function changeF(i, v) { if(filters[i]) filters[i].gain.value = v; }
    function resetEQ() { filters.forEach((f, i) => { f.gain.value = 0; document.getElementById(`f-${i}`).value = 0; }); }

    // Colores
    document.getElementById('c1').oninput = (e) => colorA = e.target.value;
    document.getElementById('c2').oninput = (e) => colorB = e.target.value;

    // Audio & Timeline
    document.getElementById('file').onchange = (e) => audio.src = URL.createObjectURL(e.target.files[0]);
    
    // FUNCIONALIDAD DE LA LÍNEA DE TIEMPO MEJORADA
    audio.onloadedmetadata = () => { 
        timeline.max = audio.duration; 
        document.getElementById('time-total').innerText = formatT(audio.duration); 
    };
    audio.ontimeupdate = () => { 
        if(!dragging) { 
            timeline.value = audio.currentTime; 
            document.getElementById('time-curr').innerText = formatT(audio.currentTime); 
        } 
    };
    
    let dragging = false;
    
    timeline.oninput = () => {
        dragging = true;
        document.getElementById('time-curr').innerText = formatT(timeline.value);
    };
    
    timeline.onchange = () => {
        audio.currentTime = timeline.value;
        dragging = false;
    };
    
    timeline.onmousedown = () => dragging = true;
    timeline.onmouseup = () => {
        audio.currentTime = timeline.value;
        dragging = false;
    };
    
    // También permitir clic en cualquier punto de la línea
    timeline.addEventListener('click', (e) => {
        if (!dragging) {
            const rect = timeline.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            audio.currentTime = percent * audio.duration;
            timeline.value = audio.currentTime;
        }
    });
    
    function formatT(s) { 
        let m = Math.floor(s/60); 
        s = Math.floor(s%60); 
        return m + ":" + (s<10?'0':'')+s; 
    }

    document.getElementById('btn-play').onclick = () => {
        if (!initialized) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let src = audioCtx.createMediaElementSource(audio);
            let prev = src;
            fVals.forEach((f, i) => {
                const flt = audioCtx.createBiquadFilter(); flt.type = "peaking"; flt.frequency.value = f;
                filters.push(flt); prev.connect(flt); prev = flt;
            });
            analyser = audioCtx.createAnalyser(); analyser.fftSize = 1024;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            prev.connect(analyser); analyser.connect(audioCtx.destination);
            initialized = true; loop();
        }
        audio.paused ? audio.play() : audio.pause();
    };

    function loop() {
        requestAnimationFrame(loop);
        const trail = ['psycho_sphere', 'liquid_dream', 'rave', 'vortex', 'chrome_whirl'].includes(mode) ? 0.15 : 0.8;
        ctx.fillStyle = `rgba(0,0,0,${trail})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const isT = ['wave', 'oscilloscope', 'chaos', 'pulse', 'glitch'].includes(mode);
        isT ? analyser.getByteTimeDomainData(dataArray) : analyser.getByteFrequencyData(dataArray);

        const cx = canvas.width/2, cy = canvas.height/2; rot += 0.02;

        ctx.lineWidth = 2; ctx.strokeStyle = colorA; ctx.fillStyle = colorA;

        switch(mode) {
            case 'bars':
                for(let i=0; i<80; i++){ ctx.fillStyle = i%2?colorA:colorB; let h = (dataArray[i]/255)*canvas.height; ctx.fillRect(i*(canvas.width/80), canvas.height-h, (canvas.width/80)-1, h); }
                break;
            case 'wave':
            case 'oscilloscope':
                ctx.beginPath(); for(let i=0; i<dataArray.length; i++){ let x = (i/dataArray.length)*canvas.width, y = (dataArray[i]/255)*canvas.height; i===0?ctx.moveTo(x,y):ctx.lineTo(x,y); } ctx.stroke();
                break;
            case 'rave':
                ctx.save(); ctx.translate(cx,cy); ctx.rotate(rot); for(let i=0; i<dataArray.length; i+=10){ ctx.strokeStyle = i%20?colorA:colorB; ctx.beginPath(); ctx.arc(0,0,dataArray[i]*0.8,0,Math.PI*2); ctx.stroke(); ctx.rotate(0.02); } ctx.restore();
                break;
            case 'psycho_sphere':
                ctx.save(); ctx.translate(cx,cy); ctx.rotate(rot); for(let i=0; i<100; i+=2){ ctx.strokeStyle = i%10===0?"#fff":colorA; ctx.beginPath(); ctx.arc(0,0,dataArray[i]*1.2,0,Math.PI*2); ctx.stroke(); if(i%20===0){ ctx.strokeStyle=colorB; ctx.strokeRect(-dataArray[i],-dataArray[i],dataArray[i]*2,dataArray[i]*2); }} ctx.restore();
                break;
            case 'liquid_dream':
                for(let i=0; i<dataArray.length; i+=10){ ctx.fillStyle = i%20?colorA:colorB; ctx.globalAlpha=0.3; ctx.beginPath(); ctx.arc((i/dataArray.length)*canvas.width, cy+Math.sin(rot+i)*80, dataArray[i]/1.5, 0, Math.PI*2); ctx.fill(); } ctx.globalAlpha=1;
                break;
            case 'matrix':
                ctx.font = "10px monospace"; for(let i=0; i<dataArray.length; i+=15){ ctx.fillStyle = dataArray[i]>150?colorA:colorB; ctx.fillText(Math.floor(Math.random()*9), (i/dataArray.length)*canvas.width, (dataArray[i]/255)*canvas.height); }
                break;
            case 'dna':
                for(let i=0; i<dataArray.length; i+=6){ ctx.fillStyle = i%12?colorA:colorB; let y = cy + Math.sin(i*0.1+rot*4)*(dataArray[i]/2); ctx.fillRect((i/dataArray.length)*canvas.width, y, 4, 4); }
                break;
            case 'fractal_tree':
                ctx.save(); ctx.translate(cx, canvas.height-50); drawTree(120, 0, dataArray[10]/4); ctx.restore();
                break;
            case 'glitch':
                let s = dataArray[10]-128; ctx.drawImage(canvas, s*2, 0); if(Math.abs(s)>30) { ctx.fillStyle = colorA; ctx.fillRect(0, Math.random()*canvas.height, canvas.width, 1); }
                break;
            case 'cyber':
                for(let i=0; i<dataArray.length; i+=20){ ctx.fillStyle = colorA; ctx.fillRect((i/dataArray.length)*canvas.width, cy, 8, -dataArray[i]); ctx.fillRect((i/dataArray.length)*canvas.width, cy, 8, dataArray[i]); }
                break;
            case 'radial':
                ctx.save(); ctx.translate(cx, cy); for(let i=0; i<80; i++){ ctx.rotate((Math.PI*2)/80); ctx.fillStyle = colorA; ctx.fillRect(80, 0, dataArray[i%50]/2, 2); } ctx.restore();
                break;
            case 'stars':
                for(let i=0; i<50; i++){ ctx.fillStyle = "#fff"; ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, dataArray[i]/50, dataArray[i]/50); }
                break;
            case 'chaos':
                ctx.beginPath(); ctx.strokeStyle = colorB; for(let i=0; i<15; i++){ ctx.lineTo(Math.random()*canvas.width, Math.random()*canvas.height); } ctx.stroke();
                break;
            case 'tunnel':
                ctx.save();
                ctx.translate(cx, cy);
                for(let i = 0; i < 50; i++) {
                    ctx.strokeStyle = i % 2 === 0 ? colorA : colorB;
                    ctx.beginPath();
                    ctx.arc(0, 0, 20 + (dataArray[i] * 0.5), 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
                break;
                
            case 'vortex':
                ctx.save();
                ctx.translate(cx, cy);
                for(let i = 0; i < 80; i += 2) {
                    ctx.strokeStyle = i % 4 === 0 ? colorA : colorB;
                    ctx.beginPath();
                    ctx.arc(0, 0, 30 + i * 2, rot + i * 0.1, rot + i * 0.1 + Math.PI/2);
                    ctx.stroke();
                }
                ctx.restore();
                break;
                
            case 'laser':
                for(let i = 0; i < 10; i++) {
                    ctx.strokeStyle = colorA;
                    ctx.beginPath();
                    ctx.moveTo(0, i * 50);
                    ctx.lineTo(dataArray[i * 5] * 2, i * 50);
                    ctx.stroke();
                }
                break;
                
            case 'hex':
                const size = 20;
                for(let y = 0; y < canvas.height; y += size * 1.5) {
                    for(let x = 0; x < canvas.width; x += size * 1.732) {
                        ctx.fillStyle = (x + y) % 2 === 0 ? colorA : colorB;
                        drawHexagon(ctx, x + ((y / size) % 2) * size * 0.866, y, size, dataArray[(x + y) % dataArray.length] / 30);
                    }
                }
                break;
                
            case 'rings':
                ctx.save();
                ctx.translate(cx, cy);
                for(let i = 0; i < 5; i++) {
                    ctx.strokeStyle = i % 2 === 0 ? colorA : colorB;
                    ctx.beginPath();
                    ctx.arc(0, 0, 50 + i * 30 + (dataArray[i * 10] / 5), 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
                break;
                
            case 'dots':
                for(let i = 0; i < 200; i++) {
                    const idx = i % dataArray.length;
                    ctx.fillStyle = idx % 20 === 0 ? colorB : colorA;
                    ctx.beginPath();
                    ctx.arc(
                        (i * 10) % canvas.width, 
                        (Math.floor(i / 20) * 30) % canvas.height, 
                        dataArray[idx] / 40, 
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                break;
                
            case 'flower':
                ctx.save();
                ctx.translate(cx, cy);
                const petals = 8;
                for(let i = 0; i < petals; i++) {
                    ctx.fillStyle = i % 2 === 0 ? colorA : colorB;
                    ctx.save();
                    ctx.rotate((i * Math.PI * 2) / petals + rot);
                    ctx.beginPath();
                    ctx.ellipse(40 + dataArray[i * 5] / 10, 0, 30 + dataArray[i * 5] / 20, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                ctx.restore();
                break;
                
            case 'nebula':
                for(let i = 0; i < 30; i++) {
                    const alpha = dataArray[i * 3] / 255;
                    ctx.fillStyle = `rgba(${parseInt(colorA.slice(1,3), 16)}, ${parseInt(colorA.slice(3,5), 16)}, ${parseInt(colorA.slice(5,7), 16)}, ${alpha * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        10 + dataArray[i * 3] / 20,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
                break;
                
            case 'spectrum':
                const barWidth = canvas.width / 64;
                for(let i = 0; i < 64; i++) {
                    const height = (dataArray[i] / 255) * canvas.height;
                    ctx.fillStyle = `hsl(${i * 5}, 100%, 50%)`;
                    ctx.fillRect(i * barWidth, canvas.height - height, barWidth - 1, height);
                }
                break;
                
            case 'grid':
                const cellSize = 30;
                for(let x = 0; x < canvas.width; x += cellSize) {
                    for(let y = 0; y < canvas.height; y += cellSize) {
                        const idx = ((x + y) * 2) % dataArray.length;
                        ctx.strokeStyle = dataArray[idx] > 128 ? colorA : colorB;
                        ctx.strokeRect(
                            x + (dataArray[idx] / 50),
                            y + (dataArray[(idx + 10) % dataArray.length] / 50),
                            cellSize - 5,
                            cellSize - 5
                        );
                    }
                }
                break;
                
            case 'pulse':
                ctx.save();
                ctx.translate(cx, cy);
                ctx.fillStyle = colorA;
                ctx.beginPath();
                const pulseSize = 100 + (dataArray[10] / 255) * 150;
                ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                break;
                
            case 'orbit':
                ctx.save();
                ctx.translate(cx, cy);
                for(let i = 0; i < 5; i++) {
                    const angle = rot * (i + 1);
                    const radius = 50 + i * 30;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    ctx.fillStyle = i % 2 === 0 ? colorA : colorB;
                    ctx.beginPath();
                    ctx.arc(x, y, 10 + dataArray[i * 10] / 30, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
                break;
                
            case 'chrome_whirl':
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(rot * 2);
                for(let i = 0; i < 60; i += 3) {
                    ctx.strokeStyle = `hsl(${i * 6}, 100%, 50%)`;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(dataArray[i] * 2, 0);
                    ctx.stroke();
                    ctx.rotate(0.1);
                }
                ctx.restore();
                break;
                
            case 'ghost_pulse':
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = colorA;
                ctx.beginPath();
                ctx.arc(cx + Math.sin(rot) * 50, cy + Math.cos(rot) * 50, 80 + dataArray[20] / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.restore();
                break;
            default:
                ctx.fillRect(0, cy, canvas.width, 2);
        }
    }

      // Nuevos modos
  case 'quantum_lines':
    for(let i=0; i<dataArray.length; i+=4) {
      ctx.strokeStyle = i%8 ? colorA : colorB;
      ctx.beginPath();
      ctx.moveTo(0, i*3);
      ctx.lineTo(canvas.width, (dataArray[i]/255)*canvas.height);
      ctx.stroke();
    }
    break;
    
  case 'echo_ribbons':
    for(let i=0; i<50; i++) {
      ctx.strokeStyle = colorA;
      ctx.beginPath();
      ctx.arc(cx, cy, i*8 + Math.sin(rot+i)*dataArray[i], 0, Math.PI*2);
      ctx.stroke();
    }
    break;
    
  case 'void_spiral':
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rot);
    for(let i=0; i<dataArray.length; i+=8) {
      ctx.fillStyle = colorB;
      ctx.fillRect(i, 0, 4, dataArray[i]);
    }
    ctx.restore();
    break;
    
  case 'neon_cage':
    ctx.strokeStyle = colorA;
    for(let x=0; x<canvas.width; x+=40) {
      for(let y=0; y<canvas.height; y+=40) {
        ctx.strokeRect(x, y, 30+dataArray[(x+y)%dataArray.length]/4, 30);
      }
    }
    break;
    
  case 'plasma_cells':
    for(let i=0; i<dataArray.length; i++) {
      ctx.fillStyle = i%2 ? colorA : colorB;
      ctx.beginPath();
      ctx.arc(Math.random()*canvas.width, Math.random()*canvas.height, dataArray[i]/8, 0, Math.PI*2);
      ctx.fill();
    }
    break;
    
  case 'sound_mandala':
    ctx.save();
    ctx.translate(cx, cy);
    for(let i=0; i<dataArray.length; i+=6) {
      ctx.rotate(Math.PI/32);
      ctx.strokeStyle = colorA;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, dataArray[i]);
      ctx.stroke();
    }
    ctx.restore();
    break;
    
  case 'bit_crusher':
    for(let i=0; i<100; i++) {
      let s = dataArray[i]/4;
      ctx.fillStyle = colorB;
      ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, s, s);
    }
    break;
    
  case 'holo_wave':
    ctx.strokeStyle = colorA;
    ctx.beginPath();
    for(let i=0; i<dataArray.length; i++) {
      ctx.lineTo(i/dataArray.length*canvas.width, cy+Math.sin(i*0.1+rot)*dataArray[i]);
    }
    ctx.stroke();
    break;
    
  case 'spectral_rain':
    for(let i=0; i<dataArray.length; i++) {
      ctx.fillStyle = colorA;
      ctx.fillRect(i*6, Math.random()*canvas.height, 4, dataArray[i]);
    }
    break;
    
  case 'audio_constellation':
    for(let i=0; i<dataArray.length; i+=10) {
      for(let j=i+10; j<dataArray.length; j+=10) {
        if(Math.abs(dataArray[i]-dataArray[j]) < 10) {
          ctx.strokeStyle = colorB;
          ctx.beginPath();
          ctx.moveTo(i*4, dataArray[i]);
          ctx.lineTo(j*4, dataArray[j]);
          ctx.stroke();
        }
      }
    }
    break;
    
  case 'energy_core':
    ctx.fillStyle = colorA;
    ctx.beginPath();
    ctx.arc(cx, cy, dataArray[10]*2, 0, Math.PI*2);
    ctx.fill();
    break;
    
  case 'mirror_bass':
    for(let i=0; i<50; i++) {
      let h = dataArray[i]*2;
      ctx.fillStyle = colorB;
      ctx.fillRect(cx-i*6, cy-h/2, 5, h);
      ctx.fillRect(cx+i*6, cy-h/2, 5, h);
    }
    break;
    
  case 'time_fracture':
    if(dataArray[0] > 200) {
      ctx.fillStyle = colorA;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    break;
    
  case 'digital_smoke':
    for(let i=0; i<dataArray.length; i++) {
      ctx.fillStyle = `rgba(0,255,0,0.05)`;
      ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, dataArray[i]/5, dataArray[i]/5);
    }
    break;
    
  case 'pulse_grid':
    for(let x=0; x<canvas.width; x+=50) {
      for(let y=0; y<canvas.height; y+=50) {
        let s = dataArray[(x+y)%dataArray.length]/6;
        ctx.strokeStyle = colorA;
        ctx.strokeRect(x, y, s, s);
      }
    }
    break;
    
  case 'frequency_blades':
    ctx.save();
    ctx.translate(cx, cy);
    for(let i=0; i<dataArray.length; i+=10) {
      ctx.rotate(0.1);
      ctx.fillStyle = colorB;
      ctx.fillRect(0, 0, dataArray[i], 4);
    }
    ctx.restore();
    break;
    
  case 'audio_tentacles':
    ctx.save();
    ctx.translate(cx, cy);
    for(let i=0; i<dataArray.length; i+=8) {
      ctx.strokeStyle = colorA;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(i)*dataArray[i], Math.sin(i)*dataArray[i]);
      ctx.stroke();
    }
    ctx.restore();
    break;
    
  case 'broken_signal':
    ctx.drawImage(canvas, Math.random()*20-10, 0);
    break;
    
  case 'sonic_orbitals':
    ctx.save();
    ctx.translate(cx, cy);
    for(let i=0; i<dataArray.length; i+=12) {
      ctx.fillStyle = colorB;
      ctx.beginPath();
      ctx.arc(Math.cos(i+rot)*dataArray[i], Math.sin(i+rot)*dataArray[i], 4, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
    break;
    
  case 'liquid_mirror':
    ctx.save();
    ctx.scale(1, -1);
    ctx.drawImage(canvas, 0, -canvas.height);
    ctx.restore();
    break;
    
  case 'vector_storm':
    for(let i=0; i<dataArray.length; i++) {
      ctx.strokeStyle = colorA;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx+Math.random()*dataArray[i], cy+Math.random()*dataArray[i]);
      ctx.stroke();
    }
    break;
    
  case 'bass_blackhole':
    ctx.strokeStyle = colorB;
    ctx.beginPath();
    ctx.arc(cx, cy, dataArray[0]*4, 0, Math.PI*2);
    ctx.stroke();
    break;
    
  case 'neural_pulse':
    for(let i=0; i<dataArray.length; i+=5) {
      ctx.fillStyle = colorA;
      ctx.fillRect(i*4, dataArray[i], 3, 3);
    }
    break;
    
  case 'data_flow':
    ctx.font = "10px monospace";
    for(let i=0; i<dataArray.length; i+=8) {
      ctx.fillStyle = colorB;
      ctx.fillText("01", (i/dataArray.length)*canvas.width, dataArray[i]);
    }
    break;
    
  case 'audio_fabric':
    ctx.strokeStyle = colorA;
    for(let i=0; i<dataArray.length; i++) {
      ctx.beginPath();
      ctx.moveTo(i*4, 0);
      ctx.lineTo(i*4, dataArray[i]*2);
      ctx.stroke();
    }
    break;
    
  case 'spectral_sun':
    ctx.save();
    ctx.translate(cx, cy);
    for(let i=0; i<dataArray.length; i++) {
      ctx.strokeStyle = colorA;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(i)*dataArray[i], Math.sin(i)*dataArray[i]);
      ctx.stroke();
    }
    ctx.restore();
    break;
    
  case 'cyber_fog':
    ctx.fillStyle = `rgba(0,255,255,0.03)`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    break;
    
  case 'harmonic_shell':
    for(let i=0; i<dataArray.length; i+=6) {
      ctx.strokeStyle = colorB;
      ctx.beginPath();
      ctx.arc(cx, cy, dataArray[i]*2, 0, Math.PI*2);
      ctx.stroke();
    }
    break;
    
  case 'bass_inferno':
    if(dataArray[0] > 180) {
      ctx.fillStyle = 'red';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    break;
    
  case 'echo_particles':
    for(let i=0; i<dataArray.length; i++) {
      ctx.fillStyle = colorA;
      ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, 2, 2);
    }
    break;
    
  case 'time_rings':
    ctx.strokeStyle = colorB;
    ctx.beginPath();
    ctx.arc(cx, cy, (audio.currentTime%5)*100, 0, Math.PI*2);
    ctx.stroke();
    break;
    
  case 'audio_prism':
    ctx.fillStyle = colorA;
    ctx.fillRect(cx-dataArray[0], cy-dataArray[1], dataArray[2], dataArray[3]);
    break;
    
  case 'glow_maze':
    ctx.strokeStyle = colorB;
    for(let i=0; i<canvas.width; i+=30) {
      ctx.strokeRect(i, i, 40, 40);
    }
    break;
    
  case 'cosmic_noise':
    for(let i=0; i<500; i++) {
      ctx.fillStyle = colorA;
      ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, 1, 1);
    }
    break;
    
  default:
    ctx.fillRect(0, cy, canvas.width, 2);
    }
    function drawTree(len, angle, bA) {
        ctx.strokeStyle = colorA; ctx.lineWidth = len/15; ctx.beginPath(); ctx.save(); ctx.rotate(angle*Math.PI/180); ctx.moveTo(0,0); ctx.lineTo(0,-len); ctx.stroke(); ctx.translate(0,-len);
        if(len > 15){ drawTree(len*0.75, angle+bA, bA); drawTree(len*0.75, angle-bA, bA); } ctx.restore();
    }

    function drawHexagon(ctx, x, y, size, scale = 1) {
        ctx.beginPath();
        for(let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i;
            const px = x + Math.cos(angle) * size * scale;
            const py = y + Math.sin(angle) * size * scale;
            if(i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
    }

    function resize() { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }
    window.onresize = resize; resize();
</script>
</body>
</html>

