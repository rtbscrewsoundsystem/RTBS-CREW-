<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>RTBS CREW DJ CONTROLLER MIX - MOD</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
/* --- Estilos principales de la mesa de DJ --- */
body { margin:0; font-family:'Comic Sans MS', cursive, sans-serif; background: black; color: #FFFF00; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
.container { display: flex; flex-direction: column; gap: 20px; padding: 20px; background: #111; border-radius: 10px; border: 2px solid #333; width: 90%; max-width: 1200px; margin: auto; position: relative; }
h1 { text-align: center; margin-top: 0; }
.waveforms-container-top { position: relative; width: 100%; height: 100px; background: #000; border: 2px solid #00f; border-radius: 5px; overflow: hidden; }
#superimposedWaveformCanvas { width: 100%; height: 100%; display:block; }
.waveforms-dual-container { display: flex; justify-content: space-between; gap: 10px; }
.waveform-deck-container { width: 100%; height: 80px; background: #222; border: 2px solid #00f; border-radius: 5px; overflow: hidden; position: relative; }
.waveform-deck-container.deck1 { border-color: #00FF00; }
.waveform-deck-container.deck2 { border-color: #FF0000; }
.hot-cue-marker { position: absolute; width: 2px; height: 100%; background: #0080FF; top: 0; pointer-events:none; z-index:5; }
#waveformCanvas1, #waveformCanvas2 { width: 100%; height: 100%; display:block; }
.decks-container { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; gap: 20px; }
.deck { display: flex; flex-direction: column; align-items: center; gap: 10px; width: auto; position: relative; z-index:1; }
.deck h3 { display: flex; align-items: center; gap: 5px; }
.bpm-display { font-size: 12px; color: #00FF00; }
.platter { width: 120px; height: 120px; background: #222; border-radius: 50%; border: 4px solid #00f; box-shadow: 0 0 10px #00f; display: flex; justify-content: center; align-items: center; position: relative; z-index:2; }
.platter-inner { width: 60px; height: 60px; background: #080; border-radius: 50%; border: 2px solid #00f; display: flex; align-items: center; justify-content: center; font-size: 10px; }
.controls { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
.buttons { display: flex; gap: 10px; z-index:3; position: relative; }
.button { width: 60px; height: 30px; background: #080; border: 2px solid #00f; border-radius: 5px; display: flex; justify-content: center; align-items: center; cursor: pointer; user-select:none; }
.crossfader-container { margin-top: 20px; text-align: center; position:relative; z-index:3; }
#crossfader { width: 90%; }
.control-block {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    padding: 10px;
    border: 1px solid #444;
    border-radius: 8px;
    background: #222;
}
.eq-group {
    display: flex;
    justify-content: space-around;
    width: 100%;
    gap: 15px;
}
.eq-control {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.eq-control label { font-size: 12px; font-weight: bold; }
.rotary-knob {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    width: 60px;
    height: 60px;
    transform: rotate(270deg);
}
.rotary-knob::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; height: 20px; width: 20px; background-color: #00f; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); margin-top: -10px; }
.rotary-knob::-moz-range-thumb { height: 20px; width: 20px; background-color: #00f; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); }
.rotary-knob::-webkit-slider-runnable-track { background: #555; height: 5px; border-radius: 5px; }
.rotary-knob::-moz-range-track { background: #555; height: 5px; border-radius: 5px; }
.eq-on-off { width: 40px; height: 20px; border: 2px solid #00f; background: #333; color: #fff; font-size: 8px; cursor: pointer; border-radius: 5px; }
.vertical-fader-container { height: 120px; width: 20px; position: relative; }
.vertical-fader {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    width: 120px;
    height: 20px;
    transform-origin: center;
    transform: rotate(270deg);
}
.vertical-fader::-webkit-slider-runnable-track { background: #555; height: 8px; border-radius: 5px; }
.vertical-fader::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; margin-top: -4px; }
.vertical-fader::-moz-range-thumb { width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; }
.progress-container { width: 100%; display: flex; flex-direction: column; gap: 5px; z-index: 10; padding: 5px; margin-top: 10px; }
.progress-bar { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #555; border-radius: 5px; cursor: pointer; }
.progress-bar::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; }
.progress-bar::-moz-range-thumb { width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; }
.time-display { display: flex; justify-content: space-between; font-size: 10px; }
.platter.playing { animation: spin 2s linear infinite; }
.platter.paused { animation-play-state: paused; }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
#equalizer-popup { display: none; flex-direction: column; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; border: 2px solid #808080; padding: 10px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); z-index: 1000; flex-direction: column; align-items: center; }
#equalizer-popup h3 { color: #0080FF; margin-top: 5px; margin-bottom: 10px; }
.eq-container { display: flex; flex-direction: column; gap: 10px; }
.eq-row { display: flex; justify-content: center; gap: 5px; }
.band { display: flex; flex-direction: column; align-items: center; width: 20px; }
.band label { font-size: 8px; color: #fff; margin-top: 5px; }
.band input[type="range"] { -webkit-appearance: slider-vertical; width: 20px; height: 120px; background: #0080FF; }
.close-btn { background: #FF0000; color: #fff; border: none; padding: 5px; cursor: pointer; margin-top: 10px; font-size: 12px; }
.loop-pads { display: flex; gap: 5px; margin-top: 10px; justify-content: center; width: 100%; }
.loop-pad { width: 45px; height: 45px; background: #005080; border: 2px solid #00f; border-radius: 5px; display: flex; justify-content: center; align-items: center; cursor: pointer; font-size: 10px; font-weight: bold; user-select: none; }
.loop-pad:active, .loop-pad.active { background: #00aaff; box-shadow: 0 0 10px #00aaff; }
#settingsButton { position: absolute; top: 10px; right: 10px; width: 40px; height: 40px; background: transparent; border: null; cursor: pointer; font-size: 30px; color: #fff; text-shadow: 0 0 5px #00f; z-index:4; }
#settingsPopup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; border: 2px solid #808080; padding: 20px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); z-index: 1001; flex-direction: column; align-items: center; gap: 15px; }
.settings-section { display: flex; flex-direction: column; gap: 5px; }
.settings-section label { font-size: 14px; font-weight: bold; }
.settings-section select { background: #333; color: #FFFF00; border: 1px solid #00f; padding: 5px; }
.deck-flex-container { display: flex; justify-content: center; align-items: flex-end; width: 100%; gap: 10px; }
.deck-controls-left { display: flex; flex-direction: column; align-items: center; gap: 10px; position: relative; }
.deck-center-controls { display: flex; flex-direction: column; align-items: center; gap: 10px; }
.hot-cues-and-reverse { display: flex; flex-direction: column; align-items: center; gap: 5px; }
.reverse-button { background: #FF0000; color: #fff; border: 2px solid #fff; cursor: pointer; user-select:none; }
.reverse-button.active { background: #ff7700; box-shadow: 0 0 10px #ff7700; }
.effects-platter-container { display: flex; flex-direction: column; align-items: center; gap: 5px; padding: 10px; border: 1px solid #444; border-radius: 8px; background: #222; z-index:2; }
.effect-button-platter { width: 40px; height: 40px; background: #500050; border: 2px solid #FF00FF; border-radius: 5px; color: #fff; font-size: 8px; text-align: center; line-height: 40px; cursor: pointer; user-select:none; }
.effect-button-platter.active { background: #ff00ff; box-shadow: 0 0 10px #ff00ff; }
.top-waveform-indicator { position: absolute; left: 50%; top: 0; width: 2px; height: 100%; background: #fff; z-index: 15; pointer-events:none; }
.center-controls-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    padding: 15px;
    background: #222;
    border: 1px solid #444;
    border-radius: 10px;
    margin-left: auto;
    margin-right: auto;
    width: 340px;
    z-index:3;
}
.fader-effects-container {
    display: flex;
    gap: 20px;
    justify-content: center;
    width: 100%;
}
.effect-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.effect-button-platter {
    width: 40px;
    height: 40px;
    background: #500050;
    border: 2px solid #FF00FF;
    border-radius: 5px;
    color: #fff;
    font-size: 8px;
    text-align: center;
    line-height: 40px;
    cursor: pointer;
    user-select:none;
}
.effect-button-platter.active {
    background: #ff00ff;
    box-shadow: 0 0 10px #ff00ff;
}
/* Ensure crossfader doesn't cover buttons */
.crossfader-container, .buttons { z-index: 3; }

/* Botones de navegación rápida */
.navigation-buttons {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}
.nav-button {
    width: 50px;
    height: 25px;
    background: #333;
    border: 1px solid #00f;
    border-radius: 3px;
    color: #fff;
    font-size: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
}
.nav-button:active {
    background: #555;
}
    /* --- NUEVOS ESTILOS PARA EL LOOP --- */
.loop-control-block {
    margin-top: 10px;
    padding: 5px;
    border: 1px solid #333;
    border-radius: 5px;
}
.loop-buttons-row {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-bottom: 5px;
}
.loop-in-button {
    background: #0080FF; /* Azul para Loop In */
    width: 80px;
}
.loop-out-button {
    background: #FF8C00; /* Naranja para Loop Out */
    width: 80px;
}
.clear-loop-button {
    background: #FF0000; /* Rojo para Clear Loop */
    width: 170px;
    font-weight: bold;
}
/* Estilos para el estado activo (opcional) */
.loop-in-button.active {
    background: #33aaff;
    box-shadow: 0 0 10px #33aaff;
}
.loop-out-button.active {
    background: #ffaa33;
    box-shadow: 0 0 10px #ffaa33;
}
<div class="control-block loop-control-block">
    <div class="loop-buttons-row">
        <button class="button loop-in-button" id="loopInBtn1" onclick="setLoopIn(1)">Loop In</button>
        <button class="button loop-out-button" id="loopOutBtn1" onclick="setLoopOut(1)">Loop Out</button>
    </div>
    <button class="button clear-loop-button" id="clearLoopBtn1" onclick="clearLoop(1)">Clear Loop</button>
</div>

    <div class="control-block loop-control-block">
    <div class="loop-buttons-row">
        <button class="button loop-in-button" id="loopInBtn2" onclick="setLoopIn(2)">Loop In</button>
        <button class="button loop-out-button" id="loopOutBtn2" onclick="setLoopOut(2)">Loop Out</button>
    </div>
    <button class="button clear-loop-button" id="clearLoopBtn2" onclick="clearLoop(2)">Clear Loop</button>
</div>
    
</style>
</head>
<body>

<div class="container">
    <button id="settingsButton" onclick="toggleSettingsPopup()">⚙️</button>
    <h1>RTBS CREW DJ CONTROLLER MIX — MOD</h1>

    <div class="waveforms-container-top">
        <canvas id="superimposedWaveformCanvas"></canvas>
        <div class="top-waveform-indicator"></div>
    </div>

    <div class="decks-container">
        <div class="deck" data-deck="1">
            <h3>Plato 1 <span id="bpmDisplay1" class="bpm-display"></span></h3>
            <div class="platter" id="platter1" onclick="toggleSuperimpose(1)">
                <div class="platter-inner">Plato 1</div>
            </div>
            <input type="file" id="fileInput1" accept="audio/*">
            <div class="progress-container">
                <input type="range" id="progressBar1" class="progress-bar" min="0" max="1" step="0.001" value="0">
                <div class="time-display">
                    <span id="currentTime1">0:00</span>
                    <span id="duration1">0:00</span>
                </div>
            </div>
            <div class="waveform-deck-container deck1">
                <canvas id="waveformCanvas1"></canvas>
            </div>
            
            <div class="navigation-buttons">
                <div class="nav-button" onclick="navigateByBeats(1, -4)">-4 B</div>
                <div class="nav-button" onclick="navigateByBeats(1, 4)">+4 B</div>
            </div>
            
            <div class="loop-pads" id="loopPads1">
                <div class="loop-pad" data-value="0.125" onmousedown="startLoopRoll(1, 0.125)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/8</div>
                <div class="loop-pad" data-value="0.0625" onmousedown="startLoopRoll(1, 0.0625)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/16</div>
                <div class="loop-pad" data-value="0.25" onmousedown="startLoopRoll(1, 0.25)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/4</div>
                <div class="loop-pad" data-value="0.5" onmousedown="startLoopRoll(1, 0.5)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/2</div>
                <div class="loop-pad" data-value="1" onmousedown="startLoopRoll(1, 1)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1</div>
                <div class="loop-pad" data-value="2" onmousedown="startLoopRoll(1, 2)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">2</div>
            </div>
            
            <div class="deck-flex-container">
                <div class="deck-controls-left">
                    <div class="control-block">
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>B</label>
                                <input type="range" id="bass1" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>M</label>
                                <input type="range" id="mid1" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>T</label>
                                <input type="range" id="treble1" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                        </div>
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>Ganancia</label>
                                <input type="range" id="gain1" min="0" max="2" step="0.01" value="1" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>Filtro</label>
                                <input type="range" id="filter1" min="20" max="22050" step="1" value="22050" class="rotary-knob">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: center; gap: 10px;">
                            <button class="eq-on-off" onclick="toggleEQ('bass', 1)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('mid', 1)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('treble', 1)">Kill</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="center-controls-container">
            <div class="fader-effects-container">
                <div class="vertical-fader-container">
                    <input type="range" id="volume1" min="0" max="1" step="0.01" value="0.7" class="vertical-fader">
                </div>
                <div class="effect-group">
                    <h4>Efectos 1</h4>
                    <button class="effect-button-platter" id="effect1-cut" onclick="toggleEffect(1, 'cut')">CUT</button>
                    <button class="effect-button-platter" id="effect1-flanger" onclick="toggleEffect(1, 'flanger')">FLNG</button>
                </div>
                <div class="vertical-fader-container">
                    <input type="range" id="volume2" min="0" max="1" step="0.01" value="0.7" class="vertical-fader">
                </div>
                <div class="effect-group">
                    <h4>Efectos 2</h4>
                    <button class="effect-button-platter" id="effect2-cut" onclick="toggleEffect(2, 'cut')">CUT</button>
                    <button class="effect-button-platter" id="effect2-flanger" onclick="toggleEffect(2, 'flanger')">FLNG</button>
                </div>
            </div>

            <div class="pitch-controls">
                <label>Pitch 1</label>
                <input type="range" id="pitch1" min="0.5" max="2" step="0.01" value="1">
                <label>Pitch 2</label>
                <input type="range" id="pitch2" min="0.5" max="2" step="0.01" value="1">
            </div>
            <div class="buttons">
                <div class="button" id="button1" onclick="playPause(1)">Play</div>
                <div class="button" id="sync1" onclick="sync(1)">Sync</div>
                <div class="button" id="button2" onclick="playPause(2)">Play</div>
                <div class="button" id="sync2" onclick="sync(2)">Sync</div>
            </div>
            
            <div class="crossfader-container">
                <span>Crossfader</span><br>
                <input type="range" id="crossfader" min="0" max="1" step="0.01" value="0.5">
            </div>
            
            <div class="hot-cues-and-reverse">
                <div style="display:flex; gap:8px; align-items:center;">
                    <div>
                        <button class="hot-cue-button button" id="hotCue1" onclick="toggleHotCue(1)">HotCue</button>
                        <div style="font-size:10px; text-align:center;">Guardar / Ir</div>
                    </div>
                    <div>
                        <button class="button" id="deleteHotCue1" onclick="deleteHotCue(1)">Eliminar</button>
                        <div style="font-size:10px; text-align:center;">Eliminar hotcue</div>
                    </div>
                    <div>
                        <button class="hot-cue-button button" id="hotCue2" onclick="toggleHotCue(2)">HotCue</button>
                        <div style="font-size:10px; text-align:center;">Guardar / Ir</div>
                    </div>
                    <div>
                        <button class="button" id="deleteHotCue2" onclick="deleteHotCue(2)">Eliminar</button>
                        <div style="font-size:10px; text-align:center;">Eliminar hotcue</div>
                    </div>
                </div>
                <div style="margin-top:8px;">
                    <button class="button reverse-button" id="reverse1" onmousedown="startReverse(1)" onmouseup="stopReverse(1)" onmouseleave="stopReverse(1)">Reverse 1 (hold)</button>
                    <button class="button reverse-button" id="reverse2" onmousedown="startReverse(2)" onmouseup="stopReverse(2)" onmouseleave="stopReverse(2)">Reverse 2 (hold)</button>
                </div>
            </div>
        </div>

        <div class="deck" data-deck="2">
            <h3>Plato 2 <span id="bpmDisplay2" class="bpm-display"></span></h3>
            <div class="platter" id="platter2" onclick="toggleSuperimpose(2)">
                <div class="platter-inner">Plato 2</div>
            </div>
            <input type="file" id="fileInput2" accept="audio/*">
            <div class="progress-container">
                <input type="range" id="progressBar2" class="progress-bar" min="0" max="1" step="0.001" value="0">
                <div class="time-display">
                    <span id="currentTime2">0:00</span>
                    <span id="duration2">0:00</span>
                </div>
            </div>
            <div class="waveform-deck-container deck2">
                <canvas id="waveformCanvas2"></canvas>
            </div>
            
            <div class="navigation-buttons">
                <div class="nav-button" onclick="navigateByBeats(2, -4)">-4 B</div>
                <div class="nav-button" onclick="navigateByBeats(2, 4)">+4 B</div>
            </div>
            
            <div class="loop-pads" id="loopPads2">
                <div class="loop-pad" data-value="0.125" onmousedown="startLoopRoll(2, 0.125)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/8</div>
                <div class="loop-pad" data-value="0.0625" onmousedown="startLoopRoll(2, 0.0625)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/16</div>
                <div class="loop-pad" data-value="0.25" onmousedown="startLoopRoll(2, 0.25)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/4</div>
                <div class="loop-pad" data-value="0.5" onmousedown="startLoopRoll(2, 0.5)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/2</div>
                <div class="loop-pad" data-value="1" onmousedown="startLoopRoll(2, 1)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1</div>
                <div class="loop-pad" data-value="2" onmousedown="startLoopRoll(2, 2)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">2</div>
            </div>
            
            <div class="deck-flex-container">
                <div class="deck-controls-left">
                    <div class="control-block">
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>B</label>
                                <input type="range" id="bass2" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>M</label>
                                <input type="range" id="mid2" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>T</label>
                                <input type="range" id="treble2" min="-20" max; max="20" value="0" class="rotary-knob">
                            </div>
                        </div>
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>Ganancia</label>
                                <input type="range" id="gain2" min="0" max="2" step="0.01" value="1" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>Filtro</label>
                                <input type="range" id="filter2" min="20" max="22050" step="1" value="22050" class="rotary-knob">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: center; gap: 10px;">
                            <button class="eq-on-off" onclick="toggleEQ('bass', 2)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('mid', 2)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('treble', 2)">Kill</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div style="text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px;">
        <button onclick="toggleEqualizerPopup()">Ecualizador de 30 bandas</button>
        <div class="button" id="recordButton" onclick="toggleRecording()" style="width: auto;">Grabar</div>
        <div class="button" id="saveButton" onclick="saveRecording()" style="width: auto; background: #FF5733; display: none;">Guardar</div>
    </div>
</div>

<div id="equalizer-popup">
    <h3>Ecualizador de 30 bandas</h3>
    <div class="eq-container">
        <div class="eq-row" id="row1"></div>
        <div class="eq-row" id="row2"></div>
    </div>
    <button class="close-btn" onclick="toggleEqualizerPopup()">Cerrar</button>
</div>

<div id="settingsPopup">
    <h3>Ajustes de Sonido y MIDI</h3>
    <div class="settings-section">
        <label for="audioOutputSelector">Salida de Sonido:</label>
        <select id="audioOutputSelector"></select>
    </div>
    <div class="settings-section">
        <label for="midiInputSelector">Controlador MIDI:</label>
        <select id="midiInputSelector"></select>
    </div>
    <div class="settings-section">
        <label for="waveformStyleSelector">Visualizador de Onda:</label>
        <select id="waveformStyleSelector">
            <option value="default">Verde y Rojo</option>
            <option value="blue-orange">Azul y Naranja</option>
            <option value="rainbow">Arcoíris</option>
            <option value="mono">Monocromático</option>
            <option value="gradient">Degradado</option>
            <option value="bars">Barras</option>
            <option value="dots">Puntos</option>
            <option value="outline">Contorno</option>
        </select>
    </div>

    <div class="settings-section">
        <label for="recordingSourceSelector">Fuente de Grabación:</label>
        <select id="recordingSourceSelector">
            <option value="master">Salida Master (Línea)</option>
            <option value="mic">Micrófono</option>
        </select>
    </div>
    
    <div class="settings-section">
        <label for="midiMappingSelector">Mapeo MIDI:</label>
        <select id="midiMappingSelector">
            <option value="default">Por Defecto</option>
            <option value="traktor">Traktor</option>
            <option value="serato">Serato</option>
            <option value="rekordbox">Rekordbox</option>
            <option value="virtualdj">VirtualDJ</option>
            <option value="custom">Personalizado</option>
        </select>
    </div>

    <button class="close-btn" onclick="applySettings()">Aplicar</button>
    <button class="close-btn" onclick="toggleSettingsPopup()">Cerrar</button>
</div>

<script>
// =========================================================================
// === RTBS CREW CONTROLLER DJ MIX (CORREGIDO Y CON LOOP) ===
// =========================================================================

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let decks = {
        1: {
            audio: null,
            audioBuffer: null,
            source: null,
            gainNode: audioContext.createGain(),
            filterNode: audioContext.createBiquadFilter(),
            analyser: null,
            isPlaying: false,
            startTime: 0,
            pauseTime: 0, // Guarda la posición de reproducción en el buffer original (segundos)
            isReversed: false,
            reversedBuffer: null,
            eq: { bass: audioContext.createBiquadFilter(), mid: audioContext.createBiquadFilter(), treble: audioContext.createBiquadFilter() },
            isLoaded: false,
            animationFrame: null,
            eqState: { bass: true, mid: true, treble: true },
            eqValue: { bass: 0, mid: 0, treble: 0 },
            bpm: 0,
            loopRollSource: null,
            vinylBrakeInterval: null,
            hotCue: null,
            effects: { cut: false, flanger: false },
            vinylStartSound: null,
            vinylStopSound: null,
            // Efectos
            cutEffect: null,
            flangerEffect: null,
            // Para el visualizador superior
            waveformData: null,
            currentBeat: 0,
            // === PROPIEDADES AÑADIDAS PARA EL LOOP PERMANENTE ===
            loopStart: null, // Punto de inicio del loop en segundos
            loopEnd: null,   // Punto de fin del loop en segundos
            isLooping: false,
            loopSource: null, // AudioBufferSourceNode específico para el loop
        },
        2: {
            audio: null,
            audioBuffer: null,
            source: null,
            gainNode: audioContext.createGain(),
            filterNode: audioContext.createBiquadFilter(),
            analyser: null,
            isPlaying: false,
            startTime: 0,
            pauseTime: 0, // Guarda la posición de reproducción en el buffer original (segundos)
            isReversed: false,
            reversedBuffer: null,
            eq: { bass: audioContext.createBiquadFilter(), mid: audioContext.createBiquadFilter(), treble: audioContext.createBiquadFilter() },
            isLoaded: false,
            animationFrame: null,
            eqState: { bass: true, mid: true, treble: true },
            eqValue: { bass: 0, mid: 0, treble: 0 },
            bpm: 0,
            loopRollSource: null,
            vinylBrakeInterval: null,
            hotCue: null,
            effects: { cut: false, flanger: false },
            vinylStartSound: null,
            vinylStopSound: null,
            // Efectos
            cutEffect: null,
            flangerEffect: null,
            // Para el visualizador superior
            waveformData: null,
            currentBeat: 0,
            // === PROPIEDADES AÑADIDAS PARA EL LOOP PERMANENTE ===
            loopStart: null,
            loopEnd: null,
            isLooping: false,
            loopSource: null,
        }
    };
    let mediaRecorder;
    let recordedChunks = [];
    let analyserMaster = audioContext.createAnalyser(); analyserMaster.fftSize = 2048;
    let showDeck = {1:true,2:true}; // control which deck wave is superimposed
    
    let recordingStream;
    let isRecording = false;
    let activeRecordingSource = 'master';
    let currentWaveformStyle = 'default';

    // 30-band equalizer
    const frequencies = [
        32, 64, 125, 250, 500, 1000, 2000, 4000, 8000, 16000,
        31, 62, 125, 250, 500, 1000, 2000, 4000, 8000, 16000,
        20, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240
    ];
    const eqNodes = [];
    let globalEqFilters = [];
    const row1 = document.getElementById('row1');
    const row2 = document.getElementById('row2');

    const superCanvas = document.getElementById('superimposedWaveformCanvas');
    const superCtx = superCanvas.getContext('2d');
    
    // =========================================================================
    // === NUEVA FUNCIÓN DE UTILIDAD: OBTENER POSICIÓN PRECISA ===
    // =========================================================================
    function getCurrentPositionSeconds(deckNum) {
        const deck = decks[deckNum];
        if (!deck.isLoaded) return 0;
        
        const duration = deck.audioBuffer.duration;
        let playbackRate = parseFloat(document.getElementById(`pitch${deckNum}`).value);
            
        // Si no está sonando, devolvemos el tiempo en pausa (ya actualizado)
        if (!deck.isPlaying) {
            return deck.pauseTime;
        }

        // El tiempo de reproducción siempre avanza basado en el `playbackRate` desde el `pauseTime` inicial.
        const timeElapsed = audioContext.currentTime - deck.startTime;
        let positionInPlayingBuffer = deck.pauseTime + (timeElapsed * playbackRate);

        // Si la pista está en reversa, el buffer se invierte y el tiempo avanza desde 0 hasta la duración.
        // La posición real en la pista debe ser la inversa.
        if (deck.isReversed) {
            // El tiempo visible en la pista normal es: Duración Total - (Tiempo en el buffer reverso)
            positionInPlayingBuffer = duration - positionInPlayingBuffer;
            // Asegurarse de que el tiempo no se salga de 0 a Duración
            return Math.max(0, Math.min(duration, positionInPlayingBuffer));
        }
        
        // Si está en loop, el tiempo se cicla entre loopStart y loopEnd
        if (deck.isLooping && deck.loopStart !== null && deck.loopEnd !== null) {
            const loopDuration = deck.loopEnd - deck.loopStart;
            // Calcular cuánto tiempo ha avanzado dentro del loop (desde loopStart)
            let timeInLoop = (positionInPlayingBuffer - deck.loopStart) % loopDuration;
            // Manejar el resultado de módulo negativo si existe
            if (timeInLoop < 0) timeInLoop += loopDuration; 
            return deck.loopStart + timeInLoop;
        }

        // Para reproducción normal
        return Math.max(0, Math.min(duration, positionInPlayingBuffer));
    }


    // =========================================================================
    // === NUEVAS FUNCIONES DE LOOP PERMANENTE (LOOP IN/OUT) ===
    // =========================================================================
    
    // Botón: Marca el punto de inicio del loop
    function setLoopIn(deckNum) {
        const deck = decks[deckNum];
        if (!deck.isLoaded) return;
        
        // Si está sonando o pausado, el punto de inicio es la posición actual
        deck.loopStart = getCurrentPositionSeconds(deckNum);
        deck.loopEnd = null; // Resetear el punto final
        deck.isLooping = false;
        
        // Actualizar interfaz (asumiendo que tienes botones con IDs loopIn1/loopIn2, etc.)
        document.getElementById(`loopIn${deckNum}`).classList.add('active');
        document.getElementById(`loopOut${deckNum}`).classList.remove('active');
        document.getElementById(`clearLoop${deckNum}`).classList.remove('active');
        
        drawFullWaveform(deckNum);
        console.log(`Deck ${deckNum}: Loop In establecido en ${deck.loopStart.toFixed(2)}s`);
    }

    // Botón: Marca el punto final del loop e inicia el loop
    function setLoopOut(deckNum) {
        const deck = decks[deckNum];
        if (!deck.isLoaded || deck.loopStart === null) {
            alert(`Deck ${deckNum}: Primero pulsa Loop In.`);
            return;
        }

        const currentPos = getCurrentPositionSeconds(deckNum);
        
        if (currentPos <= deck.loopStart) {
            alert(`Deck ${deckNum}: El punto final debe ser después del punto de inicio (${deck.loopStart.toFixed(2)}s).`);
            return;
        }

        deck.loopEnd = currentPos;
        
        const wasPlaying = deck.isPlaying;
        
        if (wasPlaying) {
             // Detenemos la reproducción normal para cambiar a loop
             pauseTrack(deckNum);
        }
        
        // Forzar el inicio de la reproducción desde loopStart si está en pausa
        deck.pauseTime = deck.loopStart;
        
        deck.isLooping = true;
        
        if (wasPlaying) {
            // El `playTrack` ahora gestionará que debe iniciar el loop
            playTrack(deckNum);
        }
        
        // Actualizar interfaz del botón
        document.getElementById(`loopIn${deckNum}`).classList.remove('active');
        document.getElementById(`loopOut${deckNum}`).classList.add('active');
        document.getElementById(`clearLoop${deckNum}`).classList.remove('active');
        
        drawFullWaveform(deckNum);
        console.log(`Deck ${deckNum}: Loop Out establecido en ${deck.loopEnd.toFixed(2)}s. Loop activo.`);
    }

    // Botón: Limpia y detiene el loop, reanuda reproducción normal si estaba activo
    function clearLoop(deckNum) {
        const deck = decks[deckNum];
        if (!deck.isLoaded) return;
        
        const wasPlaying = deck.isPlaying;
        
        if (wasPlaying) {
            // Detener el source activo (normal o loop) y guardar la posición precisa
            pauseTrack(deckNum);
        }
        
        // 1. Resetear las propiedades del loop
        deck.loopStart = null;
        deck.loopEnd = null;
        deck.isLooping = false;
        
        // 2. Limpiar el loopSource por si acaso
        if (deck.loopSource) {
            try { deck.loopSource.stop(0); } catch(e) {}
            deck.loopSource.disconnect();
            deck.loopSource = null;
        }
        
        // 3. Si la pista estaba sonando, reanudar la reproducción normal.
        if (wasPlaying) {
            // Reanudar la reproducción desde el pauseTime que se guardó
            playTrack(deckNum); 
        } 
        
        // 4. Actualizar la interfaz de los botones
        document.getElementById(`loopIn${deckNum}`).classList.remove('active');
        document.getElementById(`loopOut${deckNum}`).classList.remove('active');
        document.getElementById(`clearLoop${deckNum}`).classList.add('active');
        
        drawFullWaveform(deckNum);
        console.log(`Deck ${deckNum}: Loop desactivado.`);
        
        // Quitar la clase active del clearBtn después de un breve tiempo
        setTimeout(() => {
            document.getElementById(`clearLoop${deckNum}`).classList.remove('active');
        }, 200);
    }

    // Función auxiliar para crear y conectar el source (normal o loop)
    function startAudioSource(deckNum, startOffset) {
        const deck = decks[deckNum];
        
        // 1. Crear el source
        const source = audioContext.createBufferSource();
        source.buffer = deck.isReversed ? deck.reversedBuffer : deck.audioBuffer;
        
        // 2. Configurar el loop si es necesario
        if (deck.isLooping && deck.loopStart !== null && deck.loopEnd !== null) {
            source.loop = true; 
            source.loopStart = deck.loopStart; 
            source.loopEnd = deck.loopEnd;
            
            // Si el modo reverso está activo, para que el loop funcione en el Web Audio API,
            // necesitamos que el buffer no esté invertido y ajustar el playback rate a negativo
            // para que suene como loop reverso.
            if (deck.isReversed) {
                 // Advertencia: El Web Audio API no soporta loop en buffers reversos.
                 // Usamos el buffer normal y ajustamos la velocidad a negativo.
                 source.buffer = deck.audioBuffer;
                 // startOffset debe ser el tiempo *normal* del buffer (duración - tiempo_reverso)
                 startOffset = deck.audioBuffer.duration - startOffset;
            }
        }
        
        // 3. Set playback rate (afectado por el pitch y la reversa en el caso de loop reverso)
        let rate = parseFloat(document.getElementById(`pitch${deckNum}`).value);
        if (deck.isLooping && deck.isReversed) {
             rate = -rate;
        }
        source.playbackRate.value = rate;
        
        // 4. Conectar source a la cadena de audio
        source.connect(decks[deckNum].eq.bass);
        
        // 5. Iniciar la reproducción
        source.start(0, startOffset);
        
        return source;
    }

    // =========================================================================
    // === FUNCIONES NUCLEARES MODIFICADAS ===
    // =========================================================================

    // Cargar sonidos de inicio y parada de vinilo
    async function loadVinylSounds() {
        try {
            // Crear sonidos sintéticos para inicio y parada de vinilo
            const createVinylSound = (fadeIn, duration) => {
                const sampleRate = audioContext.sampleRate;
                const length = sampleRate * duration;
                const buffer = audioContext.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < length; i++) {
                    // Ruido blanco
                    let value = Math.random() * 2 - 1;
                    
                    // Aplicar filtro de paso bajo para simular ruido de vinilo
                    if (i > 0) {
                        value = 0.95 * data[i-1] + 0.05 * value;
                    }
                    
                    // Aplicar envolvente
                    let envelope;
                    if (fadeIn) {
                        envelope = Math.min(1, i / (sampleRate * 0.1)); // Fade in rápido
                    } else {
                        envelope = Math.max(0, 1 - (i / (sampleRate * 0.3))); // Fade out más lento
                    }
                    
                    data[i] = value * envelope * 0.3;
                }
                
                return buffer;
            };
            
            decks[1].vinylStartSound = createVinylSound(true, 0.2);
            decks[1].vinylStopSound = createVinylSound(false, 0.5);
            decks[2].vinylStartSound = createVinylSound(true, 0.2);
            decks[2].vinylStopSound = createVinylSound(false, 0.5);
        } catch (error) {
            console.error("Error creating vinyl sounds:", error);
        }
    }

    // Reproducir sonido de vinilo
    function playVinylSound(deckNum, isStart) {
        if (!decks[deckNum]) return;
        
        const buffer = isStart ? decks[deckNum].vinylStartSound : decks[deckNum].vinylStopSound;
        if (!buffer) return;
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);
        source.start();
    }

    // Inicializar ecualizador de 30 bandas
    function init30BandEQ() {
        // Clear existing nodes
        while (globalEqFilters.length > 0) {
            const filter = globalEqFilters.pop();
            filter.disconnect();
        }
        
        // Create new filters
        for (let i = 0; i < frequencies.length; i++) {
            const filter = audioContext.createBiquadFilter();
            filter.type = 'peaking';
            filter.frequency.value = frequencies[i];
            filter.Q.value = 1;
            filter.gain.value = 0;
            
            // Connect in series
            if (i === 0) {
                analyserMaster.connect(filter);
            } else {
                globalEqFilters[i-1].connect(filter);
            }
            
            globalEqFilters.push(filter);
            
            // Create UI controls
            const band = document.createElement('div');
            band.className = 'band';
            
            const input = document.createElement('input');
            input.type = 'range';
            input.min = '-20';
            input.max = '20';
            input.value = '0';
            input.dataset.index = i;
            input.addEventListener('input', (e) => {
                const index = parseInt(e.target.dataset.index);
                globalEqFilters[index].gain.value = parseFloat(e.target.value);
            });
            
            const label = document.createElement('label');
            label.textContent = `${frequencies[i]}Hz`;
            
            band.appendChild(input);
            band.appendChild(label);
            
            // Asegurarse de que los elementos row1 y row2 existen antes de intentar usarlos
            if (row1 && i < 15) {
                row1.appendChild(band);
            } else if (row2) {
                row2.appendChild(band);
            }
        }
        
        // Connect the last filter to destination
        if (globalEqFilters.length > 0) {
            globalEqFilters[globalEqFilters.length - 1].connect(audioContext.destination);
        }
    }

    // Initialize the application
    function init() {
        // Set up audio routing
        analyserMaster.connect(audioContext.destination);
        
        // Initialize 30-band EQ
        init30BandEQ();
        
        // Load vinyl sounds
        loadVinylSounds();
        
        // Set up file inputs
        document.getElementById('fileInput1').addEventListener('change', (e) => handleFileSelect(e, 1));
        document.getElementById('fileInput2').addEventListener('change', (e) => handleFileSelect(e, 2));
        
        // Set up controls
        setupControls();
        
        // Set up canvas dimensions
        setupCanvasDimensions();
        
        // Set up MIDI (Asumimos que esta función existe)
        // setupMIDI(); 
        
        // Start animation
        animate();
        
        // Set up recording (Asumimos que esta función existe)
        // setupRecording();
    }

    // Set up controls
    function setupControls() {
        // Volume controls
        document.getElementById('volume1').addEventListener('input', (e) => {
            decks[1].gainNode.gain.value = parseFloat(e.target.value);
        });
        document.getElementById('volume2').addEventListener('input', (e) => {
            decks[2].gainNode.gain.value = parseFloat(e.target.value);
        });
        
        // EQ controls
        ['bass', 'mid', 'treble'].forEach((band) => {
            for (let i = 1; i <= 2; i++) {
                document.getElementById(`${band}${i}`).addEventListener('input', (e) => {
                    decks[i].eq[band].gain.value = parseFloat(e.target.value);
                    decks[i].eqValue[band] = parseFloat(e.target.value);
                });
            }
        });
        
        // Gain controls
        document.getElementById('gain1').addEventListener('input', (e) => {
            decks[1].gainNode.gain.value = parseFloat(e.target.value);
        });
        document.getElementById('gain2').addEventListener('input', (e) => {
            decks[2].gainNode.gain.value = parseFloat(e.target.value);
        });
        
        // Filter controls
        document.getElementById('filter1').addEventListener('input', (e) => {
            decks[1].filterNode.frequency.value = parseFloat(e.target.value);
        });
        document.getElementById('filter2').addEventListener('input', (e) => {
            decks[2].filterNode.frequency.value = parseFloat(e.target.value);
        });
        
        // Pitch controls (MODIFICADO para reajustar el playbackRate inmediatamente)
        document.getElementById('pitch1').addEventListener('input', (e) => {
            const newRate = parseFloat(e.target.value);
            if (decks[1].source) {
                decks[1].source.playbackRate.value = newRate;
            } else if (decks[1].loopSource) {
                 // Si está en loop reverso, la tasa es negativa
                 const rate = decks[1].isReversed ? -newRate : newRate;
                 decks[1].loopSource.playbackRate.value = rate;
            }
        });
        document.getElementById('pitch2').addEventListener('input', (e) => {
            const newRate = parseFloat(e.target.value);
            if (decks[2].source) {
                decks[2].source.playbackRate.value = newRate;
            } else if (decks[2].loopSource) {
                 const rate = decks[2].isReversed ? -newRate : newRate;
                 decks[2].loopSource.playbackRate.value = rate;
            }
        });
        
        // Crossfader
        document.getElementById('crossfader').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            // Adjust volumes based on crossfader position
            decks[1].gainNode.gain.value = value < 0.5 ? 1 : 1 - ((value - 0.5) * 2);
            decks[2].gainNode.gain.value = value > 0.5 ? 1 : value * 2;
        });
        
        // Progress bars (MODIFICADO: Usa la función seekTrack)
        document.getElementById('progressBar1').addEventListener('input', (e) => {
            if (decks[1].isLoaded) {
                seekTrack(1, parseFloat(e.target.value));
            }
        });
        document.getElementById('progressBar2').addEventListener('input', (e) => {
            if (decks[2].isLoaded) {
                seekTrack(2, parseFloat(e.target.value));
            }
        });
    }

    // Set up canvas dimensions
    function setupCanvasDimensions() {
        const canvases = [
            document.getElementById('superimposedWaveformCanvas'),
            document.getElementById('waveformCanvas1'),
            document.getElementById('waveformCanvas2')
        ];
        
        canvases.forEach(canvas => {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        });
    }

    // Handle file selection
    async function handleFileSelect(event, deckNum) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Store audio buffer
            decks[deckNum].audioBuffer = audioBuffer;
            decks[deckNum].isLoaded = true;
            
            // Preprocess waveform data for the top visualizer
            preprocessWaveformData(deckNum, audioBuffer);
            
            // Create reversed buffer
            createReversedBuffer(deckNum, audioBuffer);
            
            // Create analyser
            decks[deckNum].analyser = audioContext.createAnalyser();
            decks[deckNum].analyser.fftSize = 2048;
            
            // Set up audio routing
            setupAudioRouting(deckNum);
            
            // Draw waveform
            drawFullWaveform(deckNum);
            
            // Update duration display
            const duration = formatTime(audioBuffer.duration);
            document.getElementById(`duration${deckNum}`).textContent = duration;
            
            // Detect BPM
            detectBPM(deckNum, audioBuffer);
            
            // Reset position, loop and reverse state
            decks[deckNum].pauseTime = 0;
            decks[deckNum].isReversed = false;
            clearLoop(deckNum); // Asegura que el loop esté limpio
            
        } catch (error) {
            console.error('Error loading audio file:', error);
        }
    }

    // Preprocess waveform data for the top visualizer
    function preprocessWaveformData(deckNum, audioBuffer) {
        const channelData = audioBuffer.getChannelData(0);
        const samplesPerPixel = Math.floor(channelData.length / superCanvas.width);
        decks[deckNum].waveformData = [];
        
        for (let i = 0; i < superCanvas.width; i++) {
            let min = 0;
            let max = 0;
            
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = i * samplesPerPixel + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            
            decks[deckNum].waveformData.push({ min, max });
        }
    }

    // Create reversed audio buffer
    function createReversedBuffer(deckNum, audioBuffer) {
        const reversedBuffer = audioContext.createBuffer(
            audioBuffer.numberOfChannels,
            audioBuffer.length,
            audioBuffer.sampleRate
        );
        
        for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
            const originalData = audioBuffer.getChannelData(channel);
            const reversedData = reversedBuffer.getChannelData(channel);
            
            for (let i = 0; i < audioBuffer.length; i++) {
                reversedData[i] = originalData[audioBuffer.length - 1 - i];
            }
        }
        
        decks[deckNum].reversedBuffer = reversedBuffer;
    }

    // Set up audio routing
    function setupAudioRouting(deckNum) {
        // Set up EQ
        decks[deckNum].eq.bass.type = 'lowshelf';
        decks[deckNum].eq.bass.frequency.value = 250;
        
        decks[deckNum].eq.mid.type = 'peaking';
        decks[deckNum].eq.mid.frequency.value = 1000;
        decks[deckNum].eq.mid.Q.value = 1;
        
        decks[deckNum].eq.treble.type = 'highshelf';
        decks[deckNum].eq.treble.frequency.value = 4000;
        
        // Set up filter
        decks[deckNum].filterNode.type = 'lowpass';
        decks[deckNum].filterNode.frequency.value = 22050;
        
        // Connect nodes
        decks[deckNum].eq.bass.connect(decks[deckNum].eq.mid);
        decks[deckNum].eq.mid.connect(decks[deckNum].eq.treble);
        decks[deckNum].eq.treble.connect(decks[deckNum].filterNode);
        decks[deckNum].filterNode.connect(decks[deckNum].gainNode);
        decks[deckNum].gainNode.connect(decks[deckNum].analyser);
        decks[deckNum].analyser.connect(analyserMaster);
    }

    // Draw full waveform (MODIFICADA para dibujar el Loop)
    function drawFullWaveform(deckNum) {
        const canvas = document.getElementById(`waveformCanvas${deckNum}`);
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        ctx.clearRect(0, 0, width, height);
        
        if (!decks[deckNum].audioBuffer) return;
        
        const deck = decks[deckNum];
        const audioBuffer = deck.audioBuffer;
        const channelData = audioBuffer.getChannelData(0);
        const step = Math.ceil(channelData.length / width);
        
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        
        // Choose color based on deck
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        for (let i = 0; i < width; i++) {
            let min = 0;
            let max = 0;
            
            for (let j = 0; j < step; j++) {
                const index = i * step + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            
            ctx.lineTo(i, height / 2 - min * height / 2);
            ctx.lineTo(i, height / 2 - max * height / 2);
        }
        
        ctx.stroke();

        // ------------------------------------------------------------------
        // NUEVO CÓDIGO: DIBUJAR LA REGIÓN DEL LOOP
        if (deck.loopStart !== null && deck.loopEnd !== null) {
            const duration = deck.audioBuffer.duration;

            const startProgress = deck.loopStart / duration;
            const endProgress = deck.loopEnd / duration;
            
            const startX = startProgress * width;
            const endX = endProgress * width;
            const loopWidth = endX - startX;
            
            // Dibuja la región amarilla semi-transparente
            ctx.fillStyle = 'rgba(255, 255, 0, 0.3)'; 
            ctx.fillRect(startX, 0, loopWidth, height);

            // Dibuja líneas para Loop In y Loop Out
            ctx.strokeStyle = '#FFFF00';
            ctx.lineWidth = 1;
            
            // Línea Loop In
            ctx.beginPath();
            ctx.moveTo(startX, 0);
            ctx.lineTo(startX, height);
            ctx.stroke();

            // Línea Loop Out
            ctx.beginPath();
            ctx.moveTo(endX, 0);
            ctx.lineTo(endX, height);
            ctx.stroke();
        }
        // ------------------------------------------------------------------
        
        // Dibuja el cabezal de reproducción (playhead)
        const currentTime = getCurrentPositionSeconds(deckNum); // Usar la nueva función de utilidad
        const currentProgress = (currentTime / deck.audioBuffer.duration);
        const playHeadX = currentProgress * width;

        ctx.fillStyle = '#FF0000'; // Rojo
        ctx.fillRect(playHeadX, 0, 2, height);
    }

    // Play/Pause track
    function playPause(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        
        if (decks[deckNum].isPlaying) {
            pauseTrack(deckNum);
        } else {
            playTrack(deckNum);
        }
    }

    // Play track (MODIFICADA para usar la lógica de Loop y la función startAudioSource)
    function playTrack(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        
        // Si el contexto de audio está suspendido, reanudarlo
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }

        // Si ya hay un source (normal o loop), detenerlo y desconectarlo
        if (decks[deckNum].source) {
            try { decks[deckNum].source.stop(); } catch(e) {}
            decks[deckNum].source.disconnect();
            decks[deckNum].source = null;
        }
        if (decks[deckNum].loopSource) {
            try { decks[deckNum].loopSource.stop(); } catch(e) {}
            decks[deckNum].loopSource.disconnect();
            decks[deckNum].loopSource = null;
        }
        
        // Play vinyl start sound
        playVinylSound(deckNum, true);
        
        let startOffset = decks[deckNum].pauseTime;
        
        // --- Lógica del Loop ---
        if (decks[deckNum].isLooping && decks[deckNum].loopStart !== null && decks[deckNum].loopEnd !== null) {
            // Usamos loopSource para el loop
            decks[deckNum].loopSource = startAudioSource(deckNum, startOffset);
            decks[deckNum].source = null; // Asegurar que el source normal es null
        } else {
            // Reproducción normal
            decks[deckNum].source = startAudioSource(deckNum, startOffset);
            decks[deckNum].loopSource = null; // Asegurar que el loopSource es null
        }
        // --- Fin Lógica del Loop ---
        
        // Update state
        decks[deckNum].isPlaying = true;
        decks[deckNum].startTime = audioContext.currentTime;
        
        // Update button text
        document.getElementById(`button${deckNum}`).textContent = 'Pause';
        
        // Start platter animation
        document.getElementById(`platter${deckNum}`).classList.add('playing');
        
        // Start animation for progress bar
        cancelAnimationFrame(decks[deckNum].animationFrame);
        animateProgress(deckNum);
    }

    // Pause track (MODIFICADA para usar getCurrentPositionSeconds)
    function pauseTrack(deckNum) {
        const deck = decks[deckNum];
        if (!deck.isPlaying) return;
        
        // --- Lógica del Loop ---
        if (deck.isLooping && deck.loopSource) {
            try { deck.loopSource.stop(); } catch(e) {}
            deck.loopSource.disconnect();
            deck.loopSource = null;
        } else if (deck.source) {
            // Si es reproducción normal
            try { deck.source.stop(); } catch(e) {}
            deck.source.disconnect();
            deck.source = null;
        }
        // --- Fin Lógica del Loop ---
        
        // Play vinyl stop sound
        playVinylSound(deckNum, false);
        
        // Calcular y almacenar el tiempo de pausa usando la función de utilidad
        // CRÍTICO: Guarda la posición exacta con pitch/loop/reverse.
        deck.pauseTime = getCurrentPositionSeconds(deckNum); 
        
        // Update state
        deck.isPlaying = false;
        
        // Update button text
        document.getElementById(`button${deckNum}`).textContent = 'Play';
        
        // Stop platter animation
        document.getElementById(`platter${deckNum}`).classList.remove('playing');
        
        // Stop animation
        cancelAnimationFrame(deck.animationFrame);
    }

    // Seek track (MODIFICADA para limpiar el Loop)
    function seekTrack(deckNum, progress) {
        const deck = decks[deckNum];
        if (!deck.isLoaded) return;

        // *** IMPORTANTE: Desactivar loop al hacer seek ***
        if (deck.isLooping) {
            clearLoop(deckNum); // Esto pausará si estaba sonando y limpiará los markers
        }

        const wasPlaying = deck.isPlaying;
        
        if (wasPlaying) {
            pauseTrack(deckNum);
        }
        
        deck.pauseTime = progress * deck.audioBuffer.duration;
        
        // Update beat position
        updateBeatPosition(deckNum);
        
        if (wasPlaying) {
            playTrack(deckNum);
        } else {
            // Update progress bar
            document.getElementById(`progressBar${deckNum}`).value = progress;
            document.getElementById(`currentTime${deckNum}`).textContent = formatTime(deck.pauseTime);
            drawFullWaveform(deckNum);
        }
    }

    // Navegación por beats (4 tiempos)
    function navigateByBeats(deckNum, beats) {
        if (!decks[deckNum].isLoaded || decks[deckNum].bpm === 0) return;
        
        // Pausar primero para obtener la posición precisa
        if (decks[deckNum].isPlaying) {
             pauseTrack(deckNum);
        }
        
        // Calcular duración de un beat en segundos
        const secondsPerBeat = 60 / decks[deckNum].bpm;
        
        // Calcular nueva posición a partir del pauseTime guardado
        let newPosition = decks[deckNum].pauseTime + (beats * secondsPerBeat);
        
        // Asegurarse de que está dentro de los límites
        if (newPosition < 0) newPosition = 0;
        if (newPosition > decks[deckNum].audioBuffer.duration) newPosition = decks[deckNum].audioBuffer.duration;
        
        decks[deckNum].pauseTime = newPosition;
        
        // Update beat position
        updateBeatPosition(deckNum);
        
        // Reanudar si estaba sonando
        if (decks[deckNum].isPlaying) {
            playTrack(deckNum);
        } else {
            // Actualizar barra de progreso y onda si estaba pausado
            const progress = newPosition / decks[deckNum].audioBuffer.duration;
            document.getElementById(`progressBar${deckNum}`).value = progress;
            document.getElementById(`currentTime${deckNum}`).textContent = formatTime(newPosition);
            drawFullWaveform(deckNum);
        }
    }

    // Update beat position for visualization
    function updateBeatPosition(deckNum) {
        if (!decks[deckNum].isLoaded || decks[deckNum].bpm === 0) return;
        
        // Usamos la posición guardada o actual
        const currentTime = decks[deckNum].isPlaying ? getCurrentPositionSeconds(deckNum) : decks[deckNum].pauseTime;

        // Calcular posición actual en beats
        const secondsPerBeat = 60 / decks[deckNum].bpm;
        decks[deckNum].currentBeat = Math.floor(currentTime / secondsPerBeat);
    }

    // Animate progress bar (MODIFICADA para usar getCurrentPositionSeconds y lógica de fin)
    function animateProgress(deckNum) {
        if (!decks[deckNum].isPlaying) return;
        
        // Obtener el tiempo de reproducción correcto (incluye loop, pitch, reverse)
        const currentTime = getCurrentPositionSeconds(deckNum);
        const duration = decks[deckNum].audioBuffer.duration;
        const progress = currentTime / duration;

        // Si la pista llega al final y no está en loop, detener
        if (currentTime >= duration) {
            // Si estamos en loop, esto no debería ocurrir, ya que el API gestiona el loop.
            // Pero si es reproducción normal, debemos parar.
            if (!decks[deckNum].isLooping) {
                 pauseTrack(deckNum);
                 decks[deckNum].pauseTime = 0; // Reiniciar a 0
                 document.getElementById(`progressBar${deckNum}`).value = 0;
                 document.getElementById(`currentTime${deckNum}`).textContent = formatTime(0);
                 drawFullWaveform(deckNum);
                 return; // Detener la animación aquí
            }
        }
        
        // Update progress bar
        document.getElementById(`progressBar${deckNum}`).value = progress;
        document.getElementById(`currentTime${deckNum}`).textContent = formatTime(currentTime);
        
        // Update beat position
        updateBeatPosition(deckNum);
        
        // Continue animation
        decks[deckNum].animationFrame = requestAnimationFrame(() => animateProgress(deckNum));
    }

    // Format time
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
    }

    // Detect BPM
    function detectBPM(deckNum, audioBuffer) {
        // Simple BPM detection (this is a placeholder)
        // In a real application, you would use a more sophisticated algorithm
        const estimatedBPM = Math.floor(80 + Math.random() * 60);
        decks[deckNum].bpm = estimatedBPM;
        document.getElementById(`bpmDisplay${deckNum}`).textContent = `${estimatedBPM} BPM`;
    }

    // Sync BPM
    function sync(deckNum) {
        const otherDeckNum = deckNum === 1 ? 2 : 1;
        
        if (!decks[otherDeckNum].isLoaded) return;
        
        // Set pitch to match other deck's BPM
        const targetBPM = decks[otherDeckNum].bpm;
        const currentBPM = decks[deckNum].bpm;
        
        if (currentBPM > 0) {
            const ratio = targetBPM / currentBPM;
            document.getElementById(`pitch${deckNum}`).value = ratio;
            
            // Reajustar inmediatamente el playbackRate
            if (decks[deckNum].source) {
                decks[deckNum].source.playbackRate.value = ratio;
            } else if (decks[deckNum].loopSource) {
                 // Si está en loop reverso, la tasa es negativa
                 const rate = decks[deckNum].isReversed ? -ratio : ratio;
                 decks[deckNum].loopSource.playbackRate.value = rate;
            }
        }
    }

    // Toggle EQ band
    function toggleEQ(band, deckNum) {
        const isEnabled = decks[deckNum].eqState[band];
        
        if (isEnabled) {
            // Kill the band por completo
            decks[deckNum].eq[band].gain.value = -40;
            decks[deckNum].eqState[band] = false;
        } else {
            // Restaurar la banda al valor previo
            decks[deckNum].eq[band].gain.value = decks[deckNum].eqValue[band];
            decks[deckNum].eqState[band] = true;
        }
    }

    // Start reverse (MODIFICADA para usar la nueva lógica de tiempo)
    function startReverse(deckNum) {
        if (!decks[deckNum].isLoaded) return;

        // Si ya estaba en reversa, no hacer nada
        if (decks[deckNum].isReversed) return;
        
        // Pausar primero para obtener la posición precisa
        const wasPlaying = decks[deckNum].isPlaying;
        if (wasPlaying) {
            pauseTrack(deckNum);
        }
        
        // Si hay un loop activo, se desactiva al entrar en reversa para evitar bugs
        if (decks[deckNum].isLooping) {
            clearLoop(deckNum); // Llama a clearLoop, que ya pausa si es necesario.
        } else {
            // El tiempo de pausa ya está en la posición *real* de la pista
            // Al activar reverse, el nuevo pauseTime debe ser: Duración - Posición Actual
            decks[deckNum].pauseTime = decks[deckNum].audioBuffer.duration - decks[deckNum].pauseTime;
        }
        
        decks[deckNum].isReversed = true;

        if (wasPlaying) {
            playTrack(deckNum);
        }
    }

    // Stop reverse (MODIFICADA para usar la nueva lógica de tiempo)
    function stopReverse(deckNum) {
        if (!decks[deckNum].isLoaded || !decks[deckNum].isReversed) return;

        // Pausar primero para obtener la posición precisa
        const wasPlaying = decks[deckNum].isPlaying;
        if (wasPlaying) {
            pauseTrack(deckNum);
        }
        
        // El pauseTime actual es la posición dentro del buffer reverso
        // La nueva posición real en la pista es: Duración - Posición Buffer Reverso
        decks[deckNum].pauseTime = decks[deckNum].audioBuffer.duration - decks[deckNum].pauseTime;

        decks[deckNum].isReversed = false;

        if (wasPlaying) {
            playTrack(deckNum);
        }
    }

    // Toggle hot cue (MODIFICADA para usar getCurrentPositionSeconds)
    function toggleHotCue(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        
        if (decks[deckNum].hotCue === null) {
            // Set hot cue
            const currentTime = getCurrentPositionSeconds(deckNum);
            
            decks[deckNum].hotCue = currentTime;
            
            // Create visual marker
            createHotCueMarker(deckNum, currentTime);
            
            document.getElementById(`hotCue${deckNum}`).textContent = 'GoTo';
        } else {
            // Go to hot cue
            seekTrack(deckNum, decks[deckNum].hotCue / decks[deckNum].audioBuffer.duration);
        }
    }

    // Delete hot cue
    function deleteHotCue(deckNum) {
        decks[deckNum].hotCue = null;
        document.getElementById(`hotCue${deckNum}`).textContent = 'HotCue';
        
        // Remove visual marker
        const markers = document.querySelectorAll(`.hot-cue-marker[data-deck="${deckNum}"]`);
        markers.forEach(marker => marker.remove());
    }

    // Create hot cue marker
    function createHotCueMarker(deckNum, time) {
        const progress = time / decks[deckNum].audioBuffer.duration;
        const waveformContainer = document.querySelector(`.waveform-deck-container.deck${deckNum}`);
        
        // Remove existing marker
        const existingMarker = document.querySelector(`.hot-cue-marker[data-deck="${deckNum}"]`);
        if (existingMarker) existingMarker.remove();
        
        // Create new marker
        const marker = document.createElement('div');
        marker.className = 'hot-cue-marker';
        marker.dataset.deck = deckNum;
        marker.style.left = `${progress * 100}%`;
        
        if (waveformContainer) {
            waveformContainer.appendChild(marker);
        }
    }

    // Toggle effect (Mantenida)
    function toggleEffect(deckNum, effect) {
        const button = document.getElementById(`effect${deckNum}-${effect}`);
        
        if (decks[deckNum].effects[effect]) {
            // Disable effect
            decks[deckNum].effects[effect] = false;
            button.classList.remove('active');
            
            // Disconnect effect nodes
            if (effect === 'cut' && decks[deckNum].cutEffect) {
                // ... (lógica de desconexión del cut) ...
                decks[deckNum].cutEffect.disconnect();
                decks[deckNum].cutEffect = null;
            } else if (effect === 'flanger' && decks[deckNum].flangerEffect) {
                // ... (lógica de desconexión del flanger) ...
                decks[deckNum].flangerEffect.disconnect();
                decks[deckNum].flangerEffect = null;
            }
        } else {
            // Enable effect
            decks[deckNum].effects[effect] = true;
            button.classList.add('active');
            
            // Create and connect effect nodes
            if (effect === 'cut') {
                // Create a simple cut effect (mute/unmute rapidly)
                const oscillator = audioContext.createOscillator();
                oscillator.frequency.value = 10; // 10Hz for a choppy effect
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0;
                
                oscillator.connect(gainNode.gain);
                oscillator.start();
                
                // Conectar justo antes del gainNode
                decks[deckNum].filterNode.disconnect();
                decks[deckNum].filterNode.connect(gainNode);
                gainNode.connect(decks[deckNum].gainNode);
                
                decks[deckNum].cutEffect = { oscillator, gainNode };

            } else if (effect === 'flanger') {
                // Create a simple flanger effect
                const delay = audioContext.createDelay();
                delay.delayTime.value = 0.005;
                
                const oscillator = audioContext.createOscillator();
                oscillator.frequency.value = 0.5;
                
                const gain = audioContext.createGain();
                gain.gain.value = 0.002;
                
                oscillator.connect(gain);
                gain.connect(delay.delayTime);
                
                // Conectar la salida del EQ/Filter al delay, y la salida del delay a la cadena
                
                // Desconectar el filterNode para re-enrutar
                decks[deckNum].filterNode.disconnect();
                
                // 1. Conexión principal (Dry signal)
                decks[deckNum].filterNode.connect(decks[deckNum].gainNode);
                
                // 2. Conexión del efecto (Wet signal)
                decks[deckNum].filterNode.connect(delay);
                delay.connect(decks[deckNum].gainNode);
                
                oscillator.start();
                
                decks[deckNum].flangerEffect = { delay, oscillator, gain };
            }
        }
    }

    // Start loop roll (Mantenida)
    function startLoopRoll(deckNum, duration) {
        if (!decks[deckNum].isLoaded || decks[deckNum].isPlaying) return; // Si está sonando, no puede hacer loop roll
        
        // Pausar pista principal
        pauseTrack(deckNum); // Esto guarda el pauseTime actual
        
        const currentTime = decks[deckNum].pauseTime;
        const startTime = currentTime;
        const endTime = startTime + duration;

        // Crear nuevo source en loop
        const source = audioContext.createBufferSource();
        source.buffer = decks[deckNum].audioBuffer;
        source.loop = true;
        source.loopStart = startTime;
        source.loopEnd = endTime;

        // Conectar source
        source.connect(decks[deckNum].eq.bass);

        // Reproducir fragmento
        source.start(0, startTime);
        decks[deckNum].loopRollSource = { source, startTime, duration };
        decks[deckNum].isPlaying = true; // El loop roll se considera reproducción
        decks[deckNum].startTime = audioContext.currentTime;
    }

    // Stop loop roll (Mantenida)
    function stopLoopRoll(deckNum) {
        if (decks[deckNum].loopRollSource) {
            const { source, startTime, duration } = decks[deckNum].loopRollSource;
            const now = audioContext.currentTime;
            const loopDuration = duration;

            // Calcular cuánto tiempo ha avanzado el loop
            const timeElapsed = now - decks[deckNum].startTime;
            const playbackRate = parseFloat(document.getElementById(`pitch${deckNum}`).value);
            const timeInLoop = (timeElapsed * playbackRate) % loopDuration;
            
            source.stop();
            source.disconnect();
            decks[deckNum].loopRollSource = null;

            // Calcular nuevo punto de tiempo real (desde donde debería continuar)
            decks[deckNum].pauseTime = startTime + timeInLoop;
            decks[deckNum].isPlaying = false; // Estado de pausa después del roll

            // Reanudar reproducción normal desde el nuevo punto
            playTrack(deckNum);
        }
    }

    // Toggle superimpose
    function toggleSuperimpose(deckNum) {
        showDeck[deckNum] = !showDeck[deckNum];
    }

    // Animate all canvas elements
    function animate() {
        drawSuperimposedWaveform();
        // Llamar a drawFullWaveform continuamente para actualizar el cabezal de reproducción
        if (decks[1].isLoaded) drawFullWaveform(1);
        if (decks[2].isLoaded) drawFullWaveform(2);
        requestAnimationFrame(animate);
    }

    // draw superimposed waveform for both decks
    function drawSuperimposedWaveform() {
        const width = superCanvas.width;
        const height = superCanvas.height;
        
        superCtx.clearRect(0, 0, width, height);
        
        // draw deck 1 waveform if shown and loaded
        if (showDeck[1] && decks[1].isLoaded && decks[1].waveformData) {
            drawDeckWaveformSegment(1, width, height);
        }
        
        // ...
    }
    
    // Función auxiliar para dibujar un segmento de la onda (la parte que faltaba)
    function drawDeckWaveformSegment(deckNum, width, height) {
        const deck = decks[deckNum];
        const waveformData = deck.waveformData;
        const currentTime = getCurrentPositionSeconds(deckNum);
        const duration = deck.audioBuffer.duration;
        
        const center = height / 2;
        const color = deckNum === 1 ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)';
        
        superCtx.fillStyle = color;
        superCtx.beginPath();
        
        for (let i = 0; i < width; i++) {
            const { min, max } = waveformData[i];
            const x = i;
            const y1 = center - (max * center);
            const y2 = center - (min * center);
            
            superCtx.fillRect(x, y1, 1, y2 - y1);
        }
        
        // Dibuja el cabezal de reproducción (Playhead)
        const currentProgress = currentTime / duration;
        const playHeadX = currentProgress * width;
        
        superCtx.fillStyle = '#FFFFFF'; // Color blanco para el cabezal
        superCtx.fillRect(playHeadX - 1, 0, 2, height);
    }
    
    // Ejecutar init al cargar la página
    window.addEventListener('load', init);
// =========================================================================
// === FIN DEL CONTROLADOR DJ ===
// =========================================================================
    
</script>
</body>
</html>
