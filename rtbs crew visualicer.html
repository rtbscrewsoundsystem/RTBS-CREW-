<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTBS CREW - FINAL BOSS VISUALIZER V6.0</title>
    <style>
        :root {
            --color-primary: #00ff41;
            --color-secondary: #0080ff;
            --win-blue: #000080;
            --retro-gray: #c0c0c0;
            --dark-gray: #404040;
        }

        body {
            background: #000; color: var(--color-primary); font-family: 'Courier New', monospace;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; margin: 0; overflow: hidden; text-transform: uppercase;
        }

        body::after {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), url('https://grainy-gradients.vercel.app/noise.svg');
            background-size: 100% 2px, auto; opacity: 0.05; pointer-events: none;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box; z-index: 10;
        }

        .win-panel {
            background: var(--retro-gray); border: 3px solid;
            border-color: #fff #808080 #808080 #fff;
            padding: 10px; color: #000; box-shadow: 5px 5px 0 rgba(0,0,0,0.5);
        }

        .win-title {
            background: var(--win-blue); color: #fff; padding: 3px 8px;
            font-weight: bold; margin-bottom: 10px; display: flex; justify-content: space-between;
        }

        .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }

        button {
            background: var(--retro-gray); border: 2px solid;
            border-color: #fff #808080 #808080 #fff;
            padding: 5px 15px; cursor: pointer; font-family: 'Courier New', monospace;
            font-weight: bold; transition: 0.1s;
        }

        button:active { border-color: #808080 #fff #fff #808080; transform: translate(1px, 1px); }

        #visual-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        input[type="range"] { accent-color: var(--win-blue); cursor: pointer; }

        .stat-box { font-size: 12px; border: 2px inset #fff; padding: 5px; background: #eee; }
        
        #song-info { font-weight: bold; font-size: 18px; color: var(--win-blue); }
    </style>
</head>
<body>

    <canvas id="visual-canvas"></canvas>

    <div id="ui-layer">
        <div class="win-panel" style="width: fit-content;">
            <div class="win-title"><span>SYSTEM_INFO.EXE</span><span>[X]</span></div>
            <div id="song-info">RTBS_CREW_READY...</div>
            <div id="time-info" class="stat-box">TIME: <span id="cur-time">0:00</span> / <span id="dur-time">0:00</span></div>
        </div>

        <div class="win-panel">
            <div class="win-title"><span>MEDIA_PLAYER_CONTROLS</span><span>[_]</span></div>
            <div class="controls">
                <input type="file" id="audio-upload" accept="audio/*" style="display:none">
                <button onclick="document.getElementById('audio-upload').click()">[LOAD_FILE]</button>
                <button id="play-btn">[PLAY]</button>
                <button id="mode-btn">[MODE]</button>
                <button id="color-btn">[PALETTE]</button>
                <input type="range" id="timeline" value="0" style="flex-grow:1">
            </div>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('visual-canvas');
    const ctx = canvas.getContext('2d');
    const audio = new Audio();
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let source, analyser, dataArray;

    // LISTA DE MODOS CORREGIDA
    const modes = ['bars', 'wave', 'cyber', 'radial', 'plasma', 'acidwarp', 'bassquake', 'spiralcore', 'strobegrid', 'fracture', 'raverays', 'subpulse', 'neuroflow', 'overdrive'];
    let currentMode = 'bars';
    
    let colorA = '#00ff41', colorB = '#0080ff';
    const palettes = [
        ['#00ff41', '#0080ff'], ['#ff0000', '#ffff00'], 
        ['#ff00ff', '#00ffff'], ['#ffffff', '#444444']
    ];
    let currentPalette = 0;

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.onresize = resize;
    resize();

    document.getElementById('audio-upload').onchange = function(e) {
        const file = e.target.files[0];
        if(!file) return;
        document.getElementById('song-info').innerText = file.name.toUpperCase();
        audio.src = URL.createObjectURL(file);
        setupAudio();
    };

    function setupAudio() {
        if(!source) {
            source = audioCtx.createMediaElementSource(audio);
            analyser = audioCtx.createAnalyser();
            source.connect(analyser);
            analyser.connect(audioCtx.destination);
            analyser.fftSize = 256;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            draw();
        }
    }

    document.getElementById('play-btn').onclick = () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        audio.paused ? audio.play() : audio.pause();
        document.getElementById('play-btn').innerText = audio.paused ? '[PLAY]' : '[PAUSE]';
    };

    document.getElementById('mode-btn').onclick = () => {
        let idx = (modes.indexOf(currentMode) + 1) % modes.length;
        currentMode = modes[idx];
    };

    document.getElementById('color-btn').onclick = () => {
        currentPalette = (currentPalette + 1) % palettes.length;
        colorA = palettes[currentPalette][0];
        colorB = palettes[currentPalette][1];
    };

    let rot = 0;
    function draw() {
        requestAnimationFrame(draw);
        analyser.getByteFrequencyData(dataArray);

        ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        rot += 0.01;

        if (currentMode === 'bars') {
            const barWidth = canvas.width / dataArray.length;
            for(let i=0; i<dataArray.length; i++) {
                let h = dataArray[i] * 1.5;
                ctx.fillStyle = i%2 ? colorA : colorB;
                ctx.fillRect(i*barWidth, canvas.height - h, barWidth-1, h);
            }
        } 
        else if (currentMode === 'wave') {
            ctx.beginPath();
            ctx.strokeStyle = colorA;
            ctx.lineWidth = 3;
            for(let i=0; i<dataArray.length; i++) {
                ctx.lineTo(i * (canvas.width/dataArray.length), cy + (dataArray[i]-128));
            }
            ctx.stroke();
        }
        else if (currentMode === 'cyber') {
            ctx.fillStyle = colorA;
            for(let i=0; i<dataArray.length; i+=20) {
                ctx.fillRect((i/dataArray.length)*canvas.width, cy, 10, -dataArray[i]);
                ctx.fillRect((i/dataArray.length)*canvas.width, cy, 10, dataArray[i]);
            }
        }
        else if (currentMode === 'radial') {
            ctx.save(); ctx.translate(cx, cy);
            for(let i=0; i<80; i++){
                ctx.rotate((Math.PI*2)/80); ctx.fillStyle = colorA;
                ctx.fillRect(80, 0, dataArray[i%50]/2, 2);
            }
            ctx.restore();
        }
        else if (currentMode === 'plasma') {
            ctx.save(); ctx.translate(cx, cy);
            for(let i=0; i<120; i++){
                let a = i*0.15 + rot;
                let r = dataArray[i%dataArray.length]*1.2;
                ctx.fillStyle = `hsla(${r*2},100%,50%,0.3)`;
                ctx.beginPath();
                ctx.arc(Math.cos(a)*r, Math.sin(a)*r, 4, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }
        else if (currentMode === 'acidwarp') {
            ctx.save(); ctx.translate(cx, cy);
            for(let i=0;i<dataArray.length;i+=6){
                let s = dataArray[i]/2;
                ctx.rotate(0.02);
                ctx.strokeStyle = i%12?colorA:colorB;
                ctx.strokeRect(-s/2,-s/2,s,s);
            }
            ctx.restore();
        }
        else if (currentMode === 'bassquake') {
            let bass = dataArray[2];
            ctx.save();
            ctx.translate((Math.random()-0.5)*bass*0.2, (Math.random()-0.5)*bass*0.2);
            ctx.strokeStyle = colorA;
            ctx.strokeRect(50,50,canvas.width-100,canvas.height-100);
            ctx.restore();
        }
        else if (currentMode === 'spiralcore') {
            ctx.save(); ctx.translate(cx, cy);
            for(let i=0;i<100;i++){
                let a = i*0.3 + rot*4;
                let r = i*3 + dataArray[i%50];
                ctx.fillStyle = i%2?colorA:colorB;
                ctx.fillRect(Math.cos(a)*r,Math.sin(a)*r,3,3);
            }
            ctx.restore();
        }
        else if (currentMode === 'strobegrid') {
            let kick = dataArray[1];
            if(kick>180){
                ctx.fillStyle = colorA;
                ctx.fillRect(0,0,canvas.width,canvas.height);
            }
            ctx.strokeStyle = colorB;
            for(let x=0;x<canvas.width;x+=40){
                for(let y=0;y<canvas.height;y+=40){
                    ctx.strokeRect(x,y,20,20);
                }
            }
        }
        else if (currentMode === 'fracture') {
            for(let i=0;i<50;i++){
                ctx.fillStyle = i%2?colorA:colorB;
                ctx.fillRect(Math.random()*canvas.width, Math.random()*canvas.height, dataArray[i]*0.3, 4);
            }
        }
        else if (currentMode === 'raverays') {
            ctx.save(); ctx.translate(cx, cy);
            for(let i=0;i<60;i++){
                ctx.rotate(Math.PI/30);
                ctx.strokeStyle = i%2?colorA:colorB;
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(200+dataArray[i],0); ctx.stroke();
            }
            ctx.restore();
        }
        else if (currentMode === 'subpulse') {
            let b = dataArray[0]*2;
            ctx.beginPath();
            ctx.strokeStyle = colorA;
            ctx.arc(cx,cy,b,0,Math.PI*2);
            ctx.stroke();
        }
        else if (currentMode === 'neuroflow') {
            ctx.strokeStyle = colorB;
            ctx.beginPath();
            for(let i=0;i<dataArray.length;i++){
                ctx.lineTo((i/dataArray.length)*canvas.width, cy + Math.sin(i*0.1+rot*3)*dataArray[i]);
            }
            ctx.stroke();
        }
        else if (currentMode === 'overdrive') {
            let o = dataArray[5];
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.drawImage(canvas, o - 50, 0);
            ctx.globalAlpha = 1;
            ctx.restore();
        }
    }

    audio.ontimeupdate = () => { 
        if(!isNaN(audio.duration)) {
            document.getElementById('timeline').value = audio.currentTime; 
            document.getElementById('cur-time').innerText = Math.floor(audio.currentTime/60)+":"+Math.floor(audio.currentTime%60).toString().padStart(2,'0'); 
        }
    };
    audio.onloadedmetadata = () => { 
        document.getElementById('timeline').max = audio.duration; 
        document.getElementById('dur-time').innerText = Math.floor(audio.duration/60)+":"+Math.floor(audio.duration%60).toString().padStart(2,'0'); 
    };
    document.getElementById('timeline').oninput = (e) => audio.currentTime = e.target.value;
    </script>
</body>
</html>
