<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>RTBS CREW - V12.0 FINAL REPAIR</title>
    <style>
        :root { --p: #00ff41; --s: #0080ff; --bg: #c0c0c0; --win: #000080; }
        body { background: #000; color: var(--p); font-family: 'Courier New', monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; }
        .monitor { border: 4px solid var(--bg); background: var(--bg); padding: 2px; box-shadow: 10px 10px 0 #000; width: 90vw; max-width: 800px; }
        .screen { background: #000; height: 600px; display: flex; flex-direction: column; position: relative; border: 2px solid #000; }
        header { background: linear-gradient(90deg, var(--win), #0080ff); color: #fff; padding: 4px; font-size: 11px; display: flex; justify-content: space-between; font-weight: bold; }
        canvas { width: 100%; flex-grow: 1; cursor: crosshair; }
        
        .timeline-container { background: #000; padding: 10px; border-top: 1px solid var(--p); display: flex; align-items: center; gap: 10px; }
        #timeline { flex: 1; cursor: pointer; accent-color: var(--p); }

        .popup { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 500px; background: var(--bg); border: 3px solid #fff; padding: 15px; z-index: 100; display: none; color: #000; box-shadow: 0 0 40px #000; }
        .eq-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; margin: 10px 0; }
        .v-slider { appearance: slider-vertical; width: 100%; height: 80px; background: #000; }
        
        .controls { background: var(--bg); padding: 10px; display: flex; gap: 8px; border-top: 2px solid #404040; }
        button { font-family: 'Courier New'; font-weight: bold; font-size: 10px; padding: 6px; cursor: pointer; background: var(--bg); border: 2px solid; border-color: #fff #404040 #404040 #fff; }
        button:active { border-color: #404040 #fff #fff #404040; }
        
        .modes-container { display: flex; gap: 10px; height: 300px; }
        .modes-list { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; max-height: 300px; overflow-y: auto; flex: 1; }
        .modes-nav { display: flex; flex-direction: column; gap: 5px; }
        .modes-nav button { width: 35px; height: 35px; padding: 0; font-size: 18px; display: flex; align-items: center; justify-content: center; }
        
        /* Estilo para el botón del modo que está sonando/activo */
        .mode-selected { background: #ffeb3b !important; color: #000 !important; border: 2px inset #000 !important; }
    </style>
</head>
<body>

<div class="monitor">
    <div class="screen">
        <header><span>RTBS_SYSTEM_V12.0_STABLE</span><span id="cur-mode-txt">MODE: BARS</span></header>
        <canvas id="v"></canvas>

        <div class="timeline-container">
            <span id="time-curr" style="font-size:10px">0:00</span>
            <input type="range" id="timeline" value="0" min="0" step="0.1">
            <span id="time-total" style="font-size:10px">0:00</span>
        </div>

        <div id="pop-settings" class="popup">
            <b style="font-size:12px">COLOR CONFIG</b>
            <div style="margin: 10px 0; display: flex; gap: 20px;">
                C1: <input type="color" id="c1" value="#00ff41">
                C2: <input type="color" id="c2" value="#0080ff">
            </div>
            <b style="font-size:12px">20-BAND EQUALIZER</b>
            <div class="eq-grid" id="eq-1"></div>
            <div class="eq-grid" id="eq-2"></div>
            <div style="display: flex; gap: 5px;">
                <button onclick="resetEQ()" style="flex:1; background:#ffeb3b">RESET EQ (0dB)</button>
                <button onclick="togglePop('pop-settings')" style="flex:1; background:#f44336; color:#fff">CLOSE</button>
            </div>
        </div>

        <div id="pop-modes" class="popup">
            <b style="font-size:12px">MODOS DE VISUALIZACIÓN</b>
            <div class="modes-container">
                <div class="modes-nav">
                    <button id="nav-prev" onclick="navigateModes(-1)">▲</button>
                    <div style="flex: 1; text-align: center;"><span id="page-indicator" style="font-size: 10px;">1/1</span></div>
                    <button id="nav-next" onclick="navigateModes(1)">▼</button>
                </div>
                <div class="modes-list" id="modes-grid"></div>
            </div>
            <button onclick="togglePop('pop-modes')" style="width:100%; margin-top:10px; background:#4CAF50; color:white;">OK / VOLVER</button>
        </div>

        <div class="controls">
            <input type="file" id="file" accept="audio/*" style="font-size:9px; flex:1">
            <button id="btn-play" style="background:var(--p)">POWER/PLAY</button>
            <button onclick="togglePop('pop-settings')" style="background:#ffcc00">EQ/COLOR</button>
            <button onclick="togglePop('pop-modes')" style="background:var(--s); color:#fff">MODES</button>
        </div>
    </div>
</div>

<script>
    const audio = new Audio();
    const canvas = document.getElementById('v'), ctx = canvas.getContext('2d');
    const timeline = document.getElementById('timeline');
    let audioCtx, analyser, dataArray, filters = [], initialized = false;
    let currentMode = 'bars', colorA = "#00ff41", colorB = "#0080ff", rot = 0;

    // Lista de todos los modos unificados
    const modes = [
      'bars', 'rave', 'dna', 'tunnel', 'matrix', 'vortex', 'radial', 'laser', 'wave', 
      'hex', 'stars', 'rings', 'dots', 'flower', 'glitch', 'cyber', 'nebula', 
      'oscilloscope', 'spectrum', 'grid', 'pulse', 'orbit', 'chaos', 'psycho_sphere', 
      'liquid_dream', 'fractal_tree', 'chrome_whirl', 'ghost_pulse',
      'quantum_lines', 'echo_ribbons', 'void_spiral', 'neon_cage', 'plasma_cells',
      'sound_mandala', 'bit_crusher', 'holo_wave', 'spectral_rain', 'audio_constellation',
      'energy_core', 'mirror_bass', 'time_fracture', 'digital_smoke', 'pulse_grid',
      'frequency_blades', 'audio_tentacles', 'broken_signal', 'sonic_orbitals',
      'liquid_mirror', 'vector_storm', 'bass_blackhole', 'neural_pulse', 'data_flow',
      'audio_fabric', 'spectral_sun', 'cyber_fog', 'harmonic_shell', 'bass_inferno',
      'echo_particles', 'time_rings', 'audio_prism', 'glow_maze', 'cosmic_noise',
      'milkdrop', 'kaleidorave', 'feedbackwarp', 'oscillo3d', 'winampclassic', 'rtbs_finalboss',
      'milknebula','kaleidofeedback','bassgod','crt_void','spiralstorm',
      'neurokaleido','warpdrive','subdimension','hallucinate','rtbs_omega','dual_vinyl_chaos'
    ];

    let currentPage = 0;
    const MODES_PER_PAGE = 12;

    function renderModesPage() {
        const mGrid = document.getElementById('modes-grid');
        mGrid.innerHTML = '';
        const start = currentPage * MODES_PER_PAGE;
        const end = Math.min(start + MODES_PER_PAGE, modes.length);
        
        for (let i = start; i < end; i++) {
            const m = modes[i];
            const btn = document.createElement('button');
            btn.innerText = m.toUpperCase();
            
            // Si es el modo activo, añadir la clase de color especial
            if (m === currentMode) {
                btn.classList.add('mode-selected');
            }

            btn.onclick = () => {
                currentMode = m;
                document.getElementById('cur-mode-txt').innerText = "MODE: " + m.toUpperCase();
                renderModesPage(); // Re-renderizar para actualizar el color del botón seleccionado
            };
            mGrid.appendChild(btn);
        }
        
        const totalPages = Math.ceil(modes.length / MODES_PER_PAGE);
        document.getElementById('page-indicator').innerText = `PAG ${currentPage + 1}/${totalPages}`;
        document.getElementById('nav-prev').disabled = currentPage === 0;
        document.getElementById('nav-next').disabled = currentPage >= totalPages - 1;
    }

    function navigateModes(dir) {
        const totalPages = Math.ceil(modes.length / MODES_PER_PAGE);
        currentPage += dir;
        if (currentPage < 0) currentPage = 0;
        if (currentPage >= totalPages) currentPage = totalPages - 1;
        renderModesPage();
    }

    // --- Inicialización EQ ---
    const fVals = [32, 64, 125, 250, 500, 750, 1000, 1500, 2000, 2500, 3000, 4000, 5000, 6000, 8000, 10000, 12000, 14000, 16000, 18000];
    fVals.forEach((f, i) => {
        const target = i < 10 ? 'eq-1' : 'eq-2';
        const d = document.createElement('div');
        d.innerHTML = `<input type="range" class="v-slider" id="f-${i}" min="-20" max="20" value="0" oninput="changeF(${i}, this.value)"><div style="font-size:6px;text-align:center">${f<1000?f:f/1000+'k'}</div>`;
        document.getElementById(target).appendChild(d);
    });

    function togglePop(id) {
        const p = document.getElementById(id);
        const isOpen = p.style.display === 'block';
        p.style.display = isOpen ? 'none' : 'block';
        if (id === 'pop-modes' && !isOpen) {
            renderModesPage(); // Renderizar solo al abrir para mantener la página
        }
    }

    function changeF(i, v) { if(filters[i]) filters[i].gain.value = v; }
    function resetEQ() { filters.forEach((f, i) => { f.gain.value = 0; document.getElementById(`f-${i}`).value = 0; }); }

    document.getElementById('c1').oninput = (e) => colorA = e.target.value;
    document.getElementById('c2').oninput = (e) => colorB = e.target.value;
    document.getElementById('file').onchange = (e) => {
        if(e.target.files[0]) audio.src = URL.createObjectURL(e.target.files[0]);
    };

    audio.onloadedmetadata = () => { 
        timeline.max = audio.duration; 
        document.getElementById('time-total').innerText = formatT(audio.duration); 
    };
    audio.ontimeupdate = () => { 
        if(!dragging) { 
            timeline.value = audio.currentTime; 
            document.getElementById('time-curr').innerText = formatT(audio.currentTime); 
        } 
    };

    let dragging = false;
    timeline.oninput = () => { dragging = true; document.getElementById('time-curr').innerText = formatT(timeline.value); };
    timeline.onchange = () => { audio.currentTime = timeline.value; dragging = false; };

    function formatT(s) { 
        let m = Math.floor(s/60); 
        s = Math.floor(s%60); 
        return m + ":" + (s<10?'0':'')+s; 
    }

    document.getElementById('btn-play').onclick = () => {
        if (!initialized) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            let src = audioCtx.createMediaElementSource(audio);
            let prev = src;
            fVals.forEach((f, i) => {
                const flt = audioCtx.createBiquadFilter(); flt.type = "peaking"; flt.frequency.value = f;
                filters.push(flt); prev.connect(flt); prev = flt;
            });
            analyser = audioCtx.createAnalyser(); analyser.fftSize = 1024;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            prev.connect(analyser); analyser.connect(audioCtx.destination);
            initialized = true; loop();
        }
        audio.paused ? audio.play() : audio.pause();
    };

    function loop() {
        requestAnimationFrame(loop);
        const trail = ['psycho_sphere', 'liquid_dream', 'rave', 'vortex', 'milknebula', 'kaleidofeedback', 'warpdrive'].includes(currentMode) ? 0.15 : 0.8;
        ctx.fillStyle = `rgba(0,0,0,${trail})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const isTimeDomain = ['wave', 'oscilloscope', 'chaos', 'pulse', 'glitch'].includes(currentMode);
        isTimeDomain ? analyser.getByteTimeDomainData(dataArray) : analyser.getByteFrequencyData(dataArray);

        const cx = canvas.width/2, cy = canvas.height/2; rot += 0.02;
        ctx.lineWidth = 2; ctx.strokeStyle = colorA; ctx.fillStyle = colorA;

        // LÓGICA DE MODOS
        if (currentMode === 'bars') {
            for(let i=0; i<80; i++){ ctx.fillStyle = i%2?colorA:colorB; let h = (dataArray[i]/255)*canvas.height; ctx.fillRect(i*(canvas.width/80), canvas.height-h, (canvas.width/80)-1, h); }
        }
        else if (currentMode === 'wave' || currentMode === 'oscilloscope') {
            ctx.beginPath(); for(let i=0; i<dataArray.length; i++){ let x = (i/dataArray.length)*canvas.width, y = (dataArray[i]/255)*canvas.height; i===0?ctx.moveTo(x,y):ctx.lineTo(x,y); } ctx.stroke();
        }
        else if (currentMode === 'rave') {
            ctx.save(); ctx.translate(cx,cy); ctx.rotate(rot); for(let i=0; i<dataArray.length; i+=10){ ctx.strokeStyle = i%20?colorA:colorB; ctx.beginPath(); ctx.arc(0,0,dataArray[i]*0.8,0,Math.PI*2); ctx.stroke(); ctx.rotate(0.02); } ctx.restore();
        }
        else if (currentMode === 'milknebula') {
            ctx.save(); ctx.translate(cx, cy); ctx.scale(1.01,1.01); ctx.rotate(rot*0.2); ctx.drawImage(canvas,-cx,-cy); ctx.restore();
            ctx.globalAlpha = 0.4; for(let i=0;i<120;i++){ let a = i*0.15+rot; let r = dataArray[i]*1.3; ctx.fillStyle = `hsla(${r+rot*80},100%,50%,0.4)`; ctx.beginPath(); ctx.arc(cx+Math.cos(a)*r,cy+Math.sin(a)*r,3,0,Math.PI*2); ctx.fill(); } ctx.globalAlpha = 1;
        }
        else if (currentMode === 'kaleidofeedback') {
            ctx.save(); ctx.translate(cx,cy); ctx.rotate(rot*0.5); ctx.scale(1.02,1.02); ctx.drawImage(canvas,-cx,-cy); ctx.restore();
            ctx.save(); ctx.translate(cx,cy); for(let i=0;i<12;i++){ ctx.rotate(Math.PI/6); ctx.strokeStyle = i%2?colorA:colorB; ctx.beginPath(); for(let j=0;j<60;j++){ let r = dataArray[j]*1.4; ctx.lineTo(r,Math.sin(j*0.3+rot)*r); } ctx.stroke(); } ctx.restore();
        }
        else if (currentMode === 'bassgod') {
            let b = dataArray[1]/255; ctx.save(); ctx.translate(cx,cy); ctx.scale(1+b*0.4,1+b*0.4); ctx.rotate(b*0.3); ctx.drawImage(canvas,-cx,-cy); ctx.restore();
            ctx.strokeStyle = colorA; ctx.lineWidth = 3; ctx.strokeRect(cx-200*b,cy-200*b,400*b,400*b);
        }
        else if (currentMode === 'crt_void') {
            ctx.drawImage(canvas,1,0); ctx.globalAlpha = 0.1; ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.globalAlpha = 1;
            ctx.strokeStyle = colorB; for(let y=0;y<canvas.height;y+=4){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
        }
        else if (currentMode === 'spiralstorm') {
            ctx.save(); ctx.translate(cx,cy); for(let i=0;i<160;i++){ let a=i*0.2+rot*3; let r=i*2+dataArray[i%60]; ctx.fillStyle=i%2?colorA:colorB; ctx.fillRect(Math.cos(a)*r,Math.sin(a)*r,3,3); } ctx.restore();
        }
        else if (currentMode === 'neurokaleido') {
            ctx.save(); ctx.translate(cx,cy); for(let s=0;s<10;s++){ ctx.rotate(Math.PI/5); ctx.strokeStyle=s%2?colorA:colorB; ctx.beginPath(); for(let i=0;i<80;i++){ let x = dataArray[i]; let y = Math.sin(i*0.2+rot*2)*x; ctx.lineTo(x,y); } ctx.stroke(); } ctx.restore();
        }
        else if (currentMode === 'warpdrive') {
            let k=dataArray[2]/255; ctx.save(); ctx.translate(cx,cy); ctx.rotate((k-0.5)*0.4); ctx.scale(1+k*0.3,1+k*0.3); ctx.drawImage(canvas,-cx,-cy); ctx.restore();
        }
        else if (currentMode === 'subdimension') {
            let s=dataArray[0]*2; ctx.strokeStyle=colorA; ctx.beginPath(); ctx.arc(cx,cy,s,0,Math.PI*2); ctx.stroke();
            ctx.save(); ctx.translate((Math.random()-0.5)*s*0.05,(Math.random()-0.5)*s*0.05); ctx.drawImage(canvas,0,0); ctx.restore();
        }
        else if (currentMode === 'hallucinate') {
            ctx.drawImage(canvas,Math.sin(rot)*5,Math.cos(rot)*5); ctx.globalAlpha=0.2; ctx.fillStyle=colorB; ctx.fillRect(0, Math.random()*canvas.height, canvas.width, 3); ctx.globalAlpha=1;
        }
        else if (currentMode === 'rtbs_omega') {
            let sub=dataArray[0]/255; let kick=dataArray[2]/255; ctx.save(); ctx.translate(cx,cy); ctx.rotate((sub-0.5)*0.2); ctx.scale(1+kick*0.5,1+kick*0.5); ctx.drawImage(canvas,-cx,-cy); ctx.restore();
            ctx.strokeStyle=colorA; ctx.lineWidth=2; ctx.beginPath(); for(let i=0;i<dataArray.length;i++){ let x=(i/dataArray.length)*canvas.width; let y=cy+Math.sin(i*0.15+rot*5)*dataArray[i]; i===0?ctx.moveTo(x,y):ctx.lineTo(x,y); } ctx.stroke(); if(kick>0.8){ ctx.fillStyle=colorB; ctx.fillRect(0,0,canvas.width,canvas.height); }
        }
        else if (currentMode === 'dual_vinyl_chaos') {
            let sub = dataArray[0] / 255; let kick = dataArray[2] / 255; let mid = dataArray[10] / 255; let platterSize = Math.min(canvas.width, canvas.height) * 0.22; let leftX = cx - platterSize * 1.3; let rightX = cx + platterSize * 1.3; let rotL = rot * (1 + sub * 6) + Math.sin(rot * 4) * kick * 3; let rotR = -rot * (1 + mid * 5) + Math.cos(rot * 3) * kick * 3;
            ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.fillRect(0,0,canvas.width,canvas.height);
            function drawVinyl(x, rotation, mainColor, accentColor) { ctx.save(); ctx.translate(x, cy); ctx.rotate(rotation); ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(0,0,platterSize,0,Math.PI*2); ctx.fill(); for(let i=0;i<25;i++){ ctx.strokeStyle = `rgba(255,255,255,${0.02 + mid*0.08})`; ctx.beginPath(); ctx.arc(0,0,platterSize - i*6,0,Math.PI*2); ctx.stroke(); } ctx.fillStyle = mainColor; ctx.beginPath(); ctx.arc(0,0,platterSize*0.25,0,Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill(); ctx.strokeStyle = accentColor; ctx.lineWidth = 2 + kick*4; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(platterSize,0); ctx.stroke(); ctx.restore(); }
            drawVinyl(leftX, rotL, colorA, colorB); drawVinyl(rightX, rotR, colorB, colorA); if(kick > 0.6){ ctx.save(); ctx.translate((Math.random()-0.5)*kick*20,(Math.random()-0.5)*kick*20); ctx.drawImage(canvas,0,0); ctx.restore(); }
        }
        else if (currentMode === 'dna') {
            for(let i=0; i<dataArray.length; i+=6){ ctx.fillStyle = i%12?colorA:colorB; let y = cy + Math.sin(i*0.1+rot*4)*(dataArray[i]/2); ctx.fillRect((i/dataArray.length)*canvas.width, y, 4, 4); }
        }
        else if (currentMode === 'matrix') {
            ctx.font = "10px monospace"; for(let i=0; i<dataArray.length; i+=15){ ctx.fillStyle = dataArray[i]>150?colorA:colorB; ctx.fillText(Math.floor(Math.random()*9), (i/dataArray.length)*canvas.width, (dataArray[i]/255)*canvas.height); }
        }
        else if (currentMode === 'vortex') {
            ctx.save(); ctx.translate(cx, cy); for(let i = 0; i < 80; i += 2) { ctx.strokeStyle = i % 4 === 0 ? colorA : colorB; ctx.beginPath(); ctx.arc(0, 0, 30 + i * 2, rot + i * 0.1, rot + i * 0.1 + Math.PI/2); ctx.stroke(); } ctx.restore();
        }
        // ... El resto de los 70+ modos siguen aquí por defecto si no están definidos arriba ...
        else {
            // Un renderizado genérico para los modos que faltan por definir individualmente
            ctx.beginPath(); for(let i=0; i<dataArray.length; i+=2){ let x = (i/dataArray.length)*canvas.width, y = cy - (dataArray[i]/2); ctx.lineTo(x,y); } ctx.stroke();
        }
    }

    function resize() { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }
    window.onresize = resize; resize();
    renderModesPage();
</script>
</body>
</html>
