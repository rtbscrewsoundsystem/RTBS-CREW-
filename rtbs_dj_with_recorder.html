<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>RTBS CREW DJ CONTROLLER MIX - MOD</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
/* --- Estilos principales de la mesa de DJ --- */
body { margin:0; font-family:'Comic Sans MS', cursive, sans-serif; background: black; color: #FFFF00; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
.container { display: flex; flex-direction: column; gap: 20px; padding: 20px; background: #111; border-radius: 10px; border: 2px solid #333; width: 90%; max-width: 1200px; margin: auto; position: relative; }
h1 { text-align: center; margin-top: 0; }
.waveforms-container-top { position: relative; width: 100%; height: 100px; background: #000; border: 2px solid #00f; border-radius: 5px; overflow: hidden; }
#superimposedWaveformCanvas { width: 100%; height: 100%; display:block; }
.waveforms-dual-container { display: flex; justify-content: space-between; gap: 10px; }
.waveform-deck-container { width: 100%; height: 80px; background: #222; border: 2px solid #00f; border-radius: 5px; overflow: hidden; position: relative; }
.waveform-deck-container.deck1 { border-color: #00FF00; }
.waveform-deck-container.deck2 { border-color: #FF0000; }
.hot-cue-marker { position: absolute; width: 2px; height: 100%; background: #0080FF; top: 0; pointer-events:none; z-index:5; }
#waveformCanvas1, #waveformCanvas2 { width: 100%; height: 100%; display:block; }
.decks-container { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; gap: 20px; }
.deck { display: flex; flex-direction: column; align-items: center; gap: 10px; width: auto; position: relative; z-index:1; }
.deck h3 { display: flex; align-items: center; gap: 5px; }
.bpm-display { font-size: 12px; color: #00FF00; }
.platter { width: 120px; height: 120px; background: #222; border-radius: 50%; border: 4px solid #00f; box-shadow: 0 0 10px #00f; display: flex; justify-content: center; align-items: center; position: relative; z-index:2; }
.platter-inner { width: 60px; height: 60px; background: #080; border-radius: 50%; border: 2px solid #00f; display: flex; align-items: center; justify-content: center; font-size: 10px; }
.controls { display: flex; flex-direction: column; align-items: center; gap: 10px; width: 100%; }
.buttons { display: flex; gap: 10px; z-index:3; position: relative; }
.button { width: 60px; height: 30px; background: #080; border: 2px solid #00f; border-radius: 5px; display: flex; justify-content: center; align-items: center; cursor: pointer; user-select:none; }
.crossfader-container { margin-top: 20px; text-align: center; position:relative; z-index:3; }
#crossfader { width: 90%; }
.control-block {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    padding: 10px;
    border: 1px solid #444;
    border-radius: 8px;
    background: #222;
}
.eq-group {
    display: flex;
    justify-content: space-around;
    width: 100%;
    gap: 15px;
}
.eq-control {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.eq-control label { font-size: 12px; font-weight: bold; }
.rotary-knob {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    width: 60px;
    height: 60px;
    transform: rotate(270deg);
}
.rotary-knob::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; height: 20px; width: 20px; background-color: #00f; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); margin-top: -10px; }
.rotary-knob::-moz-range-thumb { height: 20px; width: 20px; background-color: #00f; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 5px rgba(0, 0, 0, 0.5); }
.rotary-knob::-webkit-slider-runnable-track { background: #555; height: 5px; border-radius: 5px; }
.rotary-knob::-moz-range-track { background: #555; height: 5px; border-radius: 5px; }
.eq-on-off { width: 40px; height: 20px; border: 2px solid #00f; background: #333; color: #fff; font-size: 8px; cursor: pointer; border-radius: 5px; }
.vertical-fader-container { height: 120px; width: 20px; position: relative; }
.vertical-fader {
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    width: 120px;
    height: 20px;
    transform-origin: center;
    transform: rotate(270deg);
}
.vertical-fader::-webkit-slider-runnable-track { background: #555; height: 8px; border-radius: 5px; }
.vertical-fader::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; margin-top: -4px; }
.vertical-fader::-moz-range-thumb { width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; }
.progress-container { width: 100%; display: flex; flex-direction: column; gap: 5px; z-index: 10; padding: 5px; margin-top: 10px; }
.progress-bar { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: #555; border-radius: 5px; cursor: pointer; }
.progress-bar::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; }
.progress-bar::-moz-range-thumb { width: 16px; height: 16px; background: #00FF00; border-radius: 50%; border: 2px solid #fff; }
.time-display { display: flex; justify-content: space-between; font-size: 10px; }
.platter.playing { animation: spin 2s linear infinite; }
.platter.paused { animation-play-state: paused; }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
#equalizer-popup { display: none; flex-direction: column; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; border: 2px solid #808080; padding: 10px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); z-index: 1000; flex-direction: column; align-items: center; }
#equalizer-popup h3 { color: #0080FF; margin-top: 5px; margin-bottom: 10px; }
.eq-container { display: flex; flex-direction: column; gap: 10px; }
.eq-row { display: flex; justify-content: center; gap: 5px; }
.band { display: flex; flex-direction: column; align-items: center; width: 20px; }
.band label { font-size: 8px; color: #fff; margin-top: 5px; }
.band input[type="range"] { -webkit-appearance: slider-vertical; width: 20px; height: 120px; background: #0080FF; }
.close-btn { background: #FF0000; color: #fff; border: none; padding: 5px; cursor: pointer; margin-top: 10px; font-size: 12px; }
.loop-pads { display: flex; gap: 5px; margin-top: 10px; justify-content: center; width: 100%; }
.loop-pad { width: 45px; height: 45px; background: #005080; border: 2px solid #00f; border-radius: 5px; display: flex; justify-content: center; align-items: center; cursor: pointer; font-size: 10px; font-weight: bold; user-select: none; }
.loop-pad:active, .loop-pad.active { background: #00aaff; box-shadow: 0 0 10px #00aaff; }
#settingsButton { position: absolute; top: 10px; right: 10px; width: 40px; height: 40px; background: transparent; border: null; cursor: pointer; font-size: 30px; color: #fff; text-shadow: 0 0 5px #00f; z-index:4; }
#settingsPopup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; border: 2px solid #808080; padding: 20px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); z-index: 1001; flex-direction: column; align-items: center; gap: 15px; }
.settings-section { display: flex; flex-direction: column; gap: 5px; }
.settings-section label { font-size: 14px; font-weight: bold; }
.settings-section select { background: #333; color: #FFFF00; border: 1px solid #00f; padding: 5px; }
.deck-flex-container { display: flex; justify-content: center; align-items: flex-end; width: 100%; gap: 10px; }
.deck-controls-left { display: flex; flex-direction: column; align-items: center; gap: 10px; position: relative; }
.deck-center-controls { display: flex; flex-direction: column; align-items: center; gap: 10px; }
.hot-cues-and-reverse { display: flex; flex-direction: column; align-items: center; gap: 5px; }
.reverse-button { background: #FF0000; color: #fff; border: 2px solid #fff; cursor: pointer; user-select:none; }
.reverse-button.active { background: #ff7700; box-shadow: 0 0 10px #ff7700; }
.effects-platter-container { display: flex; flex-direction: column; align-items: center; gap: 5px; padding: 10px; border: 1px solid #444; border-radius: 8px; background: #222; z-index:2; }
.effect-button-platter { width: 40px; height: 40px; background: #500050; border: 2px solid #FF00FF; border-radius: 5px; color: #fff; font-size: 8px; text-align: center; line-height: 40px; cursor: pointer; user-select:none; }
.effect-button-platter.active { background: #ff00ff; box-shadow: 0 0 10px #ff00ff; }
.top-waveform-indicator { position: absolute; left: 50%; top: 0; width: 2px; height: 100%; background: #fff; z-index: 15; pointer-events:none; }
.center-controls-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    padding: 15px;
    background: #222;
    border: 1px solid #444;
    border-radius: 10px;
    margin-left: auto;
    margin-right: auto;
    width: 340px;
    z-index:3;
}
.fader-effects-container {
    display: flex;
    gap: 20px;
    justify-content: center;
    width: 100%;
}
.effect-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.effect-button-platter {
    width: 40px;
    height: 40px;
    background: #500050;
    border: 2px solid #FF00FF;
    border-radius: 5px;
    color: #fff;
    font-size: 8px;
    text-align: center;
    line-height: 40px;
    cursor: pointer;
    user-select:none;
}
.effect-button-platter.active {
    background: #ff00ff;
    box-shadow: 0 0 10px #ff00ff;
}
/* Ensure crossfader doesn't cover buttons */
.crossfader-container, .buttons { z-index: 3; }

/* Botones de navegación rápida */
.navigation-buttons {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}
.nav-button {
    width: 50px;
    height: 25px;
    background: #333;
    border: 1px solid #00f;
    border-radius: 3px;
    color: #fff;
    font-size: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
}
.nav-button:active {
    background: #555;
}
</style>
</head>
<body>

<div class="container">
    <button id="settingsButton" onclick="toggleSettingsPopup()">⚙️</button>
    <h1>RTBS CREW DJ CONTROLLER MIX — MOD</h1>

    <div class="waveforms-container-top">
        <canvas id="superimposedWaveformCanvas"></canvas>
        <div class="top-waveform-indicator"></div>
    </div>

    <div class="decks-container">
        <div class="deck" data-deck="1">
            <h3>Plato 1 <span id="bpmDisplay1" class="bpm-display"></span></h3>
            <div class="platter" id="platter1" onclick="toggleSuperimpose(1)">
                <div class="platter-inner">Plato 1</div>
            </div>
            <input type="file" id="fileInput1" accept="audio/*">
            <div class="progress-container">
                <input type="range" id="progressBar1" class="progress-bar" min="0" max="1" step="0.001" value="0">
                <div class="time-display">
                    <span id="currentTime1">0:00</span>
                    <span id="duration1">0:00</span>
                </div>
            </div>
            <div class="waveform-deck-container deck1">
                <canvas id="waveformCanvas1"></canvas>
            </div>
            
            <div class="navigation-buttons">
                <div class="nav-button" onclick="navigateByBeats(1, -4)">-4 B</div>
                <div class="nav-button" onclick="navigateByBeats(1, 4)">+4 B</div>
            </div>
            
            <div class="loop-pads" id="loopPads1">
                <div class="loop-pad" data-value="0.125" onmousedown="startLoopRoll(1, 0.125)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/8</div>
                <div class="loop-pad" data-value="0.0625" onmousedown="startLoopRoll(1, 0.0625)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/16</div>
                <div class="loop-pad" data-value="0.25" onmousedown="startLoopRoll(1, 0.25)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/4</div>
                <div class="loop-pad" data-value="0.5" onmousedown="startLoopRoll(1, 0.5)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1/2</div>
                <div class="loop-pad" data-value="1" onmousedown="startLoopRoll(1, 1)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">1</div>
                <div class="loop-pad" data-value="2" onmousedown="startLoopRoll(1, 2)" onmouseup="stopLoopRoll(1)" onmouseleave="stopLoopRoll(1)">2</div>
            </div>
            
            <div class="deck-flex-container">
                <div class="deck-controls-left">
                    <div class="control-block">
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>B</label>
                                <input type="range" id="bass1" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>M</label>
                                <input type="range" id="mid1" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>T</label>
                                <input type="range" id="treble1" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                        </div>
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>Ganancia</label>
                                <input type="range" id="gain1" min="0" max="2" step="0.01" value="1" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>Filtro</label>
                                <input type="range" id="filter1" min="20" max="22050" step="1" value="22050" class="rotary-knob">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: center; gap: 10px;">
                            <button class="eq-on-off" onclick="toggleEQ('bass', 1)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('mid', 1)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('treble', 1)">Kill</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="center-controls-container">
            <div class="fader-effects-container">
                <div class="vertical-fader-container">
                    <input type="range" id="volume1" min="0" max="1" step="0.01" value="0.7" class="vertical-fader">
                </div>
                <div class="effect-group">
                    <h4>Efectos 1</h4>
                    <button class="effect-button-platter" id="effect1-cut" onclick="toggleEffect(1, 'cut')">CUT</button>
                    <button class="effect-button-platter" id="effect1-flanger" onclick="toggleEffect(1, 'flanger')">FLNG</button>
                </div>
                <div class="vertical-fader-container">
                    <input type="range" id="volume2" min="0" max="1" step="0.01" value="0.7" class="vertical-fader">
                </div>
                <div class="effect-group">
                    <h4>Efectos 2</h4>
                    <button class="effect-button-platter" id="effect2-cut" onclick="toggleEffect(2, 'cut')">CUT</button>
                    <button class="effect-button-platter" id="effect2-flanger" onclick="toggleEffect(2, 'flanger')">FLNG</button>
                </div>
            </div>

            <div class="pitch-controls">
                <label>Pitch 1</label>
                <input type="range" id="pitch1" min="0.5" max="2" step="0.01" value="1">
                <label>Pitch 2</label>
                <input type="range" id="pitch2" min="0.5" max="2" step="0.01" value="1">
            </div>
            <div class="buttons">
                <div class="button" id="button1" onclick="playPause(1)">Play</div>
                <div class="button" id="sync1" onclick="sync(1)">Sync</div>
                <div class="button" id="button2" onclick="playPause(2)">Play</div>
                <div class="button" id="sync2" onclick="sync(2)">Sync</div>
            </div>
            
            <div class="crossfader-container">
                <span>Crossfader</span><br>
                <input type="range" id="crossfader" min="0" max="1" step="0.01" value="0.5">
            </div>
            
            <div class="hot-cues-and-reverse">
                <div style="display:flex; gap:8px; align-items:center;">
                    <div>
                        <button class="hot-cue-button button" id="hotCue1" onclick="toggleHotCue(1)">HotCue</button>
                        <div style="font-size:10px; text-align:center;">Guardar / Ir</div>
                    </div>
                    <div>
                        <button class="button" id="deleteHotCue1" onclick="deleteHotCue(1)">Eliminar</button>
                        <div style="font-size:10px; text-align:center;">Eliminar hotcue</div>
                    </div>
                    <div>
                        <button class="hot-cue-button button" id="hotCue2" onclick="toggleHotCue(2)">HotCue</button>
                        <div style="font-size:10px; text-align:center;">Guardar / Ir</div>
                    </div>
                    <div>
                        <button class="button" id="deleteHotCue2" onclick="deleteHotCue(2)">Eliminar</button>
                        <div style="font-size:10px; text-align:center;">Eliminar hotcue</div>
                    </div>
                </div>
                <div style="margin-top:8px;">
                    <button class="button reverse-button" id="reverse1" onmousedown="startReverse(1)" onmouseup="stopReverse(1)" onmouseleave="stopReverse(1)">Reverse 1 (hold)</button>
                    <button class="button reverse-button" id="reverse2" onmousedown="startReverse(2)" onmouseup="stopReverse(2)" onmouseleave="stopReverse(2)">Reverse 2 (hold)</button>
                </div>
            </div>
        </div>

        <div class="deck" data-deck="2">
            <h3>Plato 2 <span id="bpmDisplay2" class="bpm-display"></span></h3>
            <div class="platter" id="platter2" onclick="toggleSuperimpose(2)">
                <div class="platter-inner">Plato 2</div>
            </div>
            <input type="file" id="fileInput2" accept="audio/*">
            <div class="progress-container">
                <input type="range" id="progressBar2" class="progress-bar" min="0" max="1" step="0.001" value="0">
                <div class="time-display">
                    <span id="currentTime2">0:00</span>
                    <span id="duration2">0:00</span>
                </div>
            </div>
            <div class="waveform-deck-container deck2">
                <canvas id="waveformCanvas2"></canvas>
            </div>
            
            <div class="navigation-buttons">
                <div class="nav-button" onclick="navigateByBeats(2, -4)">-4 B</div>
                <div class="nav-button" onclick="navigateByBeats(2, 4)">+4 B</div>
            </div>
            
            <div class="loop-pads" id="loopPads2">
                <div class="loop-pad" data-value="0.125" onmousedown="startLoopRoll(2, 0.125)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/8</div>
                <div class="loop-pad" data-value="0.0625" onmousedown="startLoopRoll(2, 0.0625)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/16</div>
                <div class="loop-pad" data-value="0.25" onmousedown="startLoopRoll(2, 0.25)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/4</div>
                <div class="loop-pad" data-value="0.5" onmousedown="startLoopRoll(2, 0.5)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1/2</div>
                <div class="loop-pad" data-value="1" onmousedown="startLoopRoll(2, 1)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">1</div>
                <div class="loop-pad" data-value="2" onmousedown="startLoopRoll(2, 2)" onmouseup="stopLoopRoll(2)" onmouseleave="stopLoopRoll(2)">2</div>
            </div>
            
            <div class="deck-flex-container">
                <div class="deck-controls-left">
                    <div class="control-block">
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>B</label>
                                <input type="range" id="bass2" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>M</label>
                                <input type="range" id="mid2" min="-20" max="20" value="0" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>T</label>
                                <input type="range" id="treble2" min="-20" max; max="20" value="0" class="rotary-knob">
                            </div>
                        </div>
                        <div class="eq-group">
                            <div class="eq-control">
                                <label>Ganancia</label>
                                <input type="range" id="gain2" min="0" max="2" step="0.01" value="1" class="rotary-knob">
                            </div>
                            <div class="eq-control">
                                <label>Filtro</label>
                                <input type="range" id="filter2" min="20" max="22050" step="1" value="22050" class="rotary-knob">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: center; gap: 10px;">
                            <button class="eq-on-off" onclick="toggleEQ('bass', 2)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('mid', 2)">Kill</button>
                            <button class="eq-on-off" onclick="toggleEQ('treble', 2)">Kill</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div style="text-align: center; margin-top: 20px; display: flex; justify-content: center; gap: 10px;">
        <button onclick="toggleEqualizerPopup()">Ecualizador de 30 bandas</button>
        <div class="button" id="recordButton" onclick="toggleRecording()" style="width: auto;">Grabar</div>
        <div class="button" id="saveButton" onclick="saveRecording()" style="width: auto; background: #FF5733; display: none;">Guardar</div>
    </div>
</div>

<div id="equalizer-popup">
    <h3>Ecualizador de 30 bandas</h3>
    <div class="eq-container">
        <div class="eq-row" id="row1"></div>
        <div class="eq-row" id="row2"></div>
    </div>
    <button class="close-btn" onclick="toggleEqualizerPopup()">Cerrar</button>
</div>

<div id="settingsPopup">
    <h3>Ajustes de Sonido y MIDI</h3>
    <div class="settings-section">
        <label for="audioOutputSelector">Salida de Sonido:</label>
        <select id="audioOutputSelector"></select>
    </div>
    <div class="settings-section">
        <label for="midiInputSelector">Controlador MIDI:</label>
        <select id="midiInputSelector"></select>
    </div>
    <div class="settings-section">
        <label for="waveformStyleSelector">Visualizador de Onda:</label>
        <select id="waveformStyleSelector">
            <option value="default">Verde y Rojo</option>
            <option value="blue-orange">Azul y Naranja</option>
            <option value="rainbow">Arcoíris</option>
            <option value="mono">Monocromático</option>
            <option value="gradient">Degradado</option>
            <option value="bars">Barras</option>
            <option value="dots">Puntos</option>
            <option value="outline">Contorno</option>
        </select>
    </div>

    <div class="settings-section">
        <label for="recordingSourceSelector">Fuente de Grabación:</label>
        <select id="recordingSourceSelector">
            <option value="master">Salida Master (Línea)</option>
            <option value="mic">Micrófono</option>
        </select>
    </div>
    
    <div class="settings-section">
        <label for="midiMappingSelector">Mapeo MIDI:</label>
        <select id="midiMappingSelector">
            <option value="default">Por Defecto</option>
            <option value="traktor">Traktor</option>
            <option value="serato">Serato</option>
            <option value="rekordbox">Rekordbox</option>
            <option value="virtualdj">VirtualDJ</option>
            <option value="custom">Personalizado</option>
        </select>
    </div>

    <button class="close-btn" onclick="applySettings()">Aplicar</button>
    <button class="close-btn" onclick="toggleSettingsPopup()">Cerrar</button>
</div>

<script>
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let decks = {
        1: {
            audio: null,
            audioBuffer: null,
            source: null,
            gainNode: audioContext.createGain(),
            filterNode: audioContext.createBiquadFilter(),
            analyser: null,
            isPlaying: false,
            startTime: 0,
            pauseTime: 0,
            isReversed: false,
            reversedBuffer: null,
            eq: { bass: audioContext.createBiquadFilter(), mid: audioContext.createBiquadFilter(), treble: audioContext.createBiquadFilter() },
            isLoaded: false,
            animationFrame: null,
            eqState: { bass: true, mid: true, treble: true },
            eqValue: { bass: 0, mid: 0, treble: 0 },
            bpm: 0,
            loopRollSource: null,
            vinylBrakeInterval: null,
            hotCue: null,
            effects: { cut: false, flanger: false },
            vinylStartSound: null,
            vinylStopSound: null,
            // Efectos
            cutEffect: null,
            flangerEffect: null,
            // Para el visualizador superior
            waveformData: null,
            currentBeat: 0
        },
        2: {
            audio: null,
            audioBuffer: null,
            source: null,
            gainNode: audioContext.createGain(),
            filterNode: audioContext.createBiquadFilter(),
            analyser: null,
            isPlaying: false,
            startTime: 0,
            pauseTime: 0,
            isReversed: false,
            reversedBuffer: null,
            eq: { bass: audioContext.createBiquadFilter(), mid: audioContext.createBiquadFilter(), treble: audioContext.createBiquadFilter() },
            isLoaded: false,
            animationFrame: null,
            eqState: { bass: true, mid: true, treble: true },
            eqValue: { bass: 0, mid: 0, treble: 0 },
            bpm: 0,
            loopRollSource: null,
            vinylBrakeInterval: null,
            hotCue: null,
            effects: { cut: false, flanger: false },
            vinylStartSound: null,
            vinylStopSound: null,
            // Efectos
            cutEffect: null,
            flangerEffect: null,
            // Para el visualizador superior
            waveformData: null,
            currentBeat: 0
        }
    };
    let mediaRecorder;
    let recordedChunks = [];
    let analyserMaster = audioContext.createAnalyser(); analyserMaster.fftSize = 2048;
    let showDeck = {1:true,2:true}; // control which deck wave is superimposed
    
    let recordingStream;
    let isRecording = false;
    let activeRecordingSource = 'master';
    let currentWaveformStyle = 'default';

    // 30-band equalizer
    const frequencies = [
        32, 64, 125, 250, 500, 1000, 2000, 4000, 8000, 16000,
        31, 62, 125, 250, 500, 1000, 2000, 4000, 8000, 16000,
        20, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240
    ];
    const eqNodes = [];
    let globalEqFilters = [];
    const row1 = document.getElementById('row1');
    const row2 = document.getElementById('row2');

    const superCanvas = document.getElementById('superimposedWaveformCanvas');
    const superCtx = superCanvas.getContext('2d');

    // Cargar sonidos de inicio y parada de vinilo
    async function loadVinylSounds() {
        try {
            // Crear sonidos sintéticos para inicio y parada de vinilo
            const createVinylSound = (fadeIn, duration) => {
                const sampleRate = audioContext.sampleRate;
                const length = sampleRate * duration;
                const buffer = audioContext.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < length; i++) {
                    // Ruido blanco
                    let value = Math.random() * 2 - 1;
                    
                    // Aplicar filtro de paso bajo para simular ruido de vinilo
                    if (i > 0) {
                        value = 0.95 * data[i-1] + 0.05 * value;
                    }
                    
                    // Aplicar envolvente
                    let envelope;
                    if (fadeIn) {
                        envelope = Math.min(1, i / (sampleRate * 0.1)); // Fade in rápido
                    } else {
                        envelope = Math.max(0, 1 - (i / (sampleRate * 0.3))); // Fade out más lento
                    }
                    
                    data[i] = value * envelope * 0.3;
                }
                
                return buffer;
            };
            
            decks[1].vinylStartSound = createVinylSound(true, 0.2);
            decks[1].vinylStopSound = createVinylSound(false, 0.5);
            decks[2].vinylStartSound = createVinylSound(true, 0.2);
            decks[2].vinylStopSound = createVinylSound(false, 0.5);
        } catch (error) {
            console.error("Error creating vinyl sounds:", error);
        }
    }

    // Reproducir sonido de vinilo
    function playVinylSound(deckNum, isStart) {
        if (!decks[deckNum]) return;
        
        const buffer = isStart ? decks[deckNum].vinylStartSound : decks[deckNum].vinylStopSound;
        if (!buffer) return;
        
        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(audioContext.destination);
        source.start();
    }

    // Inicializar ecualizador de 30 bandas
    function init30BandEQ() {
        // Clear existing nodes
        while (globalEqFilters.length > 0) {
            const filter = globalEqFilters.pop();
            filter.disconnect();
        }
        
        // Create new filters
        for (let i = 0; i < frequencies.length; i++) {
            const filter = audioContext.createBiquadFilter();
            filter.type = 'peaking';
            filter.frequency.value = frequencies[i];
            filter.Q.value = 1;
            filter.gain.value = 0;
            
            // Connect in series
            if (i === 0) {
                analyserMaster.connect(filter);
            } else {
                globalEqFilters[i-1].connect(filter);
            }
            
            globalEqFilters.push(filter);
            
            // Create UI controls
            const band = document.createElement('div');
            band.className = 'band';
            
            const input = document.createElement('input');
            input.type = 'range';
            input.min = '-20';
            input.max = '20';
            input.value = '0';
            input.dataset.index = i;
            input.addEventListener('input', (e) => {
                const index = parseInt(e.target.dataset.index);
                globalEqFilters[index].gain.value = parseFloat(e.target.value);
            });
            
            const label = document.createElement('label');
            label.textContent = `${frequencies[i]}Hz`;
            
            band.appendChild(input);
            band.appendChild(label);
            
            if (i < 15) {
                row1.appendChild(band);
            } else {
                row2.appendChild(band);
            }
        }
        
        // Connect the last filter to destination
        globalEqFilters[globalEqFilters.length - 1].connect(audioContext.destination);
    }

    // Initialize the application
    function init() {
        // Set up audio routing
        analyserMaster.connect(audioContext.destination);
        
        // Initialize 30-band EQ
        init30BandEQ();
        
        // Load vinyl sounds
        loadVinylSounds();
        
        // Set up file inputs
        document.getElementById('fileInput1').addEventListener('change', (e) => handleFileSelect(e, 1));
        document.getElementById('fileInput2').addEventListener('change', (e) => handleFileSelect(e, 2));
        
        // Set up controls
        setupControls();
        
        // Set up canvas dimensions
        setupCanvasDimensions();
        
        // Set up MIDI
        setupMIDI();
        
        // Start animation
        animate();
        
        // Set up recording
        setupRecording();
    }

    // Set up controls
    function setupControls() {
        // Volume controls
        document.getElementById('volume1').addEventListener('input', (e) => {
            decks[1].gainNode.gain.value = parseFloat(e.target.value);
        });
        document.getElementById('volume2').addEventListener('input', (e) => {
            decks[2].gainNode.gain.value = parseFloat(e.target.value);
        });
        
        // EQ controls
        ['bass', 'mid', 'treble'].forEach((band) => {
            for (let i = 1; i <= 2; i++) {
                document.getElementById(`${band}${i}`).addEventListener('input', (e) => {
                    decks[i].eq[band].gain.value = parseFloat(e.target.value);
                    decks[i].eqValue[band] = parseFloat(e.target.value);
                });
            }
        });
        
        // Gain controls
        document.getElementById('gain1').addEventListener('input', (e) => {
            decks[1].gainNode.gain.value = parseFloat(e.target.value);
        });
        document.getElementById('gain2').addEventListener('input', (e) => {
            decks[2].gainNode.gain.value = parseFloat(e.target.value);
        });
        
        // Filter controls
        document.getElementById('filter1').addEventListener('input', (e) => {
            decks[1].filterNode.frequency.value = parseFloat(e.target.value);
        });
        document.getElementById('filter2').addEventListener('input', (e) => {
            decks[2].filterNode.frequency.value = parseFloat(e.target.value);
        });
        
        // Pitch controls
        document.getElementById('pitch1').addEventListener('input', (e) => {
            if (decks[1].source) {
                decks[1].source.playbackRate.value = parseFloat(e.target.value);
            }
        });
        document.getElementById('pitch2').addEventListener('input', (e) => {
            if (decks[2].source) {
                decks[2].source.playbackRate.value = parseFloat(e.target.value);
            }
        });
        
        // Crossfader
        document.getElementById('crossfader').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            // Adjust volumes based on crossfader position
            decks[1].gainNode.gain.value = value < 0.5 ? 1 : 1 - ((value - 0.5) * 2);
            decks[2].gainNode.gain.value = value > 0.5 ? 1 : value * 2;
        });
        
        // Progress bars
        document.getElementById('progressBar1').addEventListener('input', (e) => {
            if (decks[1].isLoaded) {
                seekTrack(1, parseFloat(e.target.value));
            }
        });
        document.getElementById('progressBar2').addEventListener('input', (e) => {
            if (decks[2].isLoaded) {
                seekTrack(2, parseFloat(e.target.value));
            }
        });
    }

    // Set up canvas dimensions
    function setupCanvasDimensions() {
        const canvases = [
            document.getElementById('superimposedWaveformCanvas'),
            document.getElementById('waveformCanvas1'),
            document.getElementById('waveformCanvas2')
        ];
        
        canvases.forEach(canvas => {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        });
    }

    // Handle file selection
    async function handleFileSelect(event, deckNum) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Store audio buffer
            decks[deckNum].audioBuffer = audioBuffer;
            decks[deckNum].isLoaded = true;
            
            // Preprocess waveform data for the top visualizer
            preprocessWaveformData(deckNum, audioBuffer);
            
            // Create reversed buffer
            createReversedBuffer(deckNum, audioBuffer);
            
            // Create analyser
            decks[deckNum].analyser = audioContext.createAnalyser();
            decks[deckNum].analyser.fftSize = 2048;
            
            // Set up audio routing
            setupAudioRouting(deckNum);
            
            // Draw waveform
            drawFullWaveform(deckNum);
            
            // Update duration display
            const duration = formatTime(audioBuffer.duration);
            document.getElementById(`duration${deckNum}`).textContent = duration;
            
            // Detect BPM
            detectBPM(deckNum, audioBuffer);
            
        } catch (error) {
            console.error('Error loading audio file:', error);
        }
    }

    // Preprocess waveform data for the top visualizer
    function preprocessWaveformData(deckNum, audioBuffer) {
        const channelData = audioBuffer.getChannelData(0);
        const samplesPerPixel = Math.floor(channelData.length / superCanvas.width);
        decks[deckNum].waveformData = [];
        
        for (let i = 0; i < superCanvas.width; i++) {
            let min = 0;
            let max = 0;
            
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = i * samplesPerPixel + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            
            decks[deckNum].waveformData.push({ min, max });
        }
    }

    // Create reversed audio buffer
    function createReversedBuffer(deckNum, audioBuffer) {
        const reversedBuffer = audioContext.createBuffer(
            audioBuffer.numberOfChannels,
            audioBuffer.length,
            audioBuffer.sampleRate
        );
        
        for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
            const originalData = audioBuffer.getChannelData(channel);
            const reversedData = reversedBuffer.getChannelData(channel);
            
            for (let i = 0; i < audioBuffer.length; i++) {
                reversedData[i] = originalData[audioBuffer.length - 1 - i];
            }
        }
        
        decks[deckNum].reversedBuffer = reversedBuffer;
    }

    // Set up audio routing
    function setupAudioRouting(deckNum) {
        // Set up EQ
        decks[deckNum].eq.bass.type = 'lowshelf';
        decks[deckNum].eq.bass.frequency.value = 250;
        
        decks[deckNum].eq.mid.type = 'peaking';
        decks[deckNum].eq.mid.frequency.value = 1000;
        decks[deckNum].eq.mid.Q.value = 1;
        
        decks[deckNum].eq.treble.type = 'highshelf';
        decks[deckNum].eq.treble.frequency.value = 4000;
        
        // Set up filter
        decks[deckNum].filterNode.type = 'lowpass';
        decks[deckNum].filterNode.frequency.value = 22050;
        
        // Connect nodes
        decks[deckNum].eq.bass.connect(decks[deckNum].eq.mid);
        decks[deckNum].eq.mid.connect(decks[deckNum].eq.treble);
        decks[deckNum].eq.treble.connect(decks[deckNum].filterNode);
        decks[deckNum].filterNode.connect(decks[deckNum].gainNode);
        decks[deckNum].gainNode.connect(decks[deckNum].analyser);
        decks[deckNum].analyser.connect(analyserMaster);
    }

    // Draw full waveform
    function drawFullWaveform(deckNum) {
        const canvas = document.getElementById(`waveformCanvas${deckNum}`);
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        ctx.clearRect(0, 0, width, height);
        
        if (!decks[deckNum].audioBuffer) return;
        
        const audioBuffer = decks[deckNum].audioBuffer;
        const channelData = audioBuffer.getChannelData(0);
        const step = Math.ceil(channelData.length / width);
        
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        
        // Choose color based on deck
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        
        for (let i = 0; i < width; i++) {
            let min = 0;
            let max = 0;
            
            for (let j = 0; j < step; j++) {
                const index = i * step + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            
            ctx.lineTo(i, height / 2 - min * height / 2);
            ctx.lineTo(i, height / 2 - max * height / 2);
        }
        
        ctx.stroke();
    }

    // Play/Pause track
    function playPause(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        
        if (decks[deckNum].isPlaying) {
            pauseTrack(deckNum);
        } else {
            playTrack(deckNum);
        }
    }

    // Play track
    function playTrack(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        
        // Play vinyl start sound
        playVinylSound(deckNum, true);
        
        const source = audioContext.createBufferSource();
        
        if (decks[deckNum].isReversed) {
            source.buffer = decks[deckNum].reversedBuffer;
        } else {
            source.buffer = decks[deckNum].audioBuffer;
        }
        
        // Set playback rate
        source.playbackRate.value = parseFloat(document.getElementById(`pitch${deckNum}`).value);
        
        // Connect source to audio chain
        source.connect(decks[deckNum].eq.bass);
        
        // Store source
        decks[deckNum].source = source;
        
        // Calculate start time
        let startTime;
        if (decks[deckNum].pauseTime > 0) {
            startTime = audioContext.currentTime - decks[deckNum].pauseTime;
        } else {
            startTime = audioContext.currentTime;
        }
        
        // Start playback
        source.start(0, decks[deckNum].pauseTime);
        
        // Update state
        decks[deckNum].isPlaying = true;
        decks[deckNum].startTime = startTime;
        
        // Update button text
        document.getElementById(`button${deckNum}`).textContent = 'Pause';
        
        // Start platter animation
        document.getElementById(`platter${deckNum}`).classList.add('playing');
        
        // Start animation for progress bar
        cancelAnimationFrame(decks[deckNum].animationFrame);
        animateProgress(deckNum);
    }

    // Pause track
    function pauseTrack(deckNum) {
        if (!decks[deckNum].isPlaying || !decks[deckNum].source) return;
        
        // Play vinyl stop sound
        playVinylSound(deckNum, false);
        
        // Stop source
        decks[deckNum].source.stop();
        decks[deckNum].source.disconnect();
        
        // Calculate pause time
        decks[deckNum].pauseTime = audioContext.currentTime - decks[deckNum].startTime;
        
        // Update state
        decks[deckNum].isPlaying = false;
        
        // Update button text
        document.getElementById(`button${deckNum}`).textContent = 'Play';
        
        // Stop platter animation
        document.getElementById(`platter${deckNum}`).classList.remove('playing');
        
        // Stop animation
        cancelAnimationFrame(decks[deckNum].animationFrame);
    }

    // Seek track
    function seekTrack(deckNum, progress) {
        const wasPlaying = decks[deckNum].isPlaying;
        
        if (wasPlaying) {
            pauseTrack(deckNum);
        }
        
        decks[deckNum].pauseTime = progress * decks[deckNum].audioBuffer.duration;
        
        // Update beat position
        updateBeatPosition(deckNum);
        
        if (wasPlaying) {
            playTrack(deckNum);
        } else {
            // Update progress bar
            document.getElementById(`progressBar${deckNum}`).value = progress;
            document.getElementById(`currentTime${deckNum}`).textContent = formatTime(decks[deckNum].pauseTime);
        }
    }

    // Navegación por beats (4 tiempos)
    function navigateByBeats(deckNum, beats) {
        if (!decks[deckNum].isLoaded || decks[deckNum].bpm === 0) return;
        
        const wasPlaying = decks[deckNum].isPlaying;
        
        if (wasPlaying) {
            pauseTrack(deckNum);
        }
        
        // Calcular duración de un beat en segundos
        const secondsPerBeat = 60 / decks[deckNum].bpm;
        
        // Calcular nueva posición
        let newPosition = decks[deckNum].pauseTime + (beats * secondsPerBeat);
        
        // Asegurarse de que está dentro de los límites
        if (newPosition < 0) newPosition = 0;
        if (newPosition > decks[deckNum].audioBuffer.duration) newPosition = decks[deckNum].audioBuffer.duration;
        
        decks[deckNum].pauseTime = newPosition;
        
        // Update beat position
        updateBeatPosition(deckNum);
        
        if (wasPlaying) {
            playTrack(deckNum);
        } else {
            // Actualizar barra de progreso
            const progress = newPosition / decks[deckNum].audioBuffer.duration;
            document.getElementById(`progressBar${deckNum}`).value = progress;
            document.getElementById(`currentTime${deckNum}`).textContent = formatTime(newPosition);
        }
    }

    // Update beat position for visualization
    function updateBeatPosition(deckNum) {
        if (!decks[deckNum].isLoaded || decks[deckNum].bpm === 0) return;
        
        // Calcular posición actual en beats
        const secondsPerBeat = 60 / decks[deckNum].bpm;
        decks[deckNum].currentBeat = Math.floor(decks[deckNum].pauseTime / secondsPerBeat);
    }

    // Animate progress bar
    function animateProgress(deckNum) {
        if (!decks[deckNum].isPlaying) return;
        
        const currentTime = audioContext.currentTime - decks[deckNum].startTime;
        const duration = decks[deckNum].audioBuffer.duration;
        const progress = currentTime / duration;
        
        // Update progress bar
        document.getElementById(`progressBar${deckNum}`).value = progress;
        document.getElementById(`currentTime${deckNum}`).textContent = formatTime(currentTime);
        
        // Update beat position
        updateBeatPosition(deckNum);
        
        // Continue animation
        decks[deckNum].animationFrame = requestAnimationFrame(() => animateProgress(deckNum));
    }

    // Format time
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
    }

    // Detect BPM
    function detectBPM(deckNum, audioBuffer) {
        // Simple BPM detection (this is a placeholder)
        // In a real application, you would use a more sophisticated algorithm
        const estimatedBPM = Math.floor(80 + Math.random() * 60);
        decks[deckNum].bpm = estimatedBPM;
        document.getElementById(`bpmDisplay${deckNum}`).textContent = `${estimatedBPM} BPM`;
    }

    // Sync BPM
    function sync(deckNum) {
        const otherDeckNum = deckNum === 1 ? 2 : 1;
        
        if (!decks[otherDeckNum].isLoaded) return;
        
        // Set pitch to match other deck's BPM
        const targetBPM = decks[otherDeckNum].bpm;
        const currentBPM = decks[deckNum].bpm;
        
        if (currentBPM > 0) {
            const ratio = targetBPM / currentBPM;
            document.getElementById(`pitch${deckNum}`).value = ratio;
            
            if (decks[deckNum].source) {
                decks[deckNum].source.playbackRate.value = ratio;
            }
        }
    }

    // Toggle EQ band
    function toggleEQ(band, deckNum) {
        const isEnabled = decks[deckNum].eqState[band];
        
        if (isEnabled) {
            // Kill the band por completo
            decks[deckNum].eq[band].gain.value = -40;
            decks[deckNum].eqState[band] = false;
        } else {
            // Restaurar la banda al valor previo
            decks[deckNum].eq[band].gain.value = decks[deckNum].eqValue[band];
            decks[deckNum].eqState[band] = true;
        }
    }

    // Start reverse
    function startReverse(deckNum) {
        if (!decks[deckNum].isLoaded) return;

        const currentTime = decks[deckNum].isPlaying ? (audioContext.currentTime - decks[deckNum].startTime) : decks[deckNum].pauseTime;
        
        if (decks[deckNum].isPlaying) {
            pauseTrack(deckNum);
        }

        decks[deckNum].isReversed = true;
        decks[deckNum].pauseTime = decks[deckNum].audioBuffer.duration - currentTime;

        playTrack(deckNum);
    }

    // Stop reverse
    function stopReverse(deckNum) {
        if (!decks[deckNum].isLoaded || !decks[deckNum].isReversed) return;

        const currentTime = decks[deckNum].audioBuffer.duration - decks[deckNum].pauseTime;

        if (decks[deckNum].isPlaying) {
            pauseTrack(deckNum);
        }

        decks[deckNum].isReversed = false;
        decks[deckNum].pauseTime = currentTime;

        playTrack(deckNum);
    }

    // Toggle hot cue
    function toggleHotCue(deckNum) {
        if (!decks[deckNum].isLoaded) return;
        
        if (decks[deckNum].hotCue === null) {
            // Set hot cue
            const currentTime = decks[deckNum].isPlaying ? 
                (audioContext.currentTime - decks[deckNum].startTime) : 
                decks[deckNum].pauseTime;
            
            decks[deckNum].hotCue = currentTime;
            
            // Create visual marker
            createHotCueMarker(deckNum, currentTime);
            
            document.getElementById(`hotCue${deckNum}`).textContent = 'GoTo';
        } else {
            // Go to hot cue
            seekTrack(deckNum, decks[deckNum].hotCue / decks[deckNum].audioBuffer.duration);
        }
    }

    // Delete hot cue
    function deleteHotCue(deckNum) {
        decks[deckNum].hotCue = null;
        document.getElementById(`hotCue${deckNum}`).textContent = 'HotCue';
        
        // Remove visual marker
        const markers = document.querySelectorAll(`.hot-cue-marker[data-deck="${deckNum}"]`);
        markers.forEach(marker => marker.remove());
    }

    // Create hot cue marker
    function createHotCueMarker(deckNum, time) {
        const progress = time / decks[deckNum].audioBuffer.duration;
        const waveformContainer = document.querySelector(`.waveform-deck-container.deck${deckNum}`);
        
        // Remove existing marker
        const existingMarker = document.querySelector(`.hot-cue-marker[data-deck="${deckNum}"]`);
        if (existingMarker) existingMarker.remove();
        
        // Create new marker
        const marker = document.createElement('div');
        marker.className = 'hot-cue-marker';
        marker.dataset.deck = deckNum;
        marker.style.left = `${progress * 100}%`;
        
        waveformContainer.appendChild(marker);
    }

    // Toggle effect
    function toggleEffect(deckNum, effect) {
        const button = document.getElementById(`effect${deckNum}-${effect}`);
        
        if (decks[deckNum].effects[effect]) {
            // Disable effect
            decks[deckNum].effects[effect] = false;
            button.classList.remove('active');
            
            // Disconnect effect nodes
            if (effect === 'cut' && decks[deckNum].cutEffect) {
                decks[deckNum].cutEffect.disconnect();
                decks[deckNum].cutEffect = null;
            } else if (effect === 'flanger' && decks[deckNum].flangerEffect) {
                decks[deckNum].flangerEffect.disconnect();
                decks[deckNum].flangerEffect = null;
            }
        } else {
            // Enable effect
            decks[deckNum].effects[effect] = true;
            button.classList.add('active');
            
            // Create and connect effect nodes
            if (effect === 'cut') {
                // Create a simple cut effect (mute/unmute rapidly)
                const oscillator = audioContext.createOscillator();
                oscillator.frequency.value = 10; // 10Hz for a choppy effect
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0;
                
                oscillator.connect(gainNode.gain);
                oscillator.start();
                
                gainNode.connect(decks[deckNum].gainNode);
                decks[deckNum].cutEffect = gainNode;
            } else if (effect === 'flanger') {
                // Create a simple flanger effect
                const delay = audioContext.createDelay();
                delay.delayTime.value = 0.005;
                
                const oscillator = audioContext.createOscillator();
                oscillator.frequency.value = 0.5;
                
                const gain = audioContext.createGain();
                gain.gain.value = 0.002;
                
                oscillator.connect(gain);
                gain.connect(delay.delayTime);
                
                delay.connect(decks[deckNum].gainNode);
                oscillator.start();
                
                decks[deckNum].flangerEffect = delay;
            }
        }
    }

    // Start loop roll
    function startLoopRoll(deckNum, duration) {
        if (!decks[deckNum].isLoaded || !decks[deckNum].isPlaying) return;

        // Pausar pista principal
        pauseTrack(deckNum);

        const currentTime = decks[deckNum].pauseTime;
        const startTime = currentTime;
        const endTime = startTime + duration;

        // Crear nuevo source en loop
        const source = audioContext.createBufferSource();
        source.buffer = decks[deckNum].audioBuffer;
        source.loop = true;
        source.loopStart = startTime;
        source.loopEnd = endTime;

        // Conectar source
        source.connect(decks[deckNum].eq.bass);

        // Reproducir fragmento
        source.start(0, startTime);
        decks[deckNum].loopRollSource = { source, startTime };
    }

    // Stop loop roll
    function stopLoopRoll(deckNum) {
        if (decks[deckNum].loopRollSource) {
            const { source, startTime } = decks[deckNum].loopRollSource;
            const now = audioContext.currentTime;
            const loopDuration = source.loopEnd - source.loopStart;

            source.stop();
            source.disconnect();
            decks[deckNum].loopRollSource = null;

            // Calcular nuevo punto de tiempo real
            decks[deckNum].pauseTime = startTime + ((now - decks[deckNum].startTime) % loopDuration);
            playTrack(deckNum);
        }
    }

    // Toggle superimpose
    function toggleSuperimpose(deckNum) {
        showDeck[deckNum] = !showDeck[deckNum];
    }

    // Animate all canvas elements
    function animate() {
        drawSuperimposedWaveform();
        requestAnimationFrame(animate);
    }

    // draw superimposed waveform for both decks
    function drawSuperimposedWaveform() {
        const width = superCanvas.width;
        const height = superCanvas.height;
        
        superCtx.clearRect(0, 0, width, height);
        
        // draw deck 1 waveform if shown and loaded
        if (showDeck[1] && decks[1].isLoaded && decks[1].waveformData) {
            drawDeckWaveformSegment(1, width, height);
        }
        
        // draw deck 2 waveform if shown and loaded
        if (showDeck[2] && decks[2].isLoaded && decks[2].waveformData) {
            drawDeckWaveformSegment(2, width, height);
        }
    }

    // draw a segment of the waveform for the top visualizer
    function drawDeckWaveformSegment(deckNum, width, height) {
        if (!decks[deckNum].waveformData || !decks[deckNum].isLoaded) return;
        
        const audioBuffer = decks[deckNum].audioBuffer;
        if (!audioBuffer) return;
        
        const currentPositionSeconds = decks[deckNum].isPlaying ? 
            (audioContext.currentTime - decks[deckNum].startTime) : 
            decks[deckNum].pauseTime;
        
        const durationSeconds = audioBuffer.duration;
        const totalSamples = audioBuffer.length;
        const sampleRate = audioBuffer.sampleRate;
        
        // calculate the number of samples to display
        // 20 seconds of audio, adjust for playback rate
        const viewDuration = 20; 
        const samplesPerView = viewDuration * sampleRate;
        
        // calculate the current sample index and the start/end samples for the view
        const currentSampleIndex = Math.floor(currentPositionSeconds * sampleRate);
        const startSample = Math.max(0, currentSampleIndex - samplesPerView / 2);
        const endSample = Math.min(totalSamples, currentSampleIndex + samplesPerView / 2);
        
        const channelData = audioBuffer.getChannelData(0);
        
        // determine the number of samples per pixel for this zoomed-in view
        const samplesPerPixel = (endSample - startSample) / width;
        
        let color;
        switch(currentWaveformStyle) {
            case 'blue-orange':
                color = deckNum === 1 ? '#0088FF' : '#FF8800';
                break;
            case 'rainbow':
                const hue = (Date.now() / 20 + deckNum * 60) % 360;
                color = `hsl(${hue}, 100%, 60%)`;
                break;
            case 'mono':
                color = deckNum === 1 ? '#CCCCCC' : '#888888';
                break;
            case 'gradient':
                const gradient = superCtx.createLinearGradient(0, 0, width, 0);
                gradient.addColorStop(0, deckNum === 1 ? '#00FF00' : '#FF0000');
                gradient.addColorStop(1, deckNum === 1 ? '#0000FF' : '#FF00FF');
                color = gradient;
                break;
            case 'bars':
                drawBarsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData);
                return;
            case 'dots':
                drawDotsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData);
                return;
            case 'outline':
                drawOutlineWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData);
                return;
            default: // 'default'
                color = deckNum === 1 ? '#00FF00' : '#FF0000';
        }

        superCtx.strokeStyle = color;
        superCtx.lineWidth = 2;
        
        superCtx.beginPath();
        for (let i = 0; i < width; i++) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= totalSamples) break;
            
            let min = 0;
            let max = 0;
            
            // get min and max for the group of samples for this pixel
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < totalSamples) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            
            // draw the line for the pixel
            if (i === 0) {
                superCtx.moveTo(i, height / 2 - min * height / 2);
            } else {
                superCtx.lineTo(i, height / 2 - min * height / 2);
            }
            superCtx.lineTo(i, height / 2 - max * height / 2);
        }
        superCtx.stroke();
    }

    // draw bars style waveform for superimposed view
    function drawBarsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData) {
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        const samplesPerPixel = (endSample - startSample) / width;
        
        for (let i = 0; i < width; i += 4) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;

            let min = 0;
            let max = 0;

            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            const barHeight = (max - min) * height / 2;
            
            superCtx.fillStyle = color;
            superCtx.fillRect(i, height / 2 - barHeight / 2, 3, barHeight);
        }
    }

    // draw dots style waveform for superimposed view
    function drawDotsWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData) {
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        const samplesPerPixel = (endSample - startSample) / width;
        
        superCtx.fillStyle = color;
        
        for (let i = 0; i < width; i += 3) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;

            let min = 0;
            let max = 0;

            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                    if (value > max) max = value;
                }
            }
            
            superCtx.beginPath();
            superCtx.arc(i, height / 2 - min * height / 2, 1.5, 0, Math.PI * 2);
            superCtx.fill();
            
            superCtx.beginPath();
            superCtx.arc(i, height / 2 - max * height / 2, 1.5, 0, Math.PI * 2);
            superCtx.fill();
        }
    }

    // draw outline style waveform for superimposed view
    function drawOutlineWaveformSuperimposed(deckNum, width, height, startSample, endSample, channelData) {
        const color = deckNum === 1 ? '#00FF00' : '#FF0000';
        const samplesPerPixel = (endSample - startSample) / width;
        
        superCtx.strokeStyle = color;
        superCtx.lineWidth = 1;
        
        // draw upper outline
        superCtx.beginPath();
        for (let i = 0; i < width; i++) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;

            let max = 0;
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value > max) max = value;
                }
            }
            
            if (i === 0) {
                superCtx.moveTo(i, height / 2 - max * height / 2);
            } else {
                superCtx.lineTo(i, height / 2 - max * height / 2);
            }
        }
        superCtx.stroke();
        
        // draw lower outline
        superCtx.beginPath();
        for (let i = 0; i < width; i++) {
            const sampleIndex = Math.floor(startSample + i * samplesPerPixel);
            if (sampleIndex >= channelData.length) break;

            let min = 0;
            for (let j = 0; j < samplesPerPixel; j++) {
                const index = sampleIndex + j;
                if (index < channelData.length) {
                    const value = channelData[index];
                    if (value < min) min = value;
                }
            }
            
            if (i === 0) {
                superCtx.moveTo(i, height / 2 - min * height / 2);
            } else {
                superCtx.lineTo(i, height / 2 - min * height / 2);
            }
        }
        superCtx.stroke();
    }

    // Set up MIDI
    function setupMIDI() {
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(
                (midiAccess) => {
                    console.log('MIDI access granted', midiAccess);
                    
                    // List available MIDI inputs
                    const inputs = midiAccess.inputs.values();
                    const inputSelector = document.getElementById('midiInputSelector');
                    
                    for (let input = inputs.next(); input && !input.done; input = inputs.next()) {
                        const option = document.createElement('option');
                        option.value = input.value.id;
                        option.textContent = input.value.name;
                        inputSelector.appendChild(option);
                        
                        // Add event listener
                        input.value.onmidimessage = handleMIDIMessage;
                    }
                },
                (error) => {
                    console.error('MIDI access denied', error);
                }
            );
        }
    }

    // Handle MIDI message
    function handleMIDIMessage(message) {
        // This is a placeholder for MIDI mapping
        // In a real application, you would map MIDI controls to deck functions
        console.log('MIDI message received', message.data);
    }

    // Set up recording
    function setupRecording() {
        // This is a placeholder for recording setup
        // In a real application, you would set up a MediaStreamDestination
    }

    // Toggle recording
    function toggleRecording() {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    }

    // Start recording
    function startRecording() {
        // This is a placeholder for recording implementation
        // In a real application, you would create a MediaRecorder
        isRecording = true;
        document.getElementById('recordButton').textContent = 'Detener';
        document.getElementById('saveButton').style.display = 'inline-block';
    }

    // Stop recording
    function stopRecording() {
        // This is a placeholder for recording implementation
        isRecording = false;
        document.getElementById('recordButton').textContent = 'Grabar';
    }

    // Save recording
    function saveRecording() {
        // This is a placeholder for recording implementation
        alert('Grabación guardada (funcionalidad de demostración)');
    }

    // Toggle equalizer popup
    function toggleEqualizerPopup() {
        const popup = document.getElementById('equalizer-popup');
        popup.style.display = popup.style.display === 'flex' ? 'none' : 'flex';
    }

    // Toggle settings popup
    function toggleSettingsPopup() {
        const popup = document.getElementById('settingsPopup');
        popup.style.display = popup.style.display === 'flex' ? 'none' : 'flex';
    }

    // Apply settings
    function applySettings() {
        // Get selected values
        const waveformStyle = document.getElementById('waveformStyleSelector').value;
        const recordingSource = document.getElementById('recordingSourceSelector').value;
        const midiMapping = document.getElementById('midiMappingSelector').value;
        
        // Apply waveform style
        applyWaveformStyle(waveformStyle);
        
        // Set recording source
        activeRecordingSource = recordingSource;
        
        // Apply MIDI mapping
        applyMIDIMapping(midiMapping);
        
        // Close popup
        toggleSettingsPopup();
    }

    // Apply waveform style
    function applyWaveformStyle(style) {
        currentWaveformStyle = style;
    }

    // Apply MIDI mapping
    function applyMIDIMapping(mapping) {
        // This is a placeholder for MIDI mapping
        // In a real application, you would change how MIDI messages are handled
        console.log('Applying MIDI mapping:', mapping);
    }

    // Initialize when page loads
    window.addEventListener('load', init);
    window.addEventListener('resize', setupCanvasDimensions);
</script>

<!-- Recorder functions appended by assistant: functional WAV export -->
<script>
    async function setupRecording() {
        try {
            // Create or reuse a MediaStreamDestination to capture the master output
            if (!window.recordingDestination) {
                window.recordingDestination = audioContext.createMediaStreamDestination();
            }

            // Connect the end of the EQ chain to the recording destination if possible
            try {
                if (globalEqFilters && globalEqFilters.length > 0) {
                    // Connect last global EQ filter to the recording destination (in addition to destination)
                    globalEqFilters[globalEqFilters.length - 1].connect(window.recordingDestination);
                } else {
                    // Fallback: connect analyserMaster to recording destination
                    analyserMaster.connect(window.recordingDestination);
                }
            } catch (e) {
                console.warn("No globalEqFilters available yet:", e);
                try { analyserMaster.connect(window.recordingDestination); } catch(e2) {}
            }

            // Prepare mic stream (for "mic" recording source)
            window._micStream = null;
            document.getElementById('recordingSourceSelector').addEventListener('change', (e) => {
                activeRecordingSource = e.target.value;
            });

            console.log("Recording setup complete.");
        } catch (err) {
            console.error("setupRecording error:", err);
        }
    }

    // Utility: encode AudioBuffer to WAV (16-bit PCM)
    function encodeWAV(audioBuffer) {
        const numChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const format = 1; // PCM
        const bitsPerSample = 16;

        // interleave
        let samples;
        if (numChannels === 2) {
            const left = audioBuffer.getChannelData(0);
            const right = audioBuffer.getChannelData(1);
            samples = new Int16Array(left.length + right.length);
            let index = 0;
            for (let i = 0; i < left.length; i++) {
                samples[index++] = Math.max(-1, Math.min(1, left[i])) * 0x7fff;
                samples[index++] = Math.max(-1, Math.min(1, right[i])) * 0x7fff;
            }
        } else {
            const ch = audioBuffer.getChannelData(0);
            samples = new Int16Array(ch.length);
            for (let i = 0; i < ch.length; i++) {
                samples[i] = Math.max(-1, Math.min(1, ch[i])) * 0x7fff;
            }
        }

        const blockAlign = numChannels * bitsPerSample / 8;
        const byteRate = sampleRate * blockAlign;
        const dataSize = samples.length * (bitsPerSample / 8);
        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);

        /* RIFF identifier */
        writeString(view, 0, 'RIFF');
        /* file length */
        view.setUint32(4, 36 + dataSize, true);
        /* RIFF type */
        writeString(view, 8, 'WAVE');
        /* format chunk identifier */
        writeString(view, 12, 'fmt ');
        /* format chunk length */
        view.setUint32(16, 16, true);
        /* sample format (raw) */
        view.setUint16(20, format, true);
        /* channel count */
        view.setUint16(22, numChannels, true);
        /* sample rate */
        view.setUint32(24, sampleRate, true);
        /* byte rate (sample rate * block align) */
        view.setUint32(28, byteRate, true);
        /* block align (channel count * bytes per sample) */
        view.setUint16(32, blockAlign, true);
        /* bits per sample */
        view.setUint16(34, bitsPerSample, true);
        /* data chunk identifier */
        writeString(view, 36, 'data');
        /* data chunk length */
        view.setUint32(40, dataSize, true);

        // write the PCM samples
        let offset = 44;
        for (let i = 0; i < samples.length; i++, offset += 2) {
            view.setInt16(offset, samples[i], true);
        }

        return new Blob([view], { type: 'audio/wav' });

        function writeString(dataview, offset, string) {
            for (let i = 0; i < string.length; i++) {
                dataview.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    }

    // Convert arbitrary audio Blob (like webm/opus) to WAV by decoding and re-encoding
    async function convertBlobToWav(blob) {
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        // If channel count >2, downmix to stereo
        if (audioBuffer.numberOfChannels > 2) {
            // create stereo buffer
            const offline = audioContext.createBuffer(2, audioBuffer.length, audioBuffer.sampleRate);
            const outL = offline.getChannelData(0);
            const outR = offline.getChannelData(1);
            for (let i = 0; i < audioBuffer.length; i++) {
                let sumL = 0, sumR = 0;
                for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
                    const d = audioBuffer.getChannelData(ch)[i];
                    if (ch % 2 === 0) sumL += d; else sumR += d;
                }
                outL[i] = sumL / Math.ceil(audioBuffer.numberOfChannels / 2);
                outR[i] = sumR / Math.floor(audioBuffer.numberOfChannels / 2);
            }
            return encodeWAV(offline);
        } else {
            return encodeWAV(audioBuffer);
        }
    }

    // Toggle recording (start/stop)
    async function toggleRecording() {
        try {
            const button = document.getElementById('recordButton');
            if (!isRecording) {
                // Start recording
                // Ensure recordingDestination is ready
                await setupRecording();

                const sourceSelector = document.getElementById('recordingSourceSelector').value;
                let stream;
                if (sourceSelector === 'mic') {
                    // ask for mic permissions and use mic stream
                    window._micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream = window._micStream;
                } else {
                    // master output stream
                    if (!window.recordingDestination) {
                        alert('No recording destination available.');
                        return;
                    }
                    stream = window.recordingDestination.stream;
                }

                // Use MediaRecorder (will likely be webm/opus) and then convert to WAV
                const options = { mimeType: 'audio/webm' };
                try {
                    mediaRecorder = new MediaRecorder(stream, options);
                } catch (e) {
                    // fallback without mimeType
                    mediaRecorder = new MediaRecorder(stream);
                }

                recordedChunks = [];
                mediaRecorder.ondataavailable = (ev) => {
                    if (ev.data && ev.data.size > 0) recordedChunks.push(ev.data);
                };

                mediaRecorder.onstop = async () => {
                    try {
                        const blob = new Blob(recordedChunks, { type: recordedChunks[0].type || 'audio/webm' });
                        // Convert to WAV
                        const wavBlob = await convertBlobToWav(blob);
                        lastWavBlob = wavBlob;
                        // Show save button
                        document.getElementById('saveButton').style.display = 'inline-block';
                        // Create automatic download link (temporary)
                        const url = URL.createObjectURL(wavBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'rtbs_recording_' + new Date().toISOString().replace(/[:.]/g,'-') + '.wav';
                        document.body.appendChild(a);
                        a.click();
                        a.remove();
                        URL.revokeObjectURL(url);
                    } catch (err) {
                        console.error('Error converting recording to WAV:', err);
                        alert('Error al convertir la grabación a WAV. Revisa la consola.');
                    }
                };

                mediaRecorder.start();
                isRecording = true;
                button.textContent = 'Grabando...';
                button.style.background = '#AA0000';
                console.log('Recording started.');
            } else {
                // Stop recording
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
                // stop mic stream if used
                if (window._micStream) {
                    window._micStream.getTracks().forEach(t => t.stop());
                    window._micStream = null;
                }
                isRecording = false;
                document.getElementById('recordButton').textContent = 'Grabar';
                document.getElementById('recordButton').style.background = '';
                console.log('Recording stopped.');
            }
        } catch (err) {
            console.error('toggleRecording error:', err);
            alert('Error al iniciar/detener la grabación. Mira la consola.');
        }
    }

    // Save last WAV to disk (if exists)
    function saveRecording() {
        if (!lastWavBlob) {
            alert('No hay grabación para guardar.');
            return;
        }
        const url = URL.createObjectURL(lastWavBlob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = 'rtbs_recording_' + new Date().toISOString().replace(/[:.]/g,'-') + '.wav';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }
</script>
</body>
</html>
